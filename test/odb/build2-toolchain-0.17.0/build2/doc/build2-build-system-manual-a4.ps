%!PS
%%Title: The build2 Build System
%%Creator: html2ps version 1.0 beta7
%%EndComments
save
2000 dict begin
/d {bind def} bind def
/D {def} d
/t true D
/f false D
/FL [/Times-Roman
/Times-Italic
/Times-Bold
/Times-BoldItalic
/Courier
/Courier-Oblique
/Courier-Bold
/Courier-BoldOblique
/Helvetica
/Helvetica-Oblique
/Helvetica-Bold
/Helvetica-BoldOblique] D
/WF t D
/WI 0 D
/F 1 D
/IW 454 F div D
/IL 672 F div D
/PS 842 D
/EF [0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 2 2] D
/EZ [12 9 19 17 15 13 12 11 12 12 12 12 12 12 12 12 12 12 12 12 12 12 8 8] D
/Ey [0 0 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] D
/EG [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1] D
/Tm [1 1 0.8 0.8 0.8 0.8 0.8 0.8 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1.3 0 0] D
/Bm [1 1 0.5 0.5 0.5 0.5 0.5 0.5 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1 0 0] D
/Lm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 2 0 0 0] D
/Rm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0] D
/EU [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 0 0] D
/NO f D
/YY [[{()}{ h }][{ h }{()}][{()}{()}]] D
/ZZ [[{ (Revision ) ME 0 get join(, June 2024)join }{ Pn }][{ Pn }{ (Revision ) ME 0 get join(, June 2024)join }][{ Ti }{ Ti }]] D
/Ts EZ 0 get D
/TU f D
/Xp t D
/AU f D
/SN 0 D
/Cf t D
/Tp t D
/Fe f D
/TI 2 Ts mul D
/Fm 14 D
/xL 71 D
/xR 71 D
/yL 757 D
/yR 757 D
/Wl 454 F div D
/Wr 454 F div D
/hL 672 F div D
/hR 672 F div D
/FE {newpath Fm neg Fm M CP BB IW Fm add Fm L IW Fm add IL Fm add neg L CP BB
 Fm neg IL Fm add neg L closepath} D
/LA {PM 0 eq{/IW Wl D /IL hL D}{/IW Wr D /IL hR D}ie /W IW D /LL W D /LS W D
 TU PM 0 eq and{IW 56 F div add SA{Sf div}if 0 translate}
 {PM 0 eq{xL yL}{xR yR}ie translate F SA{Sf mul}if dup scale
 CS CF FS Cf{CA CL get VC}if /Bb f D}ie 0 0 M
 TF not Tc or {Cf{gsave SA{1 Sf div dup scale}if Cb VC FE fill grestore}if}if}D
/Pi 0 Ts mul D
/SG [0.8 1 1] D
/Ab 15 D
/J 0 D
/Tc t D
/NH 6 D
/Nf f D
/Pa f D
/LH 1.2 D
/XR f D
/Xr {/pN E D ( [p ) WB pN WB (] )WB} D
/Db [16#FF 16#FF 16#FF] D
/Dt [16#00 16#00 16#00] D
/eA f D
/Fi f D
/bT f D
/Lc t D
/Dl [16#00 16#00 16#00] D
/LX f D
/Br 0.25 D
/IA ([IMAGE]) D
/DS {/PF f D()WB NL NP()pop RC ZF} D
/Gb f D
/Mb t D
/Hc [16#00 16#00 16#00] D
/Bl 3 D
/MI -15.6 D
/DX (DRAFT) D
/Di 0 D
/Tt 113.385826771654 D
/Th { (
) 2 Al()BR (
  ) 0 1 -1 H()4 FZ (The ) SM (build2) ES ( ) ME 1 get join ES()EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
) Ea()BR (
  ) 0 P (Copyright © ) ME 2 get join(.)join BR (  Permission is granted to copy, distribute and/or modify this document under
  the terms of the MIT License.) EP (

  ) 0 P (Revision ) SM() ME 0 get join ES (, June 2024) BR (  This revision of the document describes the ) SM (build2) ES ( ) ME 3 get join(
  )join SM() ME 0 get join(.x)join ES ( series.) EP()} D
/tH {()0 1 -1 H (Table of Contents) EH()} D
/FD 2 D
/Dy 2 D
/cD [16#F0 16#F0 16#F0] D
/FW 0.6 D
/FU [16#00 16#00 16#00] D
/ET {/RM f D /A0 3 D /PN SN D /OU t D /Ou t D /W IW D /LL W D D1
 Ms not TP and{Ip}if /TF f D} D

%-- End of variable part --
/MySymbol 10 dict dup begin
 /FontType 3 D /FontMatrix [.001 0 0 .001 0 0 ] D /FontBBox [25 -10 600 600] D
 /Encoding 256 array D 0 1 255{Encoding exch /.notdef put}for
 Encoding (e) 0 get /euro put
 /Metrics 2 dict D Metrics begin
  /.notdef 0 D
  /euro 651 D
 end
 /BBox 2 dict D BBox begin
  /.notdef [0 0 0 0] D
  /euro [25 -10 600 600] D
 end
 /CharacterDefs 2 dict D CharacterDefs begin
  /.notdef {} D
  /euro{newpath 114 600 moveto 631 600 lineto 464 200 lineto 573 200 lineto
   573 0 lineto -94 0 lineto 31 300 lineto -10 300 lineto closepath clip
   50 setlinewidth newpath 656 300 moveto 381 300 275 0 360 arc stroke
   -19 350 moveto 600 0 rlineto -19 250 moveto 600 0 rlineto stroke}d
 end
 /BuildChar{0 begin
  /char E D /fontdict E D /charname fontdict /Encoding get char get D
  fontdict begin
   Metrics charname get 0 BBox charname get aload pop setcachedevice
   CharacterDefs charname get exec
  end
 end}D
 /BuildChar load 0 3 dict put /UniqueID 1 D
end
definefont pop

/Cd {aload length 2 idiv dup dict begin {D} repeat currentdict end} D
/EX {EC cvx exec} D
/DU {} d
/BB {pop pop}d
/ie {ifelse} d
/E {exch} d
/M {moveto} d
/R {rmoveto} d
/L {lineto} d
/RL {rlineto} d
/CP {currentpoint} d
/SW {stringwidth} d
/GI {getinterval} d
/PI {putinterval} d
/Sg {setgray} d
/LW {setlinewidth} d
/S {dup () ne OU and{0 Co R AT 3 eq LB and HF not and A1 0 ne A2 0 ne or and
 {A2 0 32 A1 0 6 -1 roll awidthshow}{show}ie 0 Co neg R}{pop}ie
 OU PH 3 eq or{/Ms t D}if} D
/U {OU{gsave CP currentfont /FontInfo get /UnderlinePosition get
 0 E currentfont /FontMatrix get dtransform E pop add newpath M dup SW pop
 CJ 0 RL stroke grestore}if} D
/B {OU Br 0 gt and{CP Ts neg Ts .33 mul R gsave 0 Sg
 CP newpath Ts Br mul 0 360 arc closepath UI 2 mod 0 eq{stroke}{fill}ie
 grestore M CP E Ts Br 1 add mul sub E BB /Ms t D}if}D
/NP {Ms TP not or PA and OU and{TP{OR}if f1{mF k2 /mF E D /YC 0 D}if
 TP TU not PM 0 eq or and{showpage}if DU Ip TE not{LA}if 0.6 LW
 /CI 0 D /TP t D /Hs f D /hl 6 D /Hv 6 D /HI hi D /Ms f D}if Bs XO BO M} D
/Np {LE sub CP E pop gt PL 0 eq and{NP}if}D
/Ip {/PN PN 1 add D /Pn RM{1}{4}ie PN Ns D /PM PN SN sub 2 mod D} D
/GP {E dup 3 -1 roll get PN 1 add 2 mod get dup type /integertype eq
 {get 0 get}{E pop}ie}d
/Fc {dup 2 GP exec SW pop /S1 E D dup 1 GP exec SW pop /S2 E D 0 GP exec SW
 pop /S3 E D S1 0 gt{S2 2 mul S1 add S3 2 mul S1 add 2 copy lt{E}if pop}{0}ie
 S2 S3 add 2 copy lt{E}if pop IW .9 mul div dup 1 gt{1 E div}{pop 1}ie}D
/OR {Df{Sd}if tp not{gsave SA{1 Sf div dup scale}if Fe{Cf{FU VC}if FW LW
 1 setlinejoin FE stroke}if /YO {60 F div dup 40 gt{pop 40}if}D /cs CS D
 /cf CF D /CF 0 D /pf PF D /PF f D /Fn FN D /At AT D /AT 0 D /FN EF Hf 1 add
 get D Fz Fs FS ZZ Fc Fz mul Fs FS EU Hf 1 add get dup type /arraytype eq
 Cf and{VC}{pop 0 Sg}ie IW IL neg YO sub M ZZ 1 GP exec dup SW pop neg 0 R Sh
 0 IL neg YO sub M ZZ 0 GP exec Sh ZZ 2 GP exec dup SW pop IW E sub 2 div
 IL neg YO sub M Sh Fz Fs FS NO{/AW IW Pn SW pop sub D AW 2 div IL neg YO sub
 S1 0 gt S2 AW .45 mul gt or S3 AW .45 mul gt or{Fz 2 mul sub}if M Pn Sh}if
 EU Hf get dup type /arraytype eq Cf and{VC}{pop 0 Sg}ie YY Fc /FN EF Hf get D
 Hz mul HS FS IW YO M YY 1 GP exec dup SW pop neg 0 R Sh 0 YO M YY 0 GP exec Sh
 YY 2 GP exec dup SW pop IW E sub 2 div YO M Sh /FN Fn D /AT At D t Pb XO SZ
 SL get neg R /PF pf D grestore /CF 0 D cs cf FS}if}D
/Sh {dup () ne{CP Hz 4 div sub BB show CP CS add BB}{pop}ie}D
/Pb {/OU E D /Ou OU D /PB t D 0 0 M Ba{/Sa save D /BP t D /Fl t D RC /PL 0 D
 /PH 0 D /W IW D /LE IL .7 mul D /EO 0 D SI ZF /YA 0 D /BO 0 D /C1 () D
 BA 0 Ts neg R Bb{Xl Yl Xh Yh}if Bb CP Sa restore M
 {/Yh E D /Xh E D /Yl E D /Xl E D}if /Fl t D}if
 BL /OU t D /HM f D /Ou t D /PB f D} D
/Bs {/BP Ba not D}D
/reencodeISO {
 dup dup findfont dup length dict begin{1 index /FID ne{D}{pop pop}ie}forall
 /Encoding ISOLatin1Encoding D currentdict end definefont} D
/ISOLatin1Encoding [
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash
/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/space/exclamdown/cent/sterling/currency/yen/brokenbar
/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine
/guillemotright/onequarter/onehalf/threequarters/questiondown
/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
/yacute/thorn/ydieresis
] D
[128/backslash 129/parenleft 130/parenright 141/circumflex 142/tilde
143/perthousand 144/dagger 145/daggerdbl 146/Ydieresis 147/scaron 148/Scaron
149/oe 150/OE 151/guilsinglleft 152/guilsinglright 153/quotesinglbase
154/quotedblbase 155/quotedblleft 156/quotedblright 157/endash 158/emdash
159/trademark]
aload length 2 idiv 1 1 3 -1 roll{pop ISOLatin1Encoding 3 1 roll put}for
/colorimage where{pop}{
 /colorimage {
  pop pop /Pr E D {/Cv Pr D /Gr Cv length 3 idiv string D 0 1 Gr length 1 sub
   {Gr E dup /i E 3 mul D Cv i get 0.299 mul Cv i 1 add get 0.587 mul add
    Cv i 2 add get 0.114 mul add cvi put}for Gr} image} D
}ie
/pdfmark where{pop}{userdict /pdfmark /cleartomark load put}ie
WF{FL{reencodeISO D}forall}{4 1 FL length 1 sub{FL E get reencodeISO D}for}ie
/Symbol dup dup findfont dup length dict begin
 {1 index /FID ne{D}{pop pop}ie}forall /Encoding [Encoding aload pop]
 dup 128 /therefore put D currentdict end definefont D

/SF {/CS E D SZ SL CS put FO SL FN put /YI CS LH neg mul D dup ST cvs ( ) join
 CS ST cvs join C1 E join ( NF ) join /C1 E D CS NF /Wf WF FN 0 gt or D
 /BW Wf{( ) SW pop}{0}ie D}D
/NF {/cS E D /cF E D cF 0 ge{FL cF get}{cF -1 eq{/Symbol}{/MySymbol}ie}ie
 findfont cS scalefont setfont} D
/FS {CF or /CF E D FR SL CF put CF CF 0 ge{FN 4 mul add}if E SF} D
/PC {SH /BP f D fin not GL not and{NL}if /HM t D /LL LS D} D
/BS {/TX E D Wf{/fin f D /CW 0 D /LK 0 D /SC 0 D
 /RT TX D {RT ( ) search{/NW E D pop /RT E D /WH NW SW pop D CW WH add LL gt
 {TX SC LK SC sub 1 sub NN GI GL{SH cF cS OC
 2 copy cS ne E cF ne or{NF}{pop pop}ie}{PC /CW WH BW add D}ie
 /SC LK D}
 {GL{JC}if
 /CW CW WH add BW add D /HM t D}ie /GL f D /Ph f D
 /LK LK NW length 1 add add D}{pop exit}ie}loop
 /fin t D TX SC LK SC sub GI SH RT () ne{GL not{CC}if}if
 /LC TX length D /WH RT SW pop D CW WH add Hy{HC SW pop add}if LL gt
 {RT GL{SH cF cS OC 2 copy cS ne E cF ne or{NF}{pop pop}ie
 Hy{/Ph t D}if /LL LS D}{NL /LL LS D SH}ie}
 {RT PC Hy{CC}if /Ph Ph Hy or D}ie RT () ne{/GL t D /HM t D}if}
 {TX SW pop LL le{TX SH}{/NW () D 0 2 TX length 1 sub
 {/CW E D TX 0 CW GI dup SW pop LL gt{pop NW SH /HM t D NL/LL W XO sub MR sub D
 /CW CW 2 sub NN D /TX TX CW TX length CW sub GI D TX BS exit}
 {/NW E D}ie}for}ie}ie /HM t D}D
/CC {C0 length 0 gt{JC}if /C0 [C1 L1 YA YB Mf NS NB TB AF Bw] D
 /C1 () D /L0 L1 D /YA 0 D /YB 0 D /Mf 0 D /NS 0 D /NB 0 D}D
/JC {C0 aload length 0 gt{pop pop pop NB add /NB E D NS add /NS E D
 dup Mf gt{/Mf E D}{pop}ie dup YB gt{/YB E D}{pop}ie
 dup YA gt{/YA E D}{pop}ie pop C1 join /C1 E D /C0 [] D}if}D
/OC {C0 length 0 gt{C1 L1 L0 sub YA YB Mf NS NB TB AF Bw GL C0 aload pop
 /Bw E D /AF E D /TB E D /NB E D /NS E D /Mf E D /YB E D /YA E D /C0 [] D
 /L1 E D /C1 E D Ph{HC SH}if NL /GL E D /Bw E D /AF E D /TB E D /NB E D /NS E D
 /Mf E D /YB E D /YA E D /L1 E D /LL W L1 sub XO sub MR sub WH sub D /CW 0 D
 C1 E join /C1 E D}if}D
/BT {/LB t D dup length string copy RS dup dup () ne E ( ) ne and
 {/CI 0 D /LS LL D /LL W L1 sub XO sub MR sub D BS}
 {dup ( ) eq{/GL f D}if dup () eq L1 0 eq or{pop}{SH /BP f D /Ph f D}ie}ie
 /LB f D} D
/BL {CP E pop XO E M} D
/NL {JC /GL f D /SK W XO sub MR sub L1 sub TB{Bw add}if D
 /YA LF{Mf HM Fl not and PF or{LH mul}if}{0 /LF t D}ie YA 2 copy lt{E}if pop D
 C1 () ne{/FB YB Mf SA{Sf mul}if 4 div 2 copy lt{E}if pop D}if Fl{/Ya YA D}if
 CP E pop YA sub YB sub LE neg lt Fl not and PB not and{NP}if NT TL BL
 OU PF not and PB or{/RE L1 TB{Bw sub}if
 W XO sub MR sub div YA YB add LE BO add div 2 copy lt{E}if pop D
 RE 1 gt{BL 1 RE div dup scale}if}if
 AT 2 le{SK AT mul 2 div YA neg R}if
 AT 3 eq{0 YA neg R TB{/NB NB 1 sub D /NS NS 1 sub D}if /NB NB 1 sub NN D
 /A3 NS 6 mul NB add D NS NB add 0 eq
  {/A1 0 D /A2 0 D}
  {NS 0 eq{/A1 SK NB div dup J gt{pop 0}if D /A2 0 D}{J A3 mul SK lt
   {/A1 J D /A2 SK J NB mul sub NS div dup Ab gt{/A1 0 D pop 0}if D}
   {/A1 SK A3 div D /A2 A1 6 mul D}ie}ie}ie /A1 A1 NN D /A2 A2 NN D}if
 AT 4 eq{0 YA neg R PH 2 le{PD 0 lt{/PD L1 D}if PD M1 gt{/M1 PD D}if
 L1 PD sub M2 gt{/M2 L1 PD sub D}if}{DV ID 1 sub get 0 ge{Lo 0 R}if}ie}if
 F0 cF ne Cs cS ne or{F0 Cs NF}if
 /ms Ms D /Ms f D CP FB sub
 C1 cvx exec XO EO sub L1 add TB{BW sub}if dup LM gt{/LM E D}{pop}ie
 PH 0 eq PH 4 eq or Ms and{HF not{/PO t D /AH t D}if
 BB CP YA add E AT 3 eq LB and{A1 sub}if TB{BW sub}if E BB}
 {pop pop}ie Ms HM PH 3 eq and or{/BP f D /Fl f D}if
 /Lo 0 D /L1 0 D /F0 cF D /Cs cS D BP not{0 YB NN neg R}if
 OU f1 and mF not and{k2 /f1 f D}if
 OU PF not and PB or{RE 1 gt{RE dup scale}if}if /Ms ms Ms or D
 /C1 AF{(Cp )}{()}ie D /YA 0 D /YB 0 D BL
 AT 4 eq LB not and PH 3 ge and
 {ID DV length lt{DV ID get dup 0 ge{DO E sub /Lo E D /L1 Lo D}{pop}ie
 /ID ID 1 add D}if}if /T t D CD{/LN LN 1 add D PD}if
 /PD -1 D /NS 0 D /NB 0 D /TB f D /Ph f D /Mf 0 D /HM f D} D
/RS {/TM E D /CN 0 D TM{10 eq{TM CN ( ) PI}if /CN CN 1 add D}forall
 /CN 0 D /BK HM EN and{0}{1}ie D TM
 {dup 32 ne{TM CN 3 2 roll put /CN CN 1 add D /BK 0 D}
 {pop BK 0 eq{TM CN 32 put /CN CN 1 add D}if /BK 1 D}ie}forall
 TM 0 CN GI dup dup () ne E ( ) ne and
 {dup CN 1 sub get 32 eq{/EN f D}{/EN t D}ie}if} D
/join {2 copy length E length add string dup 4 2 roll 2 index 0 3 index
 PI E length E PI}d
/WR {(\n) search{dup () ne BP not or
 {Li 4 le CP E pop YI Li mul add LE add 0 lt and PL 0 eq and{NP}if
 SH NL pop /Li Li 1 sub D WR}{pop pop WR}ie}{SH}ie /CI 0 D /BP f D} D
/SH {dup dup () ne E ( ) ne and PF or CS Mf gt and{/Mf CS D}if
 T not Wf and{( ) E join /T t D}if dup BP{/MF CS D}if
 AT 3 eq{2 copy length dup 0 gt{/NB E NB add D
 {( ) search{/NS NS 1 add D pop pop}{pop exit}ie}loop}{pop pop}ie}if
 CD PD 0 lt and{dup DC search{SW pop /PD E L1 add D pop pop}{pop}ie}if
 0 Np dup SW pop L1 add /L1 E D dup () ne
 {C1 (\() join E join (\)) join AU AF and UF or Wf and{( U ) join}if
 sF{( s ) join}if ( S ) join
 /C1 E D dup length 1 sub get 32 eq /TB E D /Bw BW D}{pop pop}ie} D
/BG {AI LG BC add add 0 eq} D
/ON {OU{Ty AR AI NN get dup 1 add Ln Ns Ty 2 mod 0 eq{(.  )}{(\)  )}ie join
 dup SW pop neg 0 R CP E 0 lt{0 E M}{pop}ie CP BB show /Ms t D}if} D
/Ln {AR AI 3 -1 roll put}D
/SP {dup CI lt BP not and{dup CI sub 0 E R /CI E D}{pop}ie} D
/BN {PF{WR /HM f D}{BT NL}ie} D
/NN {dup 0 lt{pop 0}if} D
/h {(h) HI ST cvs join cvx exec dup 1 get E Nf{0 get E join}{pop}ie} D
/H {/fn FN D /Hi E 1 add D 1 sub /HL E D /H2 HL 2 add D /GS EZ H2 get D
 E Tm H2 get GS mul BE dup 0 gt{1 sub}{pop EG H2 get dup 0 lt{pop AT}if}ie NA
 WW Np /SL SL 1 add D /FN EF H2 get D GS Ey H2 get FS
 EU H2 get Sc Hs not HL Hl lt and Hs HL hl lt and or Hi 0 eq or
 {/HI Hi D /Hs t D /hl HL D /Hv HL D}if HL Hl lt{/hi Hi D}if
 Nf HI 0 gt and{(h) Hi ST cvs join cvx exec 0 get WB}if
 /HF t D /AH f D /PO f D} D
/EH {Bm H2 get GS mul BE OA /SL SL 1 sub NN D /CF 0 D /FN fn D
 SZ SL get FR SL get FS /HF f D /GS Ts D ()Ec} D
/P {E PF{WR}{PO{EP}{BN}ie Ts 4 mul Np AE not{Tm 0 get Ts mul neg SP}if
 dup 0 ge AH and{Pi Pd}if}ie 1 sub dup 0 lt{pop AV AL get}if /AT E D /PO t D} D
/EP {PF{WR}{BN Ts 4 mul Np}ie AE not{Bm 0 get Ts mul neg SP}if
 /AT AV AL get D /PO f D} D
/BE {E PO{EP}{BN}ie Ts 4 mul Np neg SP} D
/HR {/Aw W EO sub D /RW E dup 0 gt{Aw mul}{neg}ie dup Aw gt{pop Aw}if D /RZ E D
 E BN Ts neg SP 1 sub 2 div Aw RW sub mul EO add CP E pop M PF{0 Ps neg R}if
 0 Np OU{gsave RZ LW Cf{Hc VC}{0 Sg}ie CP BB RW 0 RL CP BB stroke grestore}if
 /CI 0 D /BP f D PF not{Ts neg SP}if /Ms t D} D
/AD {I NL EG 14 get dup 0 lt{pop AT}if NA /AE t D Tm 14 get Ts mul neg SP
 Cf{EU 14 get dup -1 eq{pop CA CL get}if Sc}if} D
/DA {BN ()ES OA /AE f D ()Ec Bm 14 get Ts mul neg SP} D
/PR {/MW E D /Li E D Tm 1 get Ps mul BE 0 NA /FN Fp D /PF t D SI /SL SL 1 add D
 /CF 0 D Ps CS mul Ts div MW WC mul CS mul Ts div dup LL gt PL 0 eq and
 {LL div div}{pop}ie Ey 1 get FS CP E pop LE add YI neg div cvi dup Li lt
 AH and{4 lt YI Li mul 5 mul LE add 0 gt or PL 0 eq and{NP}if}{pop}ie
 EU 1 get Sc /GS Ps D}D
/RP {WR NL () /PF f D SI /FN 0 D ES Bm 1 get Ps mul neg SP OA /GS Ts D} D
/SI {/XO Lm 15 get BC NN mul Lm 16 get AI UI sub NN mul add
 Lm 17 get UI NN mul add Lm 20 get LG NN mul add Ts mul
 PF{Lm 1 get Ps mul add}if EO add D
 /MR Rm 15 get BC NN mul Rm 16 get AI UI sub NN mul add
 Rm 17 get UI NN mul add Rm 20 get LG NN mul add Ts mul
 PF{Rm 1 get Ps mul add}if D /LL W XO sub MR sub D} D
/DT {/cC E D BN /LG LG 1 sub D SI /LG LG 1 add D WW 2 div Np BL} D
/DD {WB Cc 0 eq cC 0 eq and L1 0 eq or Lm 20 get Ts mul L1 sub TB{BW add}if
 Ts 2 div lt or NL /LF E D SI BL /cC 0 D} D
/DL {Dc LG Cc put /Cc E D BG{Tm 18 get Ts mul BE}{BN}ie /LG LG 1 add D BL} D
/LD {BN LG 0 gt{/LG LG 1 sub D}if /Cc Dc LG get D SI
 BG{()Bm 18 get Ts mul BE}if BL} D
/UL {BG{Tm 17 get Ts mul BE}{BN}ie NR AI NN 0 put /UI UI 1 add D
 /AI AI 1 add D SI BL} D
/LU {BN /UI UI 1 sub D /AI AI 1 sub D SI BG{()Bm 17 get Ts mul BE}if BL} D
/OL {E BG{Tm 16 get Ts mul BE}{BN}ie TR AI NN Ty put /Ty E D NR AI NN 1 put
 /AI AI 1 add D SI BL 1 Ln} D
/LO {BN /AI AI 1 sub D /Ty TR AI get D SI BG{()Bm 16 get Ts mul BE}if BL} D
/LI {E BN -1 SP /BP f D /CI 0 D 0 Np NR AI 1 sub NN get 1 eq
 {dup dup 0 gt E 4 le and{/Ty E D}{pop}ie
 /L1 L1 Ty AR AI NN get Ns SW pop XO sub dup 0 lt{pop 0}if add D ( ON )}
 {pop ( B )}ie C1 E join /C1 E D CS Mf gt{/Mf CS D}if BL} D
/BQ {Tm 15 get Ts mul BE /BC BC 1 add D SI BL} D
/QB {Bm 15 get Ts mul BE /BC BC 1 sub D SI BL} D
/Al {E EP 1 sub dup 0 lt{pop AV AL get}if NA} D
/Ea {EP OA} D
/WB {PF{WR}{BT}ie} D
/F1 {WB /FN 0 D CS 0 FS} D
/F2 {WB /FN WI D CS 0 FS} D
/HY {/Hy t D WB /Hy f D} D
/YH {WB} D
/A {/LT E D LT 1 eq{/RN E D}if /Lh E D WB /C1 C1 ( Cp ) join D
 Lc AF not and{Cl Sc}if /AF t D} D
/EA {Lc AF and{Ec}{WB}ie TL Pa AF and Lh 0 ne and
 {( \() Lh join (\)) join /AF f D WB}if /AF f D} D
/TL {C1 ( Tl ) apa /C1 E D} d
/apa {AF OU and Lh 0 ne LT 1 eq or and{LT 1 eq{RN ( /) E ST cvs join}
 {(\() Lh join (\)) join}ie E join join}{pop}ie} d
/Cp {/Xc CP /Yc E D D} D
/SS {Cf{dup 0 ge{EU E get dup -1 eq{pop CA CL get}if}{pop CA CL get}ie Sc}
 {pop}ie SZ SL get /SL SL 1 add D} D
/I {WB 8 SS 1 FS} D
/EM {WB 8 SS /CF CF 1 xor D 0 FS} D
/BD {WB 9 SS 2 FS} D
/TT {WB 10 SS /FN Fp D 0 FS} D
/KB {WB 11 SS /FN Fp D 2 FS} D
/CT {WB 12 SS 1 FS} D
/SM {WB 13 SS /FN Fp D 0 FS} D
/Q {/QL QL 1 add D QO QL 2 mod get La get join WB} D
/EQ {QC QL 2 mod get La get join WB /QL QL 1 sub D} D
/RO {WB -1 SS /CF 0 D 0 FS} D
/SY {WB -1 SS -1 FS} D
/MY {WB -1 SS -2 FS} D
/ES {WB /SL SL 1 sub NN D /CF 0 D /FN FO SL get D SZ SL get FR SL get FS ()Ec}D
/FZ {3 sub 1.2 E exp GS mul E WB TL /C1 C1 ( Cp ) join D /SL SL 1 add D 0 FS} D
/Ef {WB TL ()ES /C1 C1 ( Cp ) join D} D
/BZ {dup /Bf E D FZ}D
/Sc {dup -1 ne Cf and{/CL CL 1 add D dup 0 eq{pop [0 0 0]}if
 dup CA E CL E put VS ( VC ) join C1 E join /C1 E D}{pop}ie} D
/Ec {WB Cf{/CL CL 1 sub NN D CA CL get VS ( VC ) join C1 E join /C1 E D}if} D
/VS {dup type /arraytype eq{([) E {ST cvs join ( ) join}forall (]) join}if} D
/VC {{255 div}forall setrgbcolor} D
/Sl {dup type /integertype ne{Ds}if /La E D WB}d
/UN {WB /UF t D} D
/NU {WB /UF f D} D
/SE {WB /sF t D} D
/XE {WB /sF f D} D
/sM {/C1 C1 ( k1 ) join D}d
/eM {/C1 C1 ( k2 ) join D}d
/k1 {/YC CP E pop Ts add D /mF t D /f1 t D}d
/k2 {gsave 3 LW -9 CP E pop Ts 0.2 mul sub M -9 YC L stroke grestore /mF f D}d
/Ac {/AC E D WB}d
/Ca {eA{( \()join AC join(\) )join}if WB}d
/s {OU{gsave 0 CS .25 mul R dup SW pop CJ 0 RL stroke grestore}if}D
/CJ {AT 3 eq LB and{E dup dup length 1 sub A1 mul E
 {( ) search{pop pop E A2 add E}{pop exit}ie}loop 3 -1 roll add
 W CP pop sub 2 copy gt{E}if pop}if}D
/So {/Co E D} D
/SO {C1 Yo ST cvs join ( So ) join /C1 E D (j) SW pop 2 div Pd} D
/Se {E WB CS E div Pd}D
/Pd {dup type /stringtype eq{SW pop}if dup /L1 E L1 add D
 ST cvs ( 0 R ) join C1 E join /C1 E D} D
/Sp {0.35 CO} D
/Sb {-0.2 CO} D
/CO {OV Io Yo put /Yo E CS mul Yo add D /Io Io 1 add D -1.5 Io mul 3 add FZ SO
 CS Yo add dup YA gt{/YA E D}{pop}ie
 Yo neg dup YB gt{/YB E D}{pop}ie} D
/Es {ES /Io Io 1 sub NN D /Yo OV Io get D SO} D
/SB {/N2 0 D 0 1 NI{/N E D{IX N2 get 0 lt{/N2 N2 1 add D}{exit}ie}loop
 /K WS N get FC N get mul D /NY AY N2 get D /BV NY array D
 0 1 NY 1 sub{/TM K string D currentfile TM readhexstring pop pop BV E TM put}
 for BM N BV put /N2 N2 1 add D}for} D
/IC [{/MA E D /MB 0 D}{2 div /MA E D /MB MA D}{/MB E CS sub D /MA CS D}
 {pop /MA YS AB mul D /MB 1 AB sub YS mul D}{pop /MA 0 D /MB 0 D}] D
/IP {BV N get /N N 1 add D} D
/II {/K E D IX K get 0 lt{/EC E D}if /TY E D
 TY 4 eq{/Y E D /X E D}if TY 3 eq{/AB E D}if
 /XW AX K get D /YW AY K get D /IS SG IT K get get D /XS XW IS mul D
 /YS YW IS mul D YS IC TY get exec /MA MA Fl not{3 add}if D} D
/IM {II /ty TY D /xs XS D /ys YS D /ya YA D /yb YB D /ma MA D /mb MB D /k K D
 /ec EC D /BP f D /CI 0 D WB TL L1 xs add dup XO add MR add W gt
 {pop /ma ma Fl{3 add}if D NL /YA ma D /YB mb D /YS ys D /L1 xs D}
 {/L1 E D ma YA gt{/YA ma D}if mb YB gt{/YB mb D}if}ie /TB f D
 OU{CP E pop YS sub LE neg lt Fl not and PB not and{NP /YA ma D /YB mb D}if
 /BP f D ty ST cvs ( ) join IX k get 0 lt{(\() join ec join (\) ) join}if
 k ST cvs join ty 3 eq{AB ST cvs ( ) join E join}if
 ty 4 eq{X ST cvs ( ) join Y ST cvs join ( ) join E join}if C1 E join
 ( DI ) join FP 2 eq FP 1 eq AF and or{( FM ) join}if
 ( Il Cp ) apa /C1 E D /EN f D}if /HM t D /T f D} D
/DI {II /Xc CP /Yc E D D /YN YW neg D /HM t D /CI 0 D /K2 IX K get D gsave
 TY 4 eq{OX X IS mul add OY FY add YS sub Y IS mul sub}
 {/FY YS D CP MB sub 2 copy /OY E D /OX E D}ie
 translate K2 0 ge{/DP AZ K2 get D /BV BM K2 get D XS YS scale /N 0 D XW YW DP
 [XW 0 0 YN 0 YW] {IP} FC K2 get 1 eq{image}{f 3 colorimage}ie}
 {EX}ie grestore XS 0 R /Ms t D} D
/FM {gsave 0 Sg CP MB sub translate XS neg 0 M 0 YS RL XS 0 RL 0 YS neg RL
 XS neg 0 RL stroke grestore} D
/NA {/AT E D /AL AL 1 add D AV AL AT put} D
/OA {AL 0 gt{/AL AL 1 sub D /AT AV AL get D}if} D
/D1 {/BR {CP E pop E BN Mb{CP E pop eq{0 YI R}if}{pop}ie} D
 /Sn {OU{C1 E ST cvs join ( Ld ) join /C1 E D}{pop}ie} D} D
/D1 {/BR {BN} D /Sn {OU {C1 E ST cvs join ( Ld ) join /C1 E D} {pop} ie} D} D
/TC {/TF t D /ML 0 D HN{SW pop dup ML gt{/ML E D}{pop}ie}forall NP /RM RM not D
 RC /OU Tc D Ep /PN 0 D Ms not TP and{Ip}if /W IW ML sub Ts sub D
 /A0 0 D TH{/BR {( ) join BT} D /Sn {pop} D /Au () D}if} D
/TN {0 eq{E EA PF HF or not XR and{HN E get Xr}{pop}ie}
 {OU{Tn 0 ge{() BN}if /Tn E D}{pop}ie WB}ie} D
/NT {OU LB not and Tn 0 ge and{PL 0 eq{Ms not{CS CF FS}if CP dup
 /y E YA sub D W 9 sub CS -1.8 mul XO L1 add 2 add{y M (.) show}for
 HN Tn get dup SW pop IW E sub y M show CP BB M}if /Tn -1 D}if} D
/Ld {/DN E D HN DN Pn put [/View [/XYZ -4 Fl{PS}{CP YA add US E pop}ie null]
 /Dest DN ST cvs cvn /DEST pdfmark} D
/C {ND 1 eq{1 sub}if TI mul /XO E D NL Nf not{pop()}if 0 3 -1 roll 1 A} D
/OP {BP not{NP}if PN 2 mod 0 eq{/Ms t D NP}if}D
/Ep {Xp PN 2 mod 0 eq and OU and{/Pn (-) D showpage /PM 1 D LA}if}D
/Dg [73 86 88 76 67 68 77] D
/Rd [0 [1 1 0][2 1 0][3 1 0][2 1 1][1 1 1][2 2 1][3 3 1][4 4 1][2 1 2]] D
/Ns {/m E D /c E 32 mul D /j m 1000 idiv D /p j 12 add string D
 c 96 le m 0 gt and{c 32 le {/i 0 D /d 77 D /l 100 D /m m j 1000 mul sub D
  j -1 1 {pop p i d c add put /i i 1 add D}for
  4 -2 0 {/j E D /n m l idiv D /m m n l mul sub D /d Dg j get D
   n 0 gt {/x Rd n get D x 0 get -1 1 {pop p i d c add put /i i 1 add D}for
   p i x 1 get sub Dg x 2 get j add get c add put}if /l l 10 idiv D
  }for p 0 i GI}
  {/i ST length 1 sub D m {1 sub dup 0 ge{dup 26 mod c add 1 add
   ST i 3 -1 roll put 26 idiv dup 0 eq{pop exit}if}if /i i 1 sub D}loop
   ST i ST length i sub GI}ie}
 {m p cvs}ie} D
/US {matrix currentmatrix matrix defaultmatrix matrix invertmatrix
 matrix concatmatrix transform} D
/GB {Gb{US}if}D
/Tl {/Rn E D Xc CP pop ne{
 [/Rect [Xc 1 sub Yc cS 0.25 mul sub GB CP E 1 add E cS 0.85 mul add GB]
  /Subtype /Link /Border [0 0 Cf Lc and LX and AU or{0}{1}ie] Rn type
  /nametype eq {/Dest Rn}{/Action [/Subtype /URI /URI Rn] Cd}ie
  /ANN pdfmark}if} D
/Il {/Rn E D [/Rect [Xc Yc GB Xc XS add Yc YS add GB] /Subtype /Link
 /Border [0 0 0] Rn type /nametype eq{/Dest Rn}
 {/Action [/Subtype /URI /URI Rn] Cd}ie /ANN pdfmark} D
/XP {[{/Z Bz 2 div D Z 0 R Z Z RL Z neg Z RL Z neg Z neg RL Z Z neg RL
 Fi cH 1 eq and{fill}if} {Bz 0 RL 0 Bz RL Bz neg 0 RL 0 Bz neg RL
 Fi cH 1 eq and{fill}if} {0 -5 R Bz 0 RL 0 21 RL Bz neg 0 RL 0 -21 RL}]} D
/MS {/Sm E D WB}D
/O {BN()0 Sm BX} D
/BX {/Bt E D Bt 2 lt{/Ch E D CS 0.8 mul}{11 mul}ie W XO sub MR sub
 2 copy gt{E}if pop /HZ E D Bt 2 eq{Fi not{pop()}if ( )E join /Ft E D TT
 /PF t D /MW 1 D /Li 1 D /Fw Ft SW pop D Fw HZ gt{/HZ Fw 8 add D}if
 HZ ST cvs( )join}{WB Ch ST cvs( )join}ie L1 HZ add XO add MR add W gt{NL}if
 Bt 2 eq{Ft ES Fw neg HM{CS sub}if Pd}if Bt ST cvs join( Bx )join
 Bt 2 eq HM and{CS Pd}if C1 E join /C1 E D /L1 L1 HZ add D /T f D
 ( ) Pd /PF f D Bt 2 lt{YA CS .8 mul lt{/YA CS .8 mul D}if}
 {YB 5 lt{/YB 5 D}if YA 21 lt{/YA 21 D}if}ie /CI 0 D} D
/Bx {dup 2 eq{E /Bz E D}{E /cH E D /Bz CS .8 mul D}ie
 OU {gsave 0 Sg XP E get exec stroke grestore}{pop}ie Bz 0 R /Ms t D}D
/SD {FD 4 mul Dy add DZ NF newpath 0 0 M DX t charpath pathbbox
 3 -1 roll sub /DY E D E dup /X1 E D sub WM mul WX DY mul add WM DG mul E div
 /DF E D /DR WX DF mul DY mul WM div 2 div D} d
/Sd {gsave 0 IL Di mul neg translate IL IW atan Di 0 eq{neg}if rotate
 FD 4 mul Dy add DZ NF DR X1 sub DY 2 div neg M cD VC DX show grestore} d
/Pt {/tp t D Tp{NP /Pn (TP) D 0 Tt neg R Th BN NP Ep ET RC ZF}if /tp f D} D
/RC {/AI 0 D /LG 0 D /BC 0 D /UI 0 D /PF f D /Cc 0 D /cC 0 D /Dc 10 array D
 /NR [0 1 9{pop 0}for] D /La Ds D /AR 10 array D /TR 10 array D /AV 30 array D
 SI /AL -1 D /AT A0 D AT NA /OV 9 array D /Yo 0 D /Co 0 D /Io 0 D /Hy f D
 /Ph f D /CL -1 D Ct Sc}D
/ZF {/FR [0 1 30{pop 0}for] D /SZ [0 1 30{pop 0}for] D /FO [0 1 30{pop 0}for] D
 /SL 0 D /CF 0 D /FN 0 D 0 Ts SF}D
/QO [[(\232)(\253\240)(\234)(\273)(\253)(\233)][(\231)(\253\240)(')(\273)(\253)(`)]] D
/QC [[(\233)(\240\273)(\234)(\253)(\273)(\234)][(`)(\240\273)(')(\253)(\273)(')]] D
/Hf EF length 2 sub D
/Hz EZ Hf get D
/HS Ey Hf get D
/Fz EZ Hf 1 add get D
/Fs Ey Hf 1 add get D
/LE IL D
/Ps EZ 1 get D
/Fp EF 1 get D
/XO 0 D
/YI 0 D
/CI 0 D
/FP 0 D
/WW Ts 7 mul D
/Mf 0 D
/YA 0 D
/YB 0 D
/Cs Ts D
/GS Ts D
/F0 0 D
/NS 0 D
/NB 0 D
/N 0 D
/C0 [] D
/C1 () D
/Lo 0 D
/L1 0 D
/LM 0 D
/PH 0 D
/EC 0 D
/Lh 0 D
/LT 0 D
/CH 1 string D
/ST 16 string D
/CA 9 array D
/HC (\255) D
/HM f D
/PF f D
/EN f D
/TB f D
/UF f D
/sF f D
/AE f D
/AF f D
/BP t D
/CD f D
/PA t D
/GL f D
/T t D
/HF f D
/AH f D
/SA f D
/PB f D
/f1 f D
/mF f D
/OX 0 D
/OY 0 D
/FY 0 D
/EO 0 D
/FB 0 D
/PL 0 D
/Bw 0 D
/PD -1 D
/TP f D
/tp f D
/TH t D
/Ty 4 D
/Tn -1 D
/Fl t D
/LB t D
/PM 1 D
/Ms f D
/Ba f D
/Bb f D
/Hl 3 D
/hl 6 D
/Hv 6 D
/Hs f D
/HI 0 D
/hi 0 D
/PO t D
/TE f D
/LF t D
/BO 0 D
/Sm 1 D
/Bf 3 D
/A1 0 D
/A2 0 D
/Ds 5 D
/QL -1 D
/Cb Db D
/Ct Dt D
/Cl Dl D
[/Creator (html2ps version 1.0 beta7) /Author () /Keywords () /Subject (build system)
 /Title (The build2 Build System) /DOCINFO pdfmark
/ND 1 D
/HN [(1) (1) (1) (1) (2) (7) (15) (26) (27) (30) (35) (38) (40) (45) (50) (54)
(56) (60) (61) (64) (65) (68) (73) (76) (81) (83) (87) (87) (90) (90) (91)
(91) (91) (91) (92) (92) (93) (94) (94) (95) (95) (95) (95) (95) (95) (96)
(96) (96) (96) (96) (97) (97) (97) (98) (98) (98) (98) (98) (99) (99) (99)
(99) (99) (99) (100) (100) (100) (100) (100) (100) (100) (100) (101) (101)
(101) (101) (101) (102) (102) (102) (102) (102) (103) (103) (103) (103)
(103) (104) (104) (104) (104) (105) (105) (105) (105) (106) (106) (106)
(106) (106) (106) (106) (107) (107) (107) (107) (107) (107) (108) (108)
(108) (108) (109) (109) (109) (110) (110) (111) (111) (111) (112) (112)
(112) (113) (113) (113) (113) (113) (113) (113) (114) (114) (114) (114)
(114) (114) (115) (115) (115) (115) (115) (116) (116) (116) (116) (116)
(116) (117) (117) (117) (117) (117) (117) (117) (118) (118) (118) (118)
(118) (118) (119) (122) (122) (125) (127) (128) (129) (130) (138) (138)
(138) (138) (139) (139) (139) (140) (140) (140) (141) (141) (141) (144)
(144) (146) (147) (147) (147) (149) (150) (150) (151) (151) (151) (152)
(153) (154) (154) (155) (155) (156) (156) (163) (166) (167) (168) (174)
(175) (175) (176) (179) (182) (1) (1) (2) (7) (15) (26) (27) (30) (35) (38)
(40) (45) (50) (54) (56) (60) (61) (64) (65) (68) (73) (76) (81) (83) (87)
(87) (90) (90) (91) (91) (91) (91) (92) (92) (93) (94) (94) (95) (95) (95)
(95) (95) (95) (96) (96) (96) (96) (96) (97) (97) (97) (98) (98) (98) (98)
(98) (99) (99) (99) (99) (99) (99) (100) (100) (100) (100) (100) (100) (100)
(100) (101) (101) (101) (101) (101) (102) (102) (102) (102) (102) (103)
(103) (103) (103) (103) (104) (104) (104) (104) (105) (105) (105) (105)
(106) (106) (106) (106) (106) (106) (106) (107) (107) (107) (107) (107)
(107) (108) (108) (108) (108) (109) (109) (109) (110) (110) (111) (111)
(111) (112) (112) (112) (113) (113) (113) (113) (113) (113) (113) (114)
(114) (114) (114) (114) (114) (115) (115) (115) (115) (115) (116) (116)
(116) (116) (116) (116) (117) (117) (117) (117) (117) (117) (117) (118)
(118) (118) (118) (118) (118) (119) (122) (122) (125) (127) (128) (129)
(130) (138) (138) (138) (138) (139) (139) (139) (140) (140) (140) (141)
(141) (141) (144) (144) (146) (147) (147) (147) (149) (150) (150) (151)
(151) (151) (152) (153) (154) (154) (155) (155) (156) (156) (163) (166)
(167) (168) (174) (175) (175) (176) (179) (182)] D
/h0 [()(Table of Contents)] D
/h1 [(1\240\240)(Preface)] D
/h2 [(2\240\240)(1 Introduction)] D
/h3 [(2.1\240\240)(1.1 Hello, World)] D
/h4 [(2.2\240\240)(1.2 Project Structure)] D
/h5 [(2.3\240\240)(1.3 Output Directories and Scopes)] D
/h6 [(2.4\240\240)(1.4 Operations)] D
/h7 [(2.4.1\240\240)(1.4.1 Configuring)] D
/h8 [(2.4.2\240\240)(1.4.2 Testing)] D
/h9 [(2.4.3\240\240)(1.4.3 Installing)] D
/h10 [(2.4.4\240\240)(1.4.4 Distributing)] D
/h11 [(2.5\240\240)(1.5 Target Importation)] D
/h12 [(2.6\240\240)(1.6 Library Exportation and Versioning)] D
/h13 [(2.7\240\240)(1.7 Subprojects and Amalgamations)] D
/h14 [(2.8\240\240)(1.8 Buildfile Language)] D
/h15 [(2.8.1\240\240)(1.8.1 Expansion and Quoting)] D
/h16 [(2.8.2\240\240)(1.8.2 Conditions \(if-else\))] D
/h17 [(2.8.3\240\240)(1.8.3 Pattern Matching \(switch\))] D
/h18 [(2.8.4\240\240)(1.8.4 Repetitions \(for\))] D
/h19 [(2.9\240\240)(1.9 Implementing Unit Testing)] D
/h20 [(2.10\240\240)(1.10 Diagnostics and Debugging)] D
/h21 [(3\240\240)(2 Project Configuration)] D
/h22 [(3.1\240\240)(2.1 config Directive)] D
/h23 [(3.2\240\240)(2.2 Configuration Report)] D
/h24 [(3.3\240\240)(2.3 Configuration Propagation)] D
/h25 [(4\240\240)(3 Targets and Target Types)] D
/h26 [(4.1\240\240)(3.1 Target Types)] D
/h27 [(4.1.1\240\240)(3.1.1 target{})] D
/h28 [(4.1.2\240\240)(3.1.2 alias{} and dir{})] D
/h29 [(4.1.3\240\240)(3.1.3 fsdir{})] D
/h30 [(4.1.4\240\240)(3.1.4 mtime_target{} and path_target{})] D
/h31 [(4.1.5\240\240)(3.1.5 group{})] D
/h32 [(4.1.6\240\240)(3.1.6 file{})] D
/h33 [(4.1.7\240\240)(3.1.7 doc{}, legal{}, and man{})] D
/h34 [(4.1.8\240\240)(3.1.8 exe{})] D
/h35 [(5\240\240)(4 Variables)] D
/h36 [(6\240\240)(5 Functions)] D
/h37 [(6.1\240\240)(5.1 Builtin Functions)] D
/h38 [(6.1.1\240\240)(5.1.1 $builtin.defined\(\))] D
/h39 [(6.1.2\240\240)(5.1.2 $builtin.visibility\(\))] D
/h40 [(6.1.3\240\240)(5.1.3 $builtin.type\(\))] D
/h41 [(6.1.4\240\240)(5.1.4 $builtin.null\(\))] D
/h42 [(6.1.5\240\240)(5.1.5 $builtin.empty\(\))] D
/h43 [(6.1.6\240\240)(5.1.6 $builtin.first\(\), $builtin.second\(\))] D
/h44 [(6.1.7\240\240)(5.1.7 $builtin.quote\(\))] D
/h45 [(6.1.8\240\240)(5.1.8 $builtin.getenv\(\))] D
/h46 [(6.2\240\240)(5.2 String Functions)] D
/h47 [(6.2.1\240\240)(5.2.1 $string.icasecmp\(\))] D
/h48 [(6.2.2\240\240)(5.2.2 $string.contains\(\))] D
/h49 [(6.2.3\240\240)(5.2.3 $string.starts_with\(\))] D
/h50 [(6.2.4\240\240)(5.2.4 $string.ends_with\(\))] D
/h51 [(6.2.5\240\240)(5.2.5 $string.replace\(\))] D
/h52 [(6.2.6\240\240)(5.2.6 $string.trim\(\))] D
/h53 [(6.2.7\240\240)(5.2.7 $string.lcase\(\), $string.ucase\(\))] D
/h54 [(6.2.8\240\240)(5.2.8 $string.size\(\))] D
/h55 [(6.2.9\240\240)(5.2.9 $string.sort\(\))] D
/h56 [(6.2.10\240\240)(5.2.10 $string.find\(\))] D
/h57 [(6.2.11\240\240)(5.2.11 $string.find_index\(\))] D
/h58 [(6.2.12\240\240)(5.2.12 $string.keys\(\))] D
/h59 [(6.3\240\240)(5.3 Integer Functions)] D
/h60 [(6.3.1\240\240)(5.3.1 $integer.string\(\))] D
/h61 [(6.3.2\240\240)(5.3.2 $integer.integer_sequence\(\))] D
/h62 [(6.3.3\240\240)(5.3.3 $integer.size\(\))] D
/h63 [(6.3.4\240\240)(5.3.4 $integer.sort\(\))] D
/h64 [(6.3.5\240\240)(5.3.5 $integer.find\(\))] D
/h65 [(6.3.6\240\240)(5.3.6 $integer.find_index\(\))] D
/h66 [(6.4\240\240)(5.4 Bool Functions)] D
/h67 [(6.4.1\240\240)(5.4.1 $bool.string\(\))] D
/h68 [(6.5\240\240)(5.5 Path Functions)] D
/h69 [(6.5.1\240\240)(5.5.1 $path.string\(\))] D
/h70 [(6.5.2\240\240)(5.5.2 $path.posix_string\(\))] D
/h71 [(6.5.3\240\240)(5.5.3 $path.representation\(\))] D
/h72 [(6.5.4\240\240)(5.5.4 $path.posix_representation\(\))] D
/h73 [(6.5.5\240\240)(5.5.5 $path.absolute\(\))] D
/h74 [(6.5.6\240\240)(5.5.6 $path.simple\(\))] D
/h75 [(6.5.7\240\240)(5.5.7 $path.sub_path\(\))] D
/h76 [(6.5.8\240\240)(5.5.8 $path.super_path\(\))] D
/h77 [(6.5.9\240\240)(5.5.9 $path.directory\(\))] D
/h78 [(6.5.10\240\240)(5.5.10 $path.root_directory\(\))] D
/h79 [(6.5.11\240\240)(5.5.11 $path.leaf\(\))] D
/h80 [(6.5.12\240\240)(5.5.12 $path.relative\(\))] D
/h81 [(6.5.13\240\240)(5.5.13 $path.base\(\))] D
/h82 [(6.5.14\240\240)(5.5.14 $path.extension\(\))] D
/h83 [(6.5.15\240\240)(5.5.15 $path.complete\(\))] D
/h84 [(6.5.16\240\240)(5.5.16 $path.canonicalize\(\))] D
/h85 [(6.5.17\240\240)(5.5.17 $path.normalize\(\), $path.try_normalize\(\))] D
/h86 [(6.5.18\240\240)(5.5.18 $path.actualize\(\), $path.try_actualize\(\))] D
/h87 [(6.5.19\240\240)(5.5.19 $path.size\(\))] D
/h88 [(6.5.20\240\240)(5.5.20 $path.sort\(\))] D
/h89 [(6.5.21\240\240)(5.5.21 $path.find\(\))] D
/h90 [(6.5.22\240\240)(5.5.22 $path.find_index\(\))] D
/h91 [(6.5.23\240\240)(5.5.23 $path.match\(\))] D
/h92 [(6.6\240\240)(5.6 Name Functions)] D
/h93 [(6.6.1\240\240)(5.6.1 $name.name\(\))] D
/h94 [(6.6.2\240\240)(5.6.2 $name.extension\(\))] D
/h95 [(6.6.3\240\240)(5.6.3 $name.directory\(\))] D
/h96 [(6.6.4\240\240)(5.6.4 $name.target_type\(\))] D
/h97 [(6.6.5\240\240)(5.6.5 $name.project\(\))] D
/h98 [(6.6.6\240\240)(5.6.6 $name.is_a\(\))] D
/h99 [(6.6.7\240\240)(5.6.7 $name.filter\(\), $name.filter_out\(\))] D
/h100 [(6.6.8\240\240)(5.6.8 $name.size\(\))] D
/h101 [(6.6.9\240\240)(5.6.9 $name.sort\(\))] D
/h102 [(6.6.10\240\240)(5.6.10 $name.find\(\))] D
/h103 [(6.6.11\240\240)(5.6.11 $name.find_index\(\))] D
/h104 [(6.7\240\240)(5.7 Target Functions)] D
/h105 [(6.7.1\240\240)(5.7.1 $target.path\(\))] D
/h106 [(6.7.2\240\240)(5.7.2 $target.process_path\(\))] D
/h107 [(6.8\240\240)(5.8 Regex Functions)] D
/h108 [(6.8.1\240\240)(5.8.1 $regex.match\(\))] D
/h109 [(6.8.2\240\240)(5.8.2 $regex.find_match\(\))] D
/h110 [(6.8.3\240\240)(5.8.3 $regex.filter_match\(\), $regex.filter_out_match\(\))] D
/h111 [(6.8.4\240\240)(5.8.4 $regex.search\(\))] D
/h112 [(6.8.5\240\240)(5.8.5 $regex.find_search\(\))] D
/h113 [(6.8.6\240\240)(5.8.6 $regex.filter_search\(\), $regex.filter_out_search\(\))] D
/h114 [(6.8.7\240\240)(5.8.7 $regex.replace\(\))] D
/h115 [(6.8.8\240\240)(5.8.8 $regex.replace_lines\(\))] D
/h116 [(6.8.9\240\240)(5.8.9 $regex.split\(\))] D
/h117 [(6.8.10\240\240)(5.8.10 $regex.merge\(\))] D
/h118 [(6.8.11\240\240)(5.8.11 $regex.apply\(\))] D
/h119 [(6.9\240\240)(5.9 JSON Functions)] D
/h120 [(6.9.1\240\240)(5.9.1 $json.value_type\(\))] D
/h121 [(6.9.2\240\240)(5.9.2 $json.value_size\(\))] D
/h122 [(6.9.3\240\240)(5.9.3 $json.member_name\(\))] D
/h123 [(6.9.4\240\240)(5.9.4 $json.member_value\(\))] D
/h124 [(6.9.5\240\240)(5.9.5 $json.object_names\(\))] D
/h125 [(6.9.6\240\240)(5.9.6 $json.array_size\(\))] D
/h126 [(6.9.7\240\240)(5.9.7 $json.array_find\(\))] D
/h127 [(6.9.8\240\240)(5.9.8 $json.array_find_index\(\))] D
/h128 [(6.9.9\240\240)(5.9.9 $json.load\(\))] D
/h129 [(6.9.10\240\240)(5.9.10 $json.parse\(\))] D
/h130 [(6.9.11\240\240)(5.9.11 $json.serialize\(\))] D
/h131 [(6.9.12\240\240)(5.9.12 $json.size\(\))] D
/h132 [(6.9.13\240\240)(5.9.13 $json.keys\(\))] D
/h133 [(6.10\240\240)(5.10 Process Functions)] D
/h134 [(6.10.1\240\240)(5.10.1 $process.run\(\))] D
/h135 [(6.10.2\240\240)(5.10.2 $process.run_regex\(\))] D
/h136 [(6.11\240\240)(5.11 Filesystem Functions)] D
/h137 [(6.11.1\240\240)(5.11.1 $filesystem.file_exists\(\))] D
/h138 [(6.11.2\240\240)(5.11.2 $filesystem.directory_exists\(\))] D
/h139 [(6.11.3\240\240)(5.11.3 $filesystem.path_search\(\))] D
/h140 [(6.12\240\240)(5.12 Project Name Functions)] D
/h141 [(6.12.1\240\240)(5.12.1 $project_name.string\(\))] D
/h142 [(6.12.2\240\240)(5.12.2 $project_name.base\(\))] D
/h143 [(6.12.3\240\240)(5.12.3 $project_name.extension\(\))] D
/h144 [(6.12.4\240\240)(5.12.4 $project_name.variable\(\))] D
/h145 [(6.13\240\240)(5.13 Process Path Functions)] D
/h146 [(6.13.1\240\240)(5.13.1 $process_path.recall\(\))] D
/h147 [(6.13.2\240\240)(5.13.2 $process_path.effect\(\))] D
/h148 [(6.13.3\240\240)(5.13.3 $process_path.name\(\))] D
/h149 [(6.13.4\240\240)(5.13.4 $process_path.checksum\(\))] D
/h150 [(6.13.5\240\240)(5.13.5 $process_path.env_checksum\(\))] D
/h151 [(6.14\240\240)(5.14 Target Triplet Functions)] D
/h152 [(6.14.1\240\240)(5.14.1 $target_triplet.string\(\))] D
/h153 [(6.14.2\240\240)(5.14.2 $target_triplet.representation\(\))] D
/h154 [(7\240\240)(6 Directives)] D
/h155 [(7.1\240\240)(6.1 define)] D
/h156 [(7.2\240\240)(6.2 include)] D
/h157 [(7.3\240\240)(6.3 source)] D
/h158 [(8\240\240)(7 Attributes)] D
/h159 [(9\240\240)(8 Name Patterns)] D
/h160 [(10\240\240)(9 config Module)] D
/h161 [(10.1\240\240)(9.1 Hermetic Build Configurations)] D
/h162 [(11\240\240)(10 test Module)] D
/h163 [(12\240\240)(11 install Module)] D
/h164 [(12.1\240\240)(11.1 Relocatable Installation)] D
/h165 [(12.2\240\240)(11.2 Installation Filtering)] D
/h166 [(13\240\240)(12 version Module)] D
/h167 [(14\240\240)(13 bin Module)] D
/h168 [(14.1\240\240)(13.1 Binary Target Types)] D
/h169 [(14.1.1\240\240)(13.1.1 lib{}, liba{}, libs{})] D
/h170 [(14.1.2\240\240)(13.1.2 libul{}, libue{}, libua{}, libus{})] D
/h171 [(14.1.3\240\240)(13.1.3 obj{}, obje{}, obja{}, objs{})] D
/h172 [(14.1.4\240\240)(13.1.4 bmi{}, bmie{}, bmia{}, bmis{})] D
/h173 [(14.1.5\240\240)(13.1.5 hbmi{}, hbmie{}, hbmia{}, hbmis{})] D
/h174 [(14.1.6\240\240)(13.1.6 def{})] D
/h175 [(15\240\240)(14 cc Module)] D
/h176 [(15.1\240\240)(14.1 C-Common Configuration Variables)] D
/h177 [(15.2\240\240)(14.2 C-Common Target Types)] D
/h178 [(15.2.1\240\240)(14.2.1 pc{}, pca{}, pcs{})] D
/h179 [(15.3\240\240)(14.3 Compilation Internal Scope)] D
/h180 [(15.4\240\240)(14.4 Automatic DLL Symbol Exporting)] D
/h181 [(15.5\240\240)(14.5 Importation of Installed Libraries)] D
/h182 [(15.5.1\240\240)(14.5.1 Rewriting Installed Libraries System Root \(sysroot\))] D
/h183 [(15.6\240\240)(14.6 GCC Compiler Toolchain)] D
/h184 [(15.7\240\240)(14.7 Clang Compiler Toolchain)] D
/h185 [(15.7.1\240\240)(14.7.1 Clang Targeting MSVC)] D
/h186 [(15.8\240\240)(14.8 MSVC Compiler Toolchain)] D
/h187 [(16\240\240)(15 c Module)] D
/h188 [(16.1\240\240)(15.1 C Configuration Variables)] D
/h189 [(16.2\240\240)(15.2 C Target Types)] D
/h190 [(16.2.1\240\240)(15.2.1 c{}, h{})] D
/h191 [(16.3\240\240)(15.3 Objective-C Compilation)] D
/h192 [(16.4\240\240)(15.4 Assembler with C Preprocessor Compilation)] D
/h193 [(16.5\240\240)(15.5 C Compiler Predefined Macro Extraction)] D
/h194 [(17\240\240)(16 cxx Module)] D
/h195 [(17.1\240\240)(16.1 C++ Configuration Variables)] D
/h196 [(17.2\240\240)(16.2 C++ Target Types)] D
/h197 [(17.2.1\240\240)(16.2.1 cxx{}, hxx{}, ixx{}, txx{}, mxx{})] D
/h198 [(17.3\240\240)(16.3 C++ Modules Support)] D
/h199 [(17.3.1\240\240)(16.3.1 Modules Introduction)] D
/h200 [(17.3.2\240\240)(16.3.2 Building Modules)] D
/h201 [(17.3.3\240\240)(16.3.3 Module Symbols Exporting)] D
/h202 [(17.3.4\240\240)(16.3.4 Modules Installation)] D
/h203 [(17.3.5\240\240)(16.3.5 Modules Design Guidelines)] D
/h204 [(17.3.6\240\240)(16.3.6 Modularizing Existing Code)] D
/h205 [(17.4\240\240)(16.4 Objective-C++ Compilation)] D
/h206 [(17.5\240\240)(16.5 C++ Compiler Predefined Macro Extraction)] D
/h207 [(18\240\240)(17 in Module)] D
/h208 [(19\240\240)(18 bash Module)] D
/h209 [(20\240\240)(19 Appendix A \235 JSON Dump Format)] D
/Hr [211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227
228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245
246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263
264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281
282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299
300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317
318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335
336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353
354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371
372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389
390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407
408 409 410 411 412 413 414 415 416 417 418 419]D
/HV [1 1 2 2 2 2 3 3 3 3 2 2 2 2 3 3 3 3 2 2 1 2 2 2 1 2 3 3 3 3 3 3 3
3 1 1 2 3 3 3 3 3 3 3 3 2 3 3 3 3 3 3 3 3 3 3 3 3 2 3 3 3 3 3 3 2 3 2 3
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2 3 3 3 3 3 3 3 3 3 3 3 2 3
3 2 3 3 3 3 3 3 3 3 3 3 3 2 3 3 3 3 3 3 3 3 3 3 3 3 3 2 3 3 2 3 3 3 2 3
3 3 3 2 3 3 3 3 3 2 3 3 1 2 2 2 1 1 1 2 1 1 2 2 1 1 2 3 3 3 3 3 3 1 2 2
3 2 2 2 3 2 2 3 2 1 2 2 3 2 2 2 1 2 2 3 2 3 3 3 3 3 3 2 2 1 1 1]D
/Cn [0 10 0 0 0 4 0 0 0 0 0 0 0 4 0 0 0 0 0 0 3 0 0 0 1 8 0 0 0 0 0 0 0
0 0 14 8 0 0 0 0 0 0 0 0 12 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 1 0 23
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 11 0 0 0 0 0 0 0 0 0 0 0 2
0 0 11 0 0 0 0 0 0 0 0 0 0 0 13 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 3 0 0 0
4 0 0 0 0 5 0 0 0 0 0 2 0 0 3 0 0 0 0 0 1 0 0 2 0 0 0 1 6 0 0 0 0 0 0 8
0 1 0 0 0 1 0 0 1 0 0 5 0 1 0 0 0 0 5 0 1 0 6 0 0 0 0 0 0 0 0 0 0 0]D
Hr length 0 gt{[/PageMode /UseOutlines /DOCVIEW pdfmark}if
/Hn 1 D
0 1 Hr length 1 sub{
 /Bn E D [Cn Bn get dup 0 gt{/Count E HV Bn get Bl ge{neg}if}{pop}ie
 /Dest Hr Bn get dup abs ST cvs cvn E 0 ge{(h)Hn ST cvs join cvx exec
 dup 1 get E Nf{0 get E join}{pop}ie /Hn Hn 1 add D}{()}ie
 /Title E dup length 255 gt{0 255 getinterval}if /OUT pdfmark}for
ZF /FN Fp D Ps 0 FS /WC Wf{( )}{<A1A1>}ie SW pop D
ET RC ZF
/Df f D
/R1 (https://build2.org/doc.xhtml) D
/R2 (https://github.com/build2/libbuild2-autoconf/) D
/R3 (http://semver.org/) D
/R4 (https://gcc.gnu.org/onlinedocs/cpp/System-Headers.html) D
/R5 (https://bugs.llvm.org/show_bug.cgi?id=33273) D
/R6 (https://github.com/build2/cxx20-modules-examples/tree/named-only-import-std) D
/Ba f D /BO 0 D Bs
/UR (-) D
/Ti (The build2 Build System) D
/Au () D
/Df f D
/ME [(0.17)(Build System)(2014-2024 the build2 authors)(build system)] D
Pt
/BO 0 D TC /Ba f D Bs /AU f D /UR () D RC ZF
 tH WB
ND 1 gt{Ts 3 mul Np 0()0 C()BD(The build2 Build System)ES()0 1 TN()EA()BN}if
1 NH le{211(1\240\240)1 C(Preface)WB 2 Sn()211 1 TN()EA()BN}if
1 NH le{212(2\240\240)1 C(1)WB 3 Sn( Intro)HY(duc)HY(tion)YH()212 1 TN()EA()BN}if
2 NH le{213(2.1\240\240)2 C(1.1)WB 4 Sn( Hello, World)213 1 TN()EA()BN}if
2 NH le{214(2.2\240\240)2 C(1.2)WB 5 Sn( Project Struc)HY(ture)YH()214 1 TN()EA()BN}if
2 NH le{215(2.3\240\240)2 C(1.3)WB 6 Sn( Output Direc)HY(to)HY(ries)YH( and Scopes)215 1 TN()EA()BN}if
2 NH le{216(2.4\240\240)2 C(1.4)WB 7 Sn( Oper)HY(a)HY(tions)YH()216 1 TN()EA()BN}if
3 NH le{217(2.4.1\240\240)3 C(1.4.1)WB 8 Sn( Config)HY(ur)HY(ing)YH()217 1 TN()EA()BN}if
3 NH le{218(2.4.2\240\240)3 C(1.4.2)WB 9 Sn( Testing)218 1 TN()EA()BN}if
3 NH le{219(2.4.3\240\240)3 C(1.4.3)WB 10 Sn( Installing)219 1 TN()EA()BN}if
3 NH le{220(2.4.4\240\240)3 C(1.4.4)WB 11 Sn( Distribut)HY(ing)YH()220 1 TN()EA()BN}if
2 NH le{221(2.5\240\240)2 C(1.5)WB 12 Sn( Target Impor)HY(ta)HY(tion)YH()221 1 TN()EA()BN}if
2 NH le{222(2.6\240\240)2 C(1.6)WB 13 Sn( Library Expor)HY(ta)HY(tion)YH( and Version)HY(ing)YH()222 1 TN()EA()BN}if
2 NH le{223(2.7\240\240)2 C(1.7)WB 14 Sn( Subpro)HY(jects)YH( and Amal)HY(ga)HY(ma)HY(tions)YH()223 1 TN()EA()BN}if
2 NH le{224(2.8\240\240)2 C(1.8)WB 15 Sn( Build)HY(file)YH( Language)224 1 TN()EA()BN}if
3 NH le{225(2.8.1\240\240)3 C(1.8.1)WB 16 Sn( Expan)HY(sion)YH( and Quoting)225 1 TN()EA()BN}if
3 NH le{226(2.8.2\240\240)3 C(1.8.2)WB 17 Sn( Condi)HY(tions)YH( \201)SM(if-else)ES(\202)226 1 TN()EA()BN}if
3 NH le{227(2.8.3\240\240)3 C(1.8.3)WB 18 Sn( Pattern Match)HY(ing)YH( \201)SM(switch)ES(\202)227 1 TN()EA()BN}if
3 NH le{228(2.8.4\240\240)3 C(1.8.4)WB 19 Sn( Repe)HY(ti)HY(tions)YH( \201)SM(for)ES(\202)228 1 TN()EA()BN}if
2 NH le{229(2.9\240\240)2 C(1.9)WB 20 Sn( Imple)HY(ment)HY(ing)YH( Unit Testing)229 1 TN()EA()BN}if
2 NH le{230(2.10\240\240)2 C(1.10)WB 21 Sn( Diag)HY(nos)HY(tics)YH( and Debug)HY(ging)YH()230 1 TN()EA()BN}if
1 NH le{231(3\240\240)1 C(2)WB 22 Sn( Project Config)HY(u)HY(ra)HY(tion)YH()231 1 TN()EA()BN}if
2 NH le{232(3.1\240\240)2 C(2.1)WB 23 Sn( )SM(config)ES( Direc)HY(tive)YH()232 1 TN()EA()BN}if
2 NH le{233(3.2\240\240)2 C(2.2)WB 24 Sn( Config)HY(u)HY(ra)HY(tion)YH( Report)233 1 TN()EA()BN}if
2 NH le{234(3.3\240\240)2 C(2.3)WB 25 Sn( Config)HY(u)HY(ra)HY(tion)YH( Prop)HY(a)HY(ga)HY(tion)YH()234 1 TN()EA()BN}if
1 NH le{235(4\240\240)1 C(3)WB 26 Sn( Targets and Target Types)235 1 TN()EA()BN}if
2 NH le{236(4.1\240\240)2 C(3.1)WB 27 Sn( Target Types)236 1 TN()EA()BN}if
3 NH le{237(4.1.1\240\240)3 C(3.1.1)WB 28 Sn( )SM(target{})ES()237 1 TN()EA()BN}if
3 NH le{238(4.1.2\240\240)3 C(3.1.2)WB 29 Sn( )SM(alias{})ES( and
  )SM(dir{})ES()238 1 TN()EA()BN}if
3 NH le{239(4.1.3\240\240)3 C(3.1.3)WB 30 Sn( )SM(fsdir{})ES()239 1 TN()EA()BN}if
3 NH le{240(4.1.4\240\240)3 C(3.1.4)WB 31 Sn( )SM(mtime_target{})ES( and
  )SM(path_target{})ES()240 1 TN()EA()BN}if
3 NH le{241(4.1.5\240\240)3 C(3.1.5)WB 32 Sn( )SM(group{})ES()241 1 TN()EA()BN}if
3 NH le{242(4.1.6\240\240)3 C(3.1.6)WB 33 Sn( )SM(file{})ES()242 1 TN()EA()BN}if
3 NH le{243(4.1.7\240\240)3 C(3.1.7)WB 34 Sn( )SM(doc{})ES(, )SM(legal{})ES(,
  and )SM(man{})ES()243 1 TN()EA()BN}if
3 NH le{244(4.1.8\240\240)3 C(3.1.8)WB 35 Sn( )SM(exe{})ES()244 1 TN()EA()BN}if
1 NH le{245(5\240\240)1 C(4)WB 36 Sn( Vari)HY(ables)YH()245 1 TN()EA()BN}if
1 NH le{246(6\240\240)1 C(5)WB 37 Sn( Func)HY(tions)YH()246 1 TN()EA()BN}if
2 NH le{247(6.1\240\240)2 C(5.1)WB 38 Sn( Builtin Func)HY(tions)YH()247 1 TN()EA()BN}if
3 NH le{248(6.1.1\240\240)3 C(5.1.1)WB 39 Sn(
  )SM($builtin.defined\201\202)ES()248 1 TN()EA()BN}if
3 NH le{249(6.1.2\240\240)3 C(5.1.2)WB 40 Sn(
  )SM($builtin.visi)HY(bil)HY(ity)YH(\201\202)ES()249 1 TN()EA()BN}if
3 NH le{250(6.1.3\240\240)3 C(5.1.3)WB 41 Sn( )SM($builtin.type\201\202)ES()250 1 TN()EA()BN}if
3 NH le{251(6.1.4\240\240)3 C(5.1.4)WB 42 Sn( )SM($builtin.null\201\202)ES()251 1 TN()EA()BN}if
3 NH le{252(6.1.5\240\240)3 C(5.1.5)WB 43 Sn( )SM($builtin.empty\201\202)ES()252 1 TN()EA()BN}if
3 NH le{253(6.1.6\240\240)3 C(5.1.6)WB 44 Sn( )SM($builtin.first\201\202)ES(,
  )SM($builtin.second\201\202)ES()253 1 TN()EA()BN}if
3 NH le{254(6.1.7\240\240)3 C(5.1.7)WB 45 Sn( )SM($builtin.quote\201\202)ES()254 1 TN()EA()BN}if
3 NH le{255(6.1.8\240\240)3 C(5.1.8)WB 46 Sn( )SM($builtin.getenv\201\202)ES()255 1 TN()EA()BN}if
2 NH le{256(6.2\240\240)2 C(5.2)WB 47 Sn( String Func)HY(tions)YH()256 1 TN()EA()BN}if
3 NH le{257(6.2.1\240\240)3 C(5.2.1)WB 48 Sn(
  )SM($string.icas)HY(ecmp)YH(\201\202)ES()257 1 TN()EA()BN}if
3 NH le{258(6.2.2\240\240)3 C(5.2.2)WB 49 Sn(
  )SM($string.contains\201\202)ES()258 1 TN()EA()BN}if
3 NH le{259(6.2.3\240\240)3 C(5.2.3)WB 50 Sn(
  )SM($string.starts_with\201\202)ES()259 1 TN()EA()BN}if
3 NH le{260(6.2.4\240\240)3 C(5.2.4)WB 51 Sn(
  )SM($string.ends_with\201\202)ES()260 1 TN()EA()BN}if
3 NH le{261(6.2.5\240\240)3 C(5.2.5)WB 52 Sn( )SM($string.replace\201\202)ES()261 1 TN()EA()BN}if
3 NH le{262(6.2.6\240\240)3 C(5.2.6)WB 53 Sn( )SM($string.trim\201\202)ES()262 1 TN()EA()BN}if
3 NH le{263(6.2.7\240\240)3 C(5.2.7)WB 54 Sn( )SM($string.lcase\201\202)ES(,
  )SM($string.ucase\201\202)ES()263 1 TN()EA()BN}if
3 NH le{264(6.2.8\240\240)3 C(5.2.8)WB 55 Sn( )SM($string.size\201\202)ES()264 1 TN()EA()BN}if
3 NH le{265(6.2.9\240\240)3 C(5.2.9)WB 56 Sn( )SM($string.sort\201\202)ES()265 1 TN()EA()BN}if
3 NH le{266(6.2.10\240\240)3 C(5.2.10)WB 57 Sn( )SM($string.find\201\202)ES()266 1 TN()EA()BN}if
3 NH le{267(6.2.11\240\240)3 C(5.2.11)WB 58 Sn(
  )SM($string.find_index\201\202)ES()267 1 TN()EA()BN}if
3 NH le{268(6.2.12\240\240)3 C(5.2.12)WB 59 Sn( )SM($string.keys\201\202)ES()268 1 TN()EA()BN}if
2 NH le{269(6.3\240\240)2 C(5.3)WB 60 Sn( Integer Func)HY(tions)YH()269 1 TN()EA()BN}if
3 NH le{270(6.3.1\240\240)3 C(5.3.1)WB 61 Sn( )SM($integer.string\201\202)ES()270 1 TN()EA()BN}if
3 NH le{271(6.3.2\240\240)3 C(5.3.2)WB 62 Sn(
  )SM($integer.integer_sequence\201\202)ES()271 1 TN()EA()BN}if
3 NH le{272(6.3.3\240\240)3 C(5.3.3)WB 63 Sn( )SM($integer.size\201\202)ES()272 1 TN()EA()BN}if
3 NH le{273(6.3.4\240\240)3 C(5.3.4)WB 64 Sn( )SM($integer.sort\201\202)ES()273 1 TN()EA()BN}if
3 NH le{274(6.3.5\240\240)3 C(5.3.5)WB 65 Sn( )SM($integer.find\201\202)ES()274 1 TN()EA()BN}if
3 NH le{275(6.3.6\240\240)3 C(5.3.6)WB 66 Sn(
  )SM($integer.find_index\201\202)ES()275 1 TN()EA()BN}if
2 NH le{276(6.4\240\240)2 C(5.4)WB 67 Sn( Bool Func)HY(tions)YH()276 1 TN()EA()BN}if
3 NH le{277(6.4.1\240\240)3 C(5.4.1)WB 68 Sn( )SM($bool.string\201\202)ES()277 1 TN()EA()BN}if
2 NH le{278(6.5\240\240)2 C(5.5)WB 69 Sn( Path Func)HY(tions)YH()278 1 TN()EA()BN}if
3 NH le{279(6.5.1\240\240)3 C(5.5.1)WB 70 Sn( )SM($path.string\201\202)ES()279 1 TN()EA()BN}if
3 NH le{280(6.5.2\240\240)3 C(5.5.2)WB 71 Sn(
  )SM($path.posix_string\201\202)ES()280 1 TN()EA()BN}if
3 NH le{281(6.5.3\240\240)3 C(5.5.3)WB 72 Sn(
  )SM($path.repre)HY(sen)HY(ta)HY(tion)YH(\201\202)ES()281 1 TN()EA()BN}if
3 NH le{282(6.5.4\240\240)3 C(5.5.4)WB 73 Sn(
  )SM($path.posix_repre)HY(sen)HY(ta)HY(tion)YH(\201\202)ES()282 1 TN()EA()BN}if
3 NH le{283(6.5.5\240\240)3 C(5.5.5)WB 74 Sn( )SM($path.abso)HY(lute)YH(\201\202)ES()283 1 TN()EA()BN}if
3 NH le{284(6.5.6\240\240)3 C(5.5.6)WB 75 Sn( )SM($path.simple\201\202)ES()284 1 TN()EA()BN}if
3 NH le{285(6.5.7\240\240)3 C(5.5.7)WB 76 Sn( )SM($path.sub_path\201\202)ES()285 1 TN()EA()BN}if
3 NH le{286(6.5.8\240\240)3 C(5.5.8)WB 77 Sn(
  )SM($path.super_path\201\202)ES()286 1 TN()EA()BN}if
3 NH le{287(6.5.9\240\240)3 C(5.5.9)WB 78 Sn( )SM($path.direc)HY(tory)YH(\201\202)ES()287 1 TN()EA()BN}if
3 NH le{288(6.5.10\240\240)3 C(5.5.10)WB 79 Sn(
  )SM($path.root_direc)HY(tory)YH(\201\202)ES()288 1 TN()EA()BN}if
3 NH le{289(6.5.11\240\240)3 C(5.5.11)WB 80 Sn( )SM($path.leaf\201\202)ES()289 1 TN()EA()BN}if
3 NH le{290(6.5.12\240\240)3 C(5.5.12)WB 81 Sn( )SM($path.rela)HY(tive)YH(\201\202)ES()290 1 TN()EA()BN}if
3 NH le{291(6.5.13\240\240)3 C(5.5.13)WB 82 Sn( )SM($path.base\201\202)ES()291 1 TN()EA()BN}if
3 NH le{292(6.5.14\240\240)3 C(5.5.14)WB 83 Sn( )SM($path.exten)HY(sion)YH(\201\202)ES()292 1 TN()EA()BN}if
3 NH le{293(6.5.15\240\240)3 C(5.5.15)WB 84 Sn( )SM($path.complete\201\202)ES()293 1 TN()EA()BN}if
3 NH le{294(6.5.16\240\240)3 C(5.5.16)WB 85 Sn(
  )SM($path.canon)HY(i)HY(cal)HY(ize)YH(\201\202)ES()294 1 TN()EA()BN}if
3 NH le{295(6.5.17\240\240)3 C(5.5.17)WB 86 Sn( )SM($path.normal)HY(ize)YH(\201\202)ES(,
  )SM($path.try_normal)HY(ize)YH(\201\202)ES()295 1 TN()EA()BN}if
3 NH le{296(6.5.18\240\240)3 C(5.5.18)WB 87 Sn( )SM($path.actu)HY(al)HY(ize)YH(\201\202)ES(,
  )SM($path.try_actu)HY(al)HY(ize)YH(\201\202)ES()296 1 TN()EA()BN}if
3 NH le{297(6.5.19\240\240)3 C(5.5.19)WB 88 Sn( )SM($path.size\201\202)ES()297 1 TN()EA()BN}if
3 NH le{298(6.5.20\240\240)3 C(5.5.20)WB 89 Sn( )SM($path.sort\201\202)ES()298 1 TN()EA()BN}if
3 NH le{299(6.5.21\240\240)3 C(5.5.21)WB 90 Sn( )SM($path.find\201\202)ES()299 1 TN()EA()BN}if
3 NH le{300(6.5.22\240\240)3 C(5.5.22)WB 91 Sn(
  )SM($path.find_index\201\202)ES()300 1 TN()EA()BN}if
3 NH le{301(6.5.23\240\240)3 C(5.5.23)WB 92 Sn( )SM($path.match\201\202)ES()301 1 TN()EA()BN}if
2 NH le{302(6.6\240\240)2 C(5.6)WB 93 Sn( Name Func)HY(tions)YH()302 1 TN()EA()BN}if
3 NH le{303(6.6.1\240\240)3 C(5.6.1)WB 94 Sn( )SM($name.name\201\202)ES()303 1 TN()EA()BN}if
3 NH le{304(6.6.2\240\240)3 C(5.6.2)WB 95 Sn( )SM($name.exten)HY(sion)YH(\201\202)ES()304 1 TN()EA()BN}if
3 NH le{305(6.6.3\240\240)3 C(5.6.3)WB 96 Sn( )SM($name.direc)HY(tory)YH(\201\202)ES()305 1 TN()EA()BN}if
3 NH le{306(6.6.4\240\240)3 C(5.6.4)WB 97 Sn(
  )SM($name.target_type\201\202)ES()306 1 TN()EA()BN}if
3 NH le{307(6.6.5\240\240)3 C(5.6.5)WB 98 Sn( )SM($name.project\201\202)ES()307 1 TN()EA()BN}if
3 NH le{308(6.6.6\240\240)3 C(5.6.6)WB 99 Sn( )SM($name.is_a\201\202)ES()308 1 TN()EA()BN}if
3 NH le{309(6.6.7\240\240)3 C(5.6.7)WB 100 Sn( )SM($name.filter\201\202)ES(,
  )SM($name.filter_out\201\202)ES()309 1 TN()EA()BN}if
3 NH le{310(6.6.8\240\240)3 C(5.6.8)WB 101 Sn( )SM($name.size\201\202)ES()310 1 TN()EA()BN}if
3 NH le{311(6.6.9\240\240)3 C(5.6.9)WB 102 Sn( )SM($name.sort\201\202)ES()311 1 TN()EA()BN}if
3 NH le{312(6.6.10\240\240)3 C(5.6.10)WB 103 Sn( )SM($name.find\201\202)ES()312 1 TN()EA()BN}if
3 NH le{313(6.6.11\240\240)3 C(5.6.11)WB 104 Sn(
  )SM($name.find_index\201\202)ES()313 1 TN()EA()BN}if
2 NH le{314(6.7\240\240)2 C(5.7)WB 105 Sn( Target Func)HY(tions)YH()314 1 TN()EA()BN}if
3 NH le{315(6.7.1\240\240)3 C(5.7.1)WB 106 Sn( )SM($target.path\201\202)ES()315 1 TN()EA()BN}if
3 NH le{316(6.7.2\240\240)3 C(5.7.2)WB 107 Sn(
  )SM($target.process_path\201\202)ES()316 1 TN()EA()BN}if
2 NH le{317(6.8\240\240)2 C(5.8)WB 108 Sn( Regex Func)HY(tions)YH()317 1 TN()EA()BN}if
3 NH le{318(6.8.1\240\240)3 C(5.8.1)WB 109 Sn( )SM($regex.match\201\202)ES()318 1 TN()EA()BN}if
3 NH le{319(6.8.2\240\240)3 C(5.8.2)WB 110 Sn(
  )SM($regex.find_match\201\202)ES()319 1 TN()EA()BN}if
3 NH le{320(6.8.3\240\240)3 C(5.8.3)WB 111 Sn(
  )SM($regex.filter_match\201\202)ES(,
  )SM($regex.filter_out_match\201\202)ES()320 1 TN()EA()BN}if
3 NH le{321(6.8.4\240\240)3 C(5.8.4)WB 112 Sn( )SM($regex.search\201\202)ES()321 1 TN()EA()BN}if
3 NH le{322(6.8.5\240\240)3 C(5.8.5)WB 113 Sn(
  )SM($regex.find_search\201\202)ES()322 1 TN()EA()BN}if
3 NH le{323(6.8.6\240\240)3 C(5.8.6)WB 114 Sn(
  )SM($regex.filter_search\201\202)ES(,
  )SM($regex.filter_out_search\201\202)ES()323 1 TN()EA()BN}if
3 NH le{324(6.8.7\240\240)3 C(5.8.7)WB 115 Sn( )SM($regex.replace\201\202)ES()324 1 TN()EA()BN}if
3 NH le{325(6.8.8\240\240)3 C(5.8.8)WB 116 Sn(
  )SM($regex.replace_lines\201\202)ES()325 1 TN()EA()BN}if
3 NH le{326(6.8.9\240\240)3 C(5.8.9)WB 117 Sn( )SM($regex.split\201\202)ES()326 1 TN()EA()BN}if
3 NH le{327(6.8.10\240\240)3 C(5.8.10)WB 118 Sn( )SM($regex.merge\201\202)ES()327 1 TN()EA()BN}if
3 NH le{328(6.8.11\240\240)3 C(5.8.11)WB 119 Sn( )SM($regex.apply\201\202)ES()328 1 TN()EA()BN}if
2 NH le{329(6.9\240\240)2 C(5.9)WB 120 Sn( JSON Func)HY(tions)YH()329 1 TN()EA()BN}if
3 NH le{330(6.9.1\240\240)3 C(5.9.1)WB 121 Sn(
  )SM($json.value_type\201\202)ES()330 1 TN()EA()BN}if
3 NH le{331(6.9.2\240\240)3 C(5.9.2)WB 122 Sn(
  )SM($json.value_size\201\202)ES()331 1 TN()EA()BN}if
3 NH le{332(6.9.3\240\240)3 C(5.9.3)WB 123 Sn(
  )SM($json.member_name\201\202)ES()332 1 TN()EA()BN}if
3 NH le{333(6.9.4\240\240)3 C(5.9.4)WB 124 Sn(
  )SM($json.member_value\201\202)ES()333 1 TN()EA()BN}if
3 NH le{334(6.9.5\240\240)3 C(5.9.5)WB 125 Sn(
  )SM($json.object_names\201\202)ES()334 1 TN()EA()BN}if
3 NH le{335(6.9.6\240\240)3 C(5.9.6)WB 126 Sn(
  )SM($json.array_size\201\202)ES()335 1 TN()EA()BN}if
3 NH le{336(6.9.7\240\240)3 C(5.9.7)WB 127 Sn(
  )SM($json.array_find\201\202)ES()336 1 TN()EA()BN}if
3 NH le{337(6.9.8\240\240)3 C(5.9.8)WB 128 Sn(
  )SM($json.array_find_index\201\202)ES()337 1 TN()EA()BN}if
3 NH le{338(6.9.9\240\240)3 C(5.9.9)WB 129 Sn( )SM($json.load\201\202)ES()338 1 TN()EA()BN}if
3 NH le{339(6.9.10\240\240)3 C(5.9.10)WB 130 Sn( )SM($json.parse\201\202)ES()339 1 TN()EA()BN}if
3 NH le{340(6.9.11\240\240)3 C(5.9.11)WB 131 Sn( )SM($json.seri)HY(al)HY(ize)YH(\201\202)ES()340 1 TN()EA()BN}if
3 NH le{341(6.9.12\240\240)3 C(5.9.12)WB 132 Sn( )SM($json.size\201\202)ES()341 1 TN()EA()BN}if
3 NH le{342(6.9.13\240\240)3 C(5.9.13)WB 133 Sn( )SM($json.keys\201\202)ES()342 1 TN()EA()BN}if
2 NH le{343(6.10\240\240)2 C(5.10)WB 134 Sn( Process Func)HY(tions)YH()343 1 TN()EA()BN}if
3 NH le{344(6.10.1\240\240)3 C(5.10.1)WB 135 Sn( )SM($process.run\201\202)ES()344 1 TN()EA()BN}if
3 NH le{345(6.10.2\240\240)3 C(5.10.2)WB 136 Sn(
  )SM($process.run_regex\201\202)ES()345 1 TN()EA()BN}if
2 NH le{346(6.11\240\240)2 C(5.11)WB 137 Sn( Filesys)HY(tem)YH( Func)HY(tions)YH()346 1 TN()EA()BN}if
3 NH le{347(6.11.1\240\240)3 C(5.11.1)WB 138 Sn(
  )SM($filesys)HY(tem)YH(.file_exists\201\202)ES()347 1 TN()EA()BN}if
3 NH le{348(6.11.2\240\240)3 C(5.11.2)WB 139 Sn(
  )SM($filesys)HY(tem)YH(.direc)HY(tory)YH(_exists\201\202)ES()348 1 TN()EA()BN}if
3 NH le{349(6.11.3\240\240)3 C(5.11.3)WB 140 Sn(
  )SM($filesys)HY(tem)YH(.path_search\201\202)ES()349 1 TN()EA()BN}if
2 NH le{350(6.12\240\240)2 C(5.12)WB 141 Sn( Project Name Func)HY(tions)YH()350 1 TN()EA()BN}if
3 NH le{351(6.12.1\240\240)3 C(5.12.1)WB 142 Sn(
  )SM($project_name.string\201\202)ES()351 1 TN()EA()BN}if
3 NH le{352(6.12.2\240\240)3 C(5.12.2)WB 143 Sn(
  )SM($project_name.base\201\202)ES()352 1 TN()EA()BN}if
3 NH le{353(6.12.3\240\240)3 C(5.12.3)WB 144 Sn(
  )SM($project_name.exten)HY(sion)YH(\201\202)ES()353 1 TN()EA()BN}if
3 NH le{354(6.12.4\240\240)3 C(5.12.4)WB 145 Sn(
  )SM($project_name.vari)HY(able)YH(\201\202)ES()354 1 TN()EA()BN}if
2 NH le{355(6.13\240\240)2 C(5.13)WB 146 Sn( Process Path Func)HY(tions)YH()355 1 TN()EA()BN}if
3 NH le{356(6.13.1\240\240)3 C(5.13.1)WB 147 Sn(
  )SM($process_path.recall\201\202)ES()356 1 TN()EA()BN}if
3 NH le{357(6.13.2\240\240)3 C(5.13.2)WB 148 Sn(
  )SM($process_path.effect\201\202)ES()357 1 TN()EA()BN}if
3 NH le{358(6.13.3\240\240)3 C(5.13.3)WB 149 Sn(
  )SM($process_path.name\201\202)ES()358 1 TN()EA()BN}if
3 NH le{359(6.13.4\240\240)3 C(5.13.4)WB 150 Sn(
  )SM($process_path.check)HY(sum)YH(\201\202)ES()359 1 TN()EA()BN}if
3 NH le{360(6.13.5\240\240)3 C(5.13.5)WB 151 Sn(
  )SM($process_path.env_check)HY(sum)YH(\201\202)ES()360 1 TN()EA()BN}if
2 NH le{361(6.14\240\240)2 C(5.14)WB 152 Sn( Target Triplet Func)HY(tions)YH()361 1 TN()EA()BN}if
3 NH le{362(6.14.1\240\240)3 C(5.14.1)WB 153 Sn(
  )SM($target_triplet.string\201\202)ES()362 1 TN()EA()BN}if
3 NH le{363(6.14.2\240\240)3 C(5.14.2)WB 154 Sn(
  )SM($target_triplet.repre)HY(sen)HY(ta)HY(tion)YH(\201\202)ES()363 1 TN()EA()BN}if
1 NH le{364(7\240\240)1 C(6)WB 155 Sn( Direc)HY(tives)YH()364 1 TN()EA()BN}if
2 NH le{365(7.1\240\240)2 C(6.1)WB 156 Sn( )SM(define)ES()365 1 TN()EA()BN}if
2 NH le{366(7.2\240\240)2 C(6.2)WB 157 Sn( )SM(include)ES()366 1 TN()EA()BN}if
2 NH le{367(7.3\240\240)2 C(6.3)WB 158 Sn( )SM(source)ES()367 1 TN()EA()BN}if
1 NH le{368(8\240\240)1 C(7)WB 159 Sn( Attributes)368 1 TN()EA()BN}if
1 NH le{369(9\240\240)1 C(8)WB 160 Sn( Name Patterns)369 1 TN()EA()BN}if
1 NH le{370(10\240\240)1 C(9)WB 161 Sn( )SM(config)ES( Module)370 1 TN()EA()BN}if
2 NH le{371(10.1\240\240)2 C(9.1)WB 162 Sn( Hermetic Build Config)HY(u)HY(ra)HY(tions)YH()371 1 TN()EA()BN}if
1 NH le{372(11\240\240)1 C(10)WB 163 Sn( )SM(test)ES( Module)372 1 TN()EA()BN}if
1 NH le{373(12\240\240)1 C(11)WB 164 Sn( )SM(install)ES( Module)373 1 TN()EA()BN}if
2 NH le{374(12.1\240\240)2 C(11.1)WB 165 Sn( Relo)HY(cat)HY(able)YH( Instal)HY(la)HY(tion)YH()374 1 TN()EA()BN}if
2 NH le{375(12.2\240\240)2 C(11.2)WB 166 Sn( Instal)HY(la)HY(tion)YH( Filter)HY(ing)YH()375 1 TN()EA()BN}if
1 NH le{376(13\240\240)1 C(12)WB 167 Sn( )SM(version)ES( Module)376 1 TN()EA()BN}if
1 NH le{377(14\240\240)1 C(13)WB 168 Sn( )SM(bin)ES( Module)377 1 TN()EA()BN}if
2 NH le{378(14.1\240\240)2 C(13.1)WB 169 Sn( Binary Target Types)378 1 TN()EA()BN}if
3 NH le{379(14.1.1\240\240)3 C(13.1.1)WB 170 Sn( )SM(lib{})ES(,
  )SM(liba{})ES(, )SM(libs{})ES()379 1 TN()EA()BN}if
3 NH le{380(14.1.2\240\240)3 C(13.1.2)WB 171 Sn( )SM(libul{})ES(,
  )SM(libue{})ES(, )SM(libua{})ES(, )SM(libus{})ES()380 1 TN()EA()BN}if
3 NH le{381(14.1.3\240\240)3 C(13.1.3)WB 172 Sn( )SM(obj{})ES(,
  )SM(obje{})ES(, )SM(obja{})ES(, )SM(objs{})ES()381 1 TN()EA()BN}if
3 NH le{382(14.1.4\240\240)3 C(13.1.4)WB 173 Sn( )SM(bmi{})ES(,
  )SM(bmie{})ES(, )SM(bmia{})ES(, )SM(bmis{})ES()382 1 TN()EA()BN}if
3 NH le{383(14.1.5\240\240)3 C(13.1.5)WB 174 Sn( )SM(hbmi{})ES(,
  )SM(hbmie{})ES(, )SM(hbmia{})ES(, )SM(hbmis{})ES()383 1 TN()EA()BN}if
3 NH le{384(14.1.6\240\240)3 C(13.1.6)WB 175 Sn( )SM(def{})ES()384 1 TN()EA()BN}if
1 NH le{385(15\240\240)1 C(14)WB 176 Sn( )SM(cc)ES( Module)385 1 TN()EA()BN}if
2 NH le{386(15.1\240\240)2 C(14.1)WB 177 Sn( C-Common Config)HY(u)HY(ra)HY(tion)YH( Vari)HY(ables)YH()386 1 TN()EA()BN}if
2 NH le{387(15.2\240\240)2 C(14.2)WB 178 Sn( C-Common Target Types)387 1 TN()EA()BN}if
3 NH le{388(15.2.1\240\240)3 C(14.2.1)WB 179 Sn( )SM(pc{})ES(, )SM(pca{})ES(,
  )SM(pcs{})ES()388 1 TN()EA()BN}if
2 NH le{389(15.3\240\240)2 C(14.3)WB 180 Sn( Compi)HY(la)HY(tion)YH( Inter)HY(nal)YH( Scope)389 1 TN()EA()BN}if
2 NH le{390(15.4\240\240)2 C(14.4)WB 181 Sn( Auto)HY(matic)YH( DLL Symbol Export)HY(ing)YH()390 1 TN()EA()BN}if
2 NH le{391(15.5\240\240)2 C(14.5)WB 182 Sn( Impor)HY(ta)HY(tion)YH( of Installed Libraries)391 1 TN()EA()BN}if
3 NH le{392(15.5.1\240\240)3 C(14.5.1)WB 183 Sn( Rewrit)HY(ing)YH( Installed Libraries
  System Root \201sysroot\202)392 1 TN()EA()BN}if
2 NH le{393(15.6\240\240)2 C(14.6)WB 184 Sn( GCC Compiler Toolchain)393 1 TN()EA()BN}if
2 NH le{394(15.7\240\240)2 C(14.7)WB 185 Sn( Clang Compiler Toolchain)394 1 TN()EA()BN}if
3 NH le{395(15.7.1\240\240)3 C(14.7.1)WB 186 Sn( Clang Target)HY(ing)YH( MSVC)395 1 TN()EA()BN}if
2 NH le{396(15.8\240\240)2 C(14.8)WB 187 Sn( MSVC Compiler Toolchain)396 1 TN()EA()BN}if
1 NH le{397(16\240\240)1 C(15)WB 188 Sn( )SM(c)ES( Module)397 1 TN()EA()BN}if
2 NH le{398(16.1\240\240)2 C(15.1)WB 189 Sn( C Config)HY(u)HY(ra)HY(tion)YH( Vari)HY(ables)YH()398 1 TN()EA()BN}if
2 NH le{399(16.2\240\240)2 C(15.2)WB 190 Sn( C Target Types)399 1 TN()EA()BN}if
3 NH le{400(16.2.1\240\240)3 C(15.2.1)WB 191 Sn( )SM(c{})ES(, )SM(h{})ES()400 1 TN()EA()BN}if
2 NH le{401(16.3\240\240)2 C(15.3)WB 192 Sn( Objec)HY(tive)YH(-C Compi)HY(la)HY(tion)YH()401 1 TN()EA()BN}if
2 NH le{402(16.4\240\240)2 C(15.4)WB 193 Sn( Assem)HY(bler)YH( with C Prepro)HY(ces)HY(sor)YH( Compi)HY(la)HY(tion)YH()402 1 TN()EA()BN}if
2 NH le{403(16.5\240\240)2 C(15.5)WB 194 Sn( C Compiler Prede)HY(fined)YH( Macro Extrac)HY(tion)YH()403 1 TN()EA()BN}if
1 NH le{404(17\240\240)1 C(16)WB 195 Sn( )SM(cxx)ES( Module)404 1 TN()EA()BN}if
2 NH le{405(17.1\240\240)2 C(16.1)WB 196 Sn( C++ Config)HY(u)HY(ra)HY(tion)YH( Vari)HY(ables)YH()405 1 TN()EA()BN}if
2 NH le{406(17.2\240\240)2 C(16.2)WB 197 Sn( C++ Target Types)406 1 TN()EA()BN}if
3 NH le{407(17.2.1\240\240)3 C(16.2.1)WB 198 Sn( )SM(cxx{})ES(, )SM(hxx{})ES(,
  )SM(ixx{})ES(, )SM(txx{})ES(, )SM(mxx{})ES()407 1 TN()EA()BN}if
2 NH le{408(17.3\240\240)2 C(16.3)WB 199 Sn( C++ Modules Support)408 1 TN()EA()BN}if
3 NH le{409(17.3.1\240\240)3 C(16.3.1)WB 200 Sn( Modules Intro)HY(duc)HY(tion)YH()409 1 TN()EA()BN}if
3 NH le{410(17.3.2\240\240)3 C(16.3.2)WB 201 Sn( Build)HY(ing)YH( Modules)410 1 TN()EA()BN}if
3 NH le{411(17.3.3\240\240)3 C(16.3.3)WB 202 Sn( Module Symbols Export)HY(ing)YH()411 1 TN()EA()BN}if
3 NH le{412(17.3.4\240\240)3 C(16.3.4)WB 203 Sn( Modules Instal)HY(la)HY(tion)YH()412 1 TN()EA()BN}if
3 NH le{413(17.3.5\240\240)3 C(16.3.5)WB 204 Sn( Modules Design Guide)HY(lines)YH()413 1 TN()EA()BN}if
3 NH le{414(17.3.6\240\240)3 C(16.3.6)WB 205 Sn( Modu)HY(lar)HY(iz)HY(ing)YH( Exist)HY(ing)YH( Code)414 1 TN()EA()BN}if
2 NH le{415(17.4\240\240)2 C(16.4)WB 206 Sn( Objec)HY(tive)YH(-C++ Compi)HY(la)HY(tion)YH()415 1 TN()EA()BN}if
2 NH le{416(17.5\240\240)2 C(16.5)WB 207 Sn( C++ Compiler Prede)HY(fined)YH( Macro Extrac)HY(tion)YH()416 1 TN()EA()BN}if
1 NH le{417(18\240\240)1 C(17)WB 208 Sn( )SM(in)ES( Module)417 1 TN()EA()BN}if
1 NH le{418(19\240\240)1 C(18)WB 209 Sn( )SM(bash)ES( Module)418 1 TN()EA()BN}if
1 NH le{419(20\240\240)1 C(19)WB 210 Sn( Appendix A \235 JSON Dump Format)419 1 TN()EA()BN}if
/OU t D /Cb Db D NP Ep ET 
/Cb Db D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc

/Ba f D /BO 0 D Bs
/UR (-) D
/Ti (The build2 Build System) D
/Au () D
/Df f D
/ME [(0.17)(Build System)(2014-2024 the build2 authors)(build system)] D

NP RC ZF
()5 Sl()WB 0 Sn(
)BR()WB 1 Sn(
   
  )0 1 0 H(Preface)WB 211 Sn()WB 2 Sn()EH(

  )0 P(This docu)HY(ment)YH( describes the )SM(build2)ES( build system. For the
  build system driver command line inter)HY(face)YH( refer to the )0 2 A()SM()BD(b\2011\202)ES()ES()EA( man pages. For other tools in
  the )SM(build2)ES( toolchain \201package and project managers, etc\202 see
  the )R1 2 A(Docu)HY(men)HY(ta)HY(tion)YH()EA( index.)EP(

  )0 1 1 H(1)WB 212 Sn()WB 3 Sn( Intro)HY(duc)HY(tion)YH()EH(

  )0 P(The )SM(build2)ES( build system is a native, cross-plat)HY(form)YH( build
  system with a terse, mostly declar)HY(a)HY(tive)YH( descrip)HY(tion)YH( language, a concep)HY(tual)YH(
  model of build, and a uniform inter)HY(face)YH( with consis)HY(tent)YH( behav)HY(ior)YH( across
  plat)HY(forms)YH( and compil)HY(ers)YH(.)EP(

  )0 P(Those famil)HY(iar)YH( with )SM(make)ES( will see many simi)HY(lar)HY(i)HY(ties)YH(, though
  mostly concep)HY(tual)YH( rather than syntac)HY(tic)YH(. This is not by acci)HY(dent)YH( since
  )SM(build2)ES( borrows the funda)HY(men)HY(tal)YH( DAG-based build model from
  orig)HY(i)HY(nal)YH( )SM(make)ES( and many of its concep)HY(tual)YH( exten)HY(sions)YH( from GNU
  )SM(make)ES(. We believe, para)HY(phras)HY(ing)YH( a famous quote, that )I(those
  who do not under)HY(stand)YH( )SM(make)ES( are condemned to rein)HY(vent)YH( it,
  poorly.)ES( So our goal with )SM(build2)ES( was to rein)HY(vent)YH(
  )SM(make)ES( )I(well)ES( while handling the demands and complex)HY(ity)YH( of
  modern cross-plat)HY(form)YH( soft)HY(ware)YH( devel)HY(op)HY(ment)YH(.)EP(

  )0 P(Like )SM(make)ES(, )SM(build2)ES( is an )I("honest")ES( build
  system without magic or black boxes. You can expect to under)HY(stand)YH( what's
  going on under)HY(neath)YH( and be able to customize most of its behav)HY(ior)YH( to suit
  your needs. This is not to say that it's not an )I(opin)HY(ion)HY(ated)YH()ES( build
  system and if you find your)HY(self)YH( "fight)HY(ing)YH(" some of its funda)HY(men)HY(tal)YH( design
  choices, it would prob)HY(a)HY(bly)YH( be wiser to look for alter)HY(na)HY(tives)YH(.)EP(

  )0 P(We believe the impor)HY(tance)YH( and complex)HY(ity)YH( of the problem warranted the
  design of a new purpose-built language and will hope)HY(fully)YH( justify the time
  it takes for you to master it. In the end we hope )SM(build2)ES( will
  make creat)HY(ing)YH( and main)HY(tain)HY(ing)YH( build infras)HY(truc)HY(ture)YH( for your projects a
  pleas)HY(ant)YH( task.)EP(

  )0 P(Also note that )SM(build2)ES( is not specific to C/C++ or even to
  compiled languages; its build model is general enough to handle any
  DAG-based oper)HY(a)HY(tions)YH(. See the )0 209 1 A()SM(bash)ES()209 0 TN TL()Ec /AF f D(
  module for a good example.)EP(

  )0 P(While the build system is part of a larger, well-inte)HY(grated)YH( build
  toolchain that includes the package and project depen)HY(dency)YH( managers, it does
  not depend on them and its stan)HY(dalone)YH( usage is the only subject of this
  manual.)EP(

  )0 P(We begin with a tuto)HY(rial)YH( intro)HY(duc)HY(tion)YH( that aims to show the essen)HY(tial)YH(
  elements of the build system on real exam)HY(ples)YH( but without getting into too
  much detail. Specif)HY(i)HY(cally)YH(, we want to quickly get to the point where we can
  build useful executable and library projects.)EP(

  )0 2 2 H(1.1)WB 213 Sn()WB 4 Sn( Hello, World)EH(

  )0 P(Let's start with the custom)HY(ary)YH( )I("Hello, World")ES( example: a single
  source file from which we would like to build an executable:)EP(

  ) 12 44 PR($ tree hello/
hello/
\267-- hello.cxx

$ cat hello/hello.cxx

#include <iostream>

int main \201\202
{
  std::cout << "Hello, World!" << std::endl;
})RP(

  )0 P(While this very basic program hardly resem)HY(bles)YH( what most soft)HY(ware)YH(
  projects look like today, it is useful for intro)HY(duc)HY(ing)YH( key build system
  concepts without getting over)HY(whelmed)YH(. In this spirit we will also use the
  )SM(build2)ES( )I(simple project)ES( struc)HY(ture)YH(, which, simi)HY(larly)YH(,
  should only be used for basic needs.)EP(

  )0 P(To turn our )SM(hello/)ES( direc)HY(tory)YH( into a simple project all we
  need to do is add a )SM(build)HY(file)YH()ES(:)EP(

  ) 10 26 PR($ tree hello/
hello/
|-- hello.cxx
\267-- buildfile

$ cat hello/buildfile

using cxx

exe{hello}: cxx{hello.cxx})RP(

  )0 P(Let's start from the bottom: the second line is a )I(depen)HY(dency)YH(
  decla)HY(ra)HY(tion)YH()ES(. On the left hand side of )SM(:)ES( we have a
  )I(target)ES(, the )SM(hello)ES( executable, and on the right hand side
  \235 a )I(prereq)HY(ui)HY(site)YH()ES(, the )SM(hello.cxx)ES( source file. Those
  )SM(exe)ES( and )SM(cxx)ES( in )SM(exe{...})ES( and
  )SM(cxx{...})ES( are called )I(target types)ES(. In fact, for clarity,
  target type names are always mentioned with trail)HY(ing)YH( )SM({})ES(, for
  example, "the )SM(exe{})ES( target type denotes an executable".)EP(

  )0 P(Notice that the depen)HY(dency)YH( decla)HY(ra)HY(tion)YH( does not specify )I(how)ES( to
  build an executable from a C++ source file \235 this is the job of a
  )I(rule)ES(. When the build system needs to update a target, it tries to
  )I(match)ES( a suit)HY(able)YH( rule based on the types of the target and its
  prereq)HY(ui)HY(sites)YH(. The )SM(build2)ES( core has a number of prede)HY(fined)YH(
  funda)HY(men)HY(tal)YH( rules with the rest coming from )I(build system modules)ES(. For
  example, the )SM(cxx)ES( module defines a number of rules for compil)HY(ing)YH(
  C++ source code as well as linking executa)HY(bles)YH( and libraries.)EP(

  )0 P(It should now be easy to guess what the first line of our
  )SM(build)HY(file)YH()ES( does: it loads the )SM(cxx)ES( module which
  defines the rules neces)HY(sary)YH( to build our program \201it also regis)HY(ters)YH( the
  )SM(cxx{})ES( target type\202.)EP(

  )0 P(Let's now try to build and run our program \201)SM(b)ES( is the build
  system driver\202:)EP(

  ) 16 38 PR($ cd hello/  # Change to project root.

$ b
c++ cxx{hello} -> obje{hello}
ld exe{hello}

$ ls -1
buildfile
hello.cxx
hello
hello.d
hello.o
hello.o.d

$ ./hello
Hello, World!)RP(

  )0 P(Or, if we are on Windows and using Visual Studio:)EP(

  ) 16 29 PR(> cd hello

> b
c++ cxx{hello} -> obje{hello}
ld exe{hello}

> dir /b
buildfile
hello.cxx
hello.exe
hello.exe.d
hello.exe.obj
hello.exe.obj.d

> .\200hello.exe
Hello, World!)RP(

  )0 P(By default )SM(build2)ES( uses the same C++ compiler it was built
  with and without passing any extra options, such as debug or opti)HY(miza)HY(tion)YH(,
  target archi)HY(tec)HY(ture)YH(, etc. To change these defaults we use )I(config)HY(u)HY(ra)HY(tion)YH(
  vari)HY(ables)YH()ES(. For example, to specify a differ)HY(ent)YH( C++ compiler we use
  )SM(config.cxx)ES(:)EP(

  ) 1 22 PR($ b config.cxx=clang++)RP(

  )BR(
  )0 P(For Visual Studio, )SM(build2)ES( by default will use the latest
  avail)HY(able)YH( version and build for the )SM(x86_64)ES( target
  \201)SM(x64)ES( in the Microsoft's termi)HY(nol)HY(ogy)YH(\202. You can, however,
  over)HY(ride)YH( these defaults by either running from a suit)HY(able)YH( Visual Studio
  devel)HY(op)HY(ment)YH( command prompt or by spec)HY(i)HY(fy)HY(ing)YH( an abso)HY(lute)YH( path to
  )SM(cl)ES( that you wish to use. For example \201notice the use of inner
  quotes\202:)EP(

  ) 1 67 PR(> b "config.cxx='...\200VC\200Tools\200MSVC\20014.23.28105\200bin\200Hostx64\200x86\200cl'")RP(

  )0 P(See )0 187 1 A(MSVC Compiler Toolchain)187 0 TN TL()Ec /AF f D( for details.)EP(
  )BR(

  )0 P(Simi)HY(larly)YH(, for addi)HY(tional)YH( compile options, such as debug infor)HY(ma)HY(tion)YH( or
  opti)HY(miza)HY(tion)YH( level, there is )SM(config.cxx.coptions)ES(. For
  example:)EP(

  ) 1 45 PR($ b config.cxx=clang++ config.cxx.coptions=-g)RP(

  )BR(
  )0 P(These and other config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( will be discussed in more detail
  later. We will also learn how to make our config)HY(u)HY(ra)HY(tion)YH( persis)HY(tent)YH( so that
  we don't have to repeat such long command lines on every build system
  invo)HY(ca)HY(tion)YH(.)EP(

  )0 P(Similar to )SM(config.cxx)ES(, there is also )SM(config.c)ES(
  for spec)HY(i)HY(fy)HY(ing)YH( the C compiler. Note, however, that if your project uses both
  C and C++, then you normally only need to specify one of them \235
  )SM(build2)ES( will deter)HY(mine)YH( the other auto)HY(mat)HY(i)HY(cally)YH(.)EP(
  )BR(

  )0 P(Let's discuss a few points about the build output. Firstly, to reduce the
  noise, the commands being executed are by default shown abbre)HY(vi)HY(ated)YH( and with
  the same target type nota)HY(tion)YH( as we used in the )SM(build)HY(file)YH()ES(. For
  example:)EP(

  ) 2 29 PR(c++ cxx{hello} -> obje{hello}
ld exe{hello})RP(

  )0 P(If, however, you would like to see the actual command lines, you can pass
  )SM(-v)ES( \201to see even more, there is the )SM(-V)ES( as well as
  )SM(--verbose)ES( options; see )0 2 A()SM()BD(b\2011\202)ES()ES()EA( for details\202. For example:)EP(

  ) 3 27 PR($ b -v
g++ -o hello.o -c hello.cxx
g++ -o hello hello.o)RP(

  )0 P(Most of the files produced by the build system should be
  self-explana)HY(tory)YH(: we have the object file \201)SM(hello.o)ES(,
  )SM(hello.obj)ES(\202 and executable \201)SM(hello)ES(,
  )SM(hello.exe)ES(\202. For each of them we also have the corre)HY(spond)HY(ing)YH(
  )SM(.d)ES( files which store the )I(auxil)HY(iary)YH( depen)HY(dency)YH(
  infor)HY(ma)HY(tion)YH()ES(, things like compile options, header depen)HY(den)HY(cies)YH(, etc.)EP(

  )0 P(To remove the build system output we use the )SM(clean)ES(
  )I(oper)HY(a)HY(tion)YH()ES( \201if no oper)HY(a)HY(tion)YH( is spec)HY(i)HY(fied)YH(, the default is
  )SM(update)ES(\202:)EP(

  ) 7 14 PR($ b clean
rm exe{hello}
rm obje{hello}

$ ls -1
buildfile
hello.cxx)RP(

  )0 P(One of the main reasons behind the )I(target type)ES( concept is the
  plat)HY(form)YH(/compiler-spec)HY(i)HY(fied)YH( vari)HY(ances)YH( in file names as illus)HY(trated)YH( by the
  above list)HY(ings)YH(. In our )SM(build)HY(file)YH()ES( we refer to the executable
  target as )SM(exe{hello})ES(, not as )SM(hello.exe)ES( or
  )SM(hello$EXT)ES(. The actual file exten)HY(sion)YH(, if any, will be
  deter)HY(mined)YH( based on the compiler's target plat)HY(form)YH( by the rule doing the
  linking. In this sense, target types are a plat)HY(form)YH(-inde)HY(pen)HY(dent)YH( replace)HY(ment)YH(
  of file exten)HY(sions)YH( \201though they do have other bene)HY(fits)YH(, such as allow)HY(ing)YH(
  non-file targets as well as being hier)HY(ar)HY(chi)HY(cal)YH(; see )0 27 1 A(Target Types)27 0 TN TL()Ec /AF f D( for details\202.)EP(

  )0 P(Let's revisit the depen)HY(dency)YH( decla)HY(ra)HY(tion)YH( line from our
  )SM(build)HY(file)YH()ES(:)EP(

  ) 1 26 PR(exe{hello}: cxx{hello.cxx})RP(

  )0 P(In light of target types replac)HY(ing)YH( file exten)HY(sions)YH( this looks
  tauto)HY(log)HY(i)HY(cal)YH(: why do we need to specify both the )SM(cxx{})ES( target
  type )I(and)ES( the )SM(.cxx)ES( file exten)HY(sion)YH(? In fact, we don't have
  to if we specify the default file exten)HY(sion)YH( for the )SM(cxx{})ES(
  target type. Here is our updated )SM(build)HY(file)YH()ES( in its entirety:)EP(

  ) 5 23 PR(using cxx

cxx{*}: extension = cxx

exe{hello}: cxx{hello})RP(

  )0 P(Let's unpack the new line. What we have here is a )I(target
  type/pattern-specific vari)HY(able)YH()ES(. It only applies to targets of the
  )SM(cxx{})ES( type whose names match the )SM(*)ES( wild)HY(card)YH(
  pattern. The )SM(exten)HY(sion)YH()ES( vari)HY(able)YH( name is reserved by the
  )SM(build2)ES( core for spec)HY(i)HY(fy)HY(ing)YH( target type exten)HY(sions)YH(.)EP(

  )0 P(Let's see how all these pieces fit together. When the build system needs
  to update )SM(exe{hello})ES(, it searches for a suit)HY(able)YH( rule. A rule
  from the )SM(cxx)ES( module matches since it knows how to build a
  target of type )SM(exe{})ES( from a prereq)HY(ui)HY(site)YH( of type
  )SM(cxx{})ES(. When the matched rule is )I(applied)ES(, it searches for
  a target for the )SM(cxx{hello})ES( prereq)HY(ui)HY(site)YH(. During this search,
  the )SM(exten)HY(sion)YH()ES( vari)HY(able)YH( is looked up and its value is used to
  end up with the )SM(hello.cxx)ES( file.)EP(

  )BR(
  )0 P(To resolve a rule match ambi)HY(gu)HY(ity)YH( or to over)HY(ride)YH( a default match
  )SM(build2)ES( uses )I(rule hints)ES(. For example, if we wanted link a
  C executable using the C++ link rule:)EP(

  ) 1 36 PR([rule_hint=cxx] exe{hello}: c{hello})RP(
  )BR(

  )0 P(Here is our new depen)HY(dency)YH( decla)HY(ra)HY(tion)YH( again:)EP(

  ) 1 22 PR(exe{hello}: cxx{hello})RP(

  )0 P(It has the canon)HY(i)HY(cal)YH( form: no exten)HY(sions)YH(, only target types. Some)HY(times)YH(
  explicit exten)HY(sion)YH( spec)HY(i)HY(fi)HY(ca)HY(tion)YH( is still neces)HY(sary)YH(, for example, if your
  project uses multi)HY(ple)YH( exten)HY(sions)YH( for the same file type. But if unnec)HY(es)HY(sary)YH(,
  it should be omitted for brevity.)EP(

  )BR(
  )0 P(If you prefer the )SM(.cpp)ES( file exten)HY(sion)YH( and your source file
  is called )SM(hello.cpp)ES(, then the only line in our
  )SM(build)HY(file)YH()ES( that needs chang)HY(ing)YH( is the )SM(exten)HY(sion)YH()ES(
  vari)HY(able)YH( assign)HY(ment)YH(:)EP(

  ) 1 23 PR(cxx{*}: extension = cpp)RP(
  )BR(

  )0 P(Let's say our )SM(hello)ES( program got compli)HY(cated)YH( enough to
  warrant moving some func)HY(tion)HY(al)HY(ity)YH( into a sepa)HY(rate)YH( source/header module \201or a
  real C++ module\202. For example:)EP(

  ) 6 15 PR($ tree hello/
hello/
|-- hello.cxx
|-- utility.hxx
|-- utility.cxx
\267-- buildfile)RP(

  )0 P(This is what our updated )SM(build)HY(file)YH()ES( could look like:)EP(

  ) 6 48 PR(using cxx

hxx{*}: extension = hxx
cxx{*}: extension = cxx

exe{hello}: cxx{hello} hxx{utility} cxx{utility})RP(

  )0 P(Nothing really new here: we've spec)HY(i)HY(fied)YH( the default exten)HY(sion)YH( for the
  )SM(hxx{})ES( target type and listed the new header and source files as
  prereq)HY(ui)HY(sites)YH(. If you have expe)HY(ri)HY(ence)YH( with other build systems, then
  explic)HY(itly)YH( listing headers might seem strange to you. As will be discussed
  later, in )SM(build2)ES( we have to explic)HY(itly)YH( list all the
  prereq)HY(ui)HY(sites)YH( of a target that should end up in a source distri)HY(bu)HY(tion)YH( of our
  project.)EP(

  )BR(
  )0 P(You don't have to list )I(all)ES( headers that you include, only the ones
  belong)HY(ing)YH( to your project. Like all modern C/C++ build systems,
  )SM(build2)ES( performs auto)HY(matic)YH( header depen)HY(dency)YH( extrac)HY(tion)YH(.)EP(
  )BR(

  )0 P(In real projects with a substan)HY(tial)YH( number of source files, repeat)HY(ing)YH(
  target types and names will quickly become noisy. To tidy things up we can
  use )I(name gener)HY(a)HY(tion)YH()ES(. Here are a few exam)HY(ples)YH( of depen)HY(dency)YH(
  decla)HY(ra)HY(tions)YH( equiv)HY(a)HY(lent)YH( to the above:)EP(

  ) 2 43 PR(exe{hello}: cxx{hello utility} hxx{utility}
exe{hello}: cxx{hello} {hxx cxx}{utility})RP(

  )0 P(The last form is prob)HY(a)HY(bly)YH( the best choice if your project contains a
  large number of header/source pairs. Here is a more real)HY(is)HY(tic)YH( example:)EP(

  ) 3 44 PR(exe{hello}: {    cxx}{hello}               \200
            {hxx    }{forward types}       \200
            {hxx cxx}{format print utility})RP(

  )0 P(Manu)HY(ally)YH( listing a prereq)HY(ui)HY(site)YH( every time we add a new source file to
  our project is both tedious and error prone. Instead, we can auto)HY(mate)YH( our
  depen)HY(dency)YH( decla)HY(ra)HY(tions)YH( with )I(wild)HY(card)YH( name patterns)ES(. For example:)EP(

  ) 1 24 PR(exe{hello}: {hxx cxx}{*})RP(

  )0 P(Based on the previ)HY(ous)YH( discus)HY(sion)YH( of default exten)HY(sions)YH(, you can prob)HY(a)HY(bly)YH(
  guess how this works: for each target type the value of the
  )SM(exten)HY(sion)YH()ES( vari)HY(able)YH( is added to the pattern and files match)HY(ing)YH(
  the result become prereq)HY(ui)HY(sites)YH(. So, in our case, we will end up with files
  match)HY(ing)YH( the )SM(*.hxx)ES( and )SM(*.cxx)ES( wild)HY(card)YH(
  patterns.)EP(

  )0 P(In more complex projects it is often conve)HY(nient)YH( to orga)HY(nize)YH( source code
  into subdi)HY(rec)HY(to)HY(ries)YH(. To handle such projects we can use the recur)HY(sive)YH(
  wild)HY(card)YH(:)EP(

  ) 1 25 PR(exe{hello}: {hxx cxx}{**})RP(

  )BR(
  )0 P(Using wild)HY(cards)YH( is some)HY(what)YH( contro)HY(ver)HY(sial)YH(. Patterns defi)HY(nitely)YH( make
  devel)HY(op)HY(ment)YH( more pleas)HY(ant)YH( and less error prone: you don't need to update
  your )SM(build)HY(file)YH()ES( every time you add, remove, or rename a source
  file and you won't forget to explic)HY(itly)YH( list headers, a mistake that is
  often only detected when trying to build a source distri)HY(bu)HY(tion)YH( of a project.
  On the other hand, there is the possi)HY(bil)HY(ity)YH( of includ)HY(ing)YH( stray source files
  into your build without notic)HY(ing)YH(. And, for more complex projects, name
  patterns can become fairly complex \201see )0 160 1 A(Name
  Patterns)160 0 TN TL()Ec /AF f D( for details\202. Note also that on modern hard)HY(ware)YH( the perfor)HY(mance)YH(
  of wild)HY(card)YH( searches hardly warrants a consid)HY(er)HY(a)HY(tion)YH(.)EP(

  )0 P(In our expe)HY(ri)HY(ence)YH(, when combined with modern version control systems like
  )SM(git\2011\202)ES(, stray source files are rarely an issue and gener)HY(ally)YH(
  the bene)HY(fits)YH( of wild)HY(cards)YH( outweigh their draw)HY(backs)YH(. But, in the end, whether
  to use them or not is a personal choice and, as shown above,
  )SM(build2)ES( supports both approaches.)EP(
  )BR(

  )0 P(And that's about all there is to our )SM(hello)ES( example. To
  summa)HY(rize)YH(, we've seen that to build a simple project we need a single
  )SM(build)HY(file)YH()ES( which itself doesn't contain much more than a
  depen)HY(dency)YH( decla)HY(ra)HY(tion)YH( for what we want to build. But we've also mentioned
  that simple projects are only really meant for basics. So let's convert our
  )SM(hello)ES( example to the )I(stan)HY(dard)YH( project)ES( struc)HY(ture)YH( which is
  what we will be using for most of our real devel)HY(op)HY(ment)YH(.)EP(

  )BR(
  )0 P(Simple projects have so many restric)HY(tions)YH( and limi)HY(ta)HY(tions)YH( that they are
  hardly usable for anything but, well, )I(really)ES( simple projects.)EP(

  )0 P(Specif)HY(i)HY(cally)YH(, such projects cannot be imported by other projects nor can
  they use build system modules that require boot)HY(strap)HY(ping)YH(. Notably, this
  includes the )SM(dist)ES( and )SM(config)ES( modules \201the
  )SM(test)ES( and )SM(install)ES( modules are loaded implic)HY(itly)YH(\202.
  And without the )SM(config)ES( module there is no support for
  persis)HY(tent)YH( config)HY(u)HY(ra)HY(tions)YH(.)EP(

  )0 P(As a result, you should only use a simple project if you are happy to
  always build in the source direc)HY(tory)YH( and with the default build
  config)HY(u)HY(ra)HY(tion)YH( or willing to specify the output direc)HY(tory)YH( and/or custom
  config)HY(u)HY(ra)HY(tion)YH( on every invo)HY(ca)HY(tion)YH(. In other words, expect an expe)HY(ri)HY(ence)YH(
  similar to a plain )SM(Make)HY(file)YH()ES(.)EP(

  )0 P(One notable example where simple projects are handy is a )I(glue
  )SM(build)HY(file)YH()ES()ES( that "pulls" together several other projects,
  usually for conve)HY(nience)YH( of devel)HY(op)HY(ment)YH(. See )0 12 1 A(Target
  Impor)HY(ta)HY(tion)YH()12 0 TN TL()Ec /AF f D( for details.)EP(
  )BR(

  )0 2 3 H(1.2)WB 214 Sn()WB 5 Sn( Project Struc)HY(ture)YH()EH(

  )0 P(A )SM(build2)ES( )I(stan)HY(dard)YH( project)ES( has the follow)HY(ing)YH( overall
  layout:)EP(

  ) 6 23 PR(hello/
|-- build/
|   |-- bootstrap.build
|   \267-- root.build
|-- ...
\267-- buildfile)RP(

  )0 P(Specif)HY(i)HY(cally)YH(, the project's root direc)HY(tory)YH( should contain the
  )SM(build/)ES( subdi)HY(rec)HY(tory)YH( as well as the root )SM(build)HY(file)YH()ES(.
  The )SM(build/)ES( subdi)HY(rec)HY(tory)YH( contains project-wide build system
  infor)HY(ma)HY(tion)YH(.)EP(

  )BR(
  )0 P(The )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  command is an easy way to create the stan)HY(dard)YH( layout executable
  \201)SM(-t\240exe)ES(\202 and library \201)SM(-t\240lib)ES(\202 projects.
  To change the C++ file exten)HY(sions)YH( to )SM(.hpp/.cpp)ES(, pass )SM(-l
  c++,cpp)ES(. For example:)EP(

  ) 1 44 PR($ bdep new --no-init -l c++,cpp -t exe hello)RP(
  )BR(

  )BR(
  )0 P(It is also possi)HY(ble)YH( to use an alter)HY(na)HY(tive)YH( build file/direc)HY(tory)YH( naming
  scheme where every instance of the word )I(build)ES( is replaced with
  )I(build2)ES(, for example:)EP(

  ) 6 24 PR(hello/
|-- build2/
|   |-- bootstrap.build2
|   \267-- root.build2
|-- ...
\267-- build2file)RP(

  )0 P(Note that the naming must be consis)HY(tent)YH( within a project with all the
  filesys)HY(tem)YH( entries either follow)HY(ing)YH( )I(build)ES( or )I(build2)ES( scheme. In
  other words, we cannot call the direc)HY(tory)YH( )SM(build2/)ES( while still
  using )SM(build)HY(file)YH()ES(.)EP(

  )0 P(The alter)HY(na)HY(tive)YH( naming scheme is primar)HY(ily)YH( useful when adding
  )SM(build2)ES( support to an exist)HY(ing)YH( project along with other build
  systems. In this case, the fairly generic stan)HY(dard)YH( names might already be in
  use. For example, it is custom)HY(ary)YH( to have )SM(build/)ES( in
  )SM(.gitig)HY(nore)YH()ES(. Plus more specific naming will make it easier to
  iden)HY(tify)YH( files and direc)HY(to)HY(ries)YH( as belong)HY(ing)YH( to the )SM(build2)ES(
  support. For new projects as well as for exist)HY(ing)YH( projects that are
  switch)HY(ing)YH( exclu)HY(sively)YH( to )SM(build2)ES( the stan)HY(dard)YH( naming scheme is
  recom)HY(mended)YH(.)EP(

  )0 P(To create a project with the alter)HY(na)HY(tive)YH( naming using )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  pass the )SM(alt-naming)ES( project type sub-option. For example:)EP(

  ) 1 32 PR($ bdep new -t exe,alt-naming ...)RP(
  )BR(

  )0 P(To support lazy loading of subpro)HY(jects)YH( \201discussed later\202, reading of the
  project's build infor)HY(ma)HY(tion)YH( is split into two phases: boot)HY(strap)HY(ping)YH( and
  loading. During boot)HY(strap)HY(ping)YH( the project's
  )SM(build/boot)HY(strap)YH(.build)ES( file is read. Then, when \201and if\202 the
  project is loaded completely, its )SM(build/root.build)ES( file is read
  followed by the )SM(build)HY(file)YH()ES( \201normally from the project root but
  possi)HY(bly)YH( from a subdi)HY(rec)HY(tory)YH(\202.)EP(

  )0 P(The )SM(boot)HY(strap)YH(.build)ES( file is required. Let's see what it
  would look like for a typical project using our )SM(hello)ES( as an
  example:)EP(

  ) 7 15 PR(project = hello

using version
using config
using test
using install
using dist)RP(

  )0 P(The first non-comment line in )SM(boot)HY(strap)YH(.build)ES( should be the
  assign)HY(ment)YH( of the project name to the )SM(project)ES( vari)HY(able)YH(. After
  that, a typical )SM(boot)HY(strap)YH(.build)ES( file loads a number of build
  system modules. While most modules can be loaded during the project load
  phase in )SM(root.build)ES(, certain modules have to be loaded early,
  while boot)HY(strap)HY(ping)YH( \201for example, because they define new oper)HY(a)HY(tions)YH(\202.)EP(

  )0 P(Let's examine briefly the modules loaded by our
  )SM(boot)HY(strap)YH(.build)ES(: The )0 167 1 A()SM(version)ES()167 0 TN TL()Ec /AF f D( module helps with manag)HY(ing)YH(
  our project version)HY(ing)YH(. With this module we only main)HY(tain)YH( the version in a
  single place \201the project's )SM(mani)HY(fest)YH()ES( file\202 and it is
  auto)HY(mat)HY(i)HY(cally)YH( made avail)HY(able)YH( in various conve)HY(nient)YH( forms through)HY(out)YH( our
  project \201)SM(build)HY(files)YH()ES(, header files, etc\202. The
  )SM(version)ES( module also auto)HY(mates)YH( version)HY(ing)YH( of snap)HY(shots)YH( between
  releases.)EP(

  )0 P(The )SM(mani)HY(fest)YH()ES( file is what makes our build system project a
  )I(package)ES(. It contains all the meta)HY(data)YH( that a user of a package might
  need to know: name, version, depen)HY(den)HY(cies)YH(, etc., all in one place. However,
  even if you don't plan to package your project, it is a good idea to create
  a basic )SM(mani)HY(fest)YH()ES( if only to take advan)HY(tage)YH( of the version
  manage)HY(ment)YH( offered by the )SM(version)ES( module. So let's go ahead and
  add it next to our root )SM(build)HY(file)YH()ES(:)EP(

  ) 13 29 PR($ tree hello/
hello/
|-- build/
|   \267-- ...
|-- ...
|-- buildfile
\267-- manifest

$ cat hello/manifest
: 1
name: hello
version: 0.1.0
summary: hello C++ executable)RP(

  )0 P(The )SM(config)ES( module provides support for persis)HY(tent)YH(
  config)HY(u)HY(ra)HY(tions)YH(. While build config)HY(u)HY(ra)HY(tion)YH( is a large topic that we will be
  discussing in more detail later, in a nutshell )SM(build2)ES( support
  for config)HY(u)HY(ra)HY(tion)YH( is an inte)HY(gral)YH( part of the build system with the same
  mech)HY(a)HY(nisms)YH( avail)HY(able)YH( to the build system core, modules, and your projects.
  However, without )SM(config)ES(, the config)HY(u)HY(ra)HY(tion)YH( infor)HY(ma)HY(tion)YH( is
  )I(tran)HY(sient)YH()ES(. That is, what)HY(ever)YH( config)HY(u)HY(ra)HY(tion)YH( infor)HY(ma)HY(tion)YH( was
  auto)HY(mat)HY(i)HY(cally)YH( discov)HY(ered)YH( or that you have supplied on the command line is
  discarded after each build system invo)HY(ca)HY(tion)YH(. With the )SM(config)ES(
  module, however, we can )I(config)HY(ure)YH()ES( a project to make the config)HY(u)HY(ra)HY(tion)YH(
  )I(persis)HY(tent)YH()ES(. We will see an example of this shortly.)EP(

  )0 P(Next up are the )SM(test)ES(, )SM(install)ES(, and
  )SM(dist)ES( modules. As their names suggest, they provide support for
  testing, instal)HY(la)HY(tion)YH( and prepa)HY(ra)HY(tion)YH( of source distri)HY(bu)HY(tions)YH(. Specif)HY(i)HY(cally)YH(,
  the )SM(test)ES( module defines the )SM(test)ES( oper)HY(a)HY(tion)YH(, the
  )SM(install)ES( module defines the )SM(install)ES( and
  )SM(unin)HY(stall)YH()ES( oper)HY(a)HY(tions)YH(, and the )SM(dist)ES( module defines
  the )SM(dist)ES( \201meta-\202oper)HY(a)HY(tion)YH(. Again, we will try them out in a
  moment.)EP(

  )0 P(Moving on, the )SM(root.build)ES( file is optional though most
  projects will have it. This is the place where we define project's
  config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( \201subject of )0 22 1 A(Project
  Config)HY(u)HY(ra)HY(tion)YH()22 0 TN TL()Ec /AF f D(\202, estab)HY(lish)YH( project-wide settings, as well as load build
  system modules that provide support for the languages/tools that we use.
  Here is what it could look like for our )SM(hello)ES( example:)EP(

  ) 6 23 PR(cxx.std = latest

using cxx

hxx{*}: extension = hxx
cxx{*}: extension = cxx)RP(

  )0 P(As you can see, we've moved the loading of the )SM(cxx)ES( modules
  and setting of the default file exten)HY(sions)YH( from the root
  )SM(build)HY(file)YH()ES( in our simple project to )SM(root.build)ES( when
  using the stan)HY(dard)YH( layout. We've also set the )SM(cxx.std)ES( vari)HY(able)YH(
  to tell the )SM(cxx)ES( module to select the latest C++ stan)HY(dard)YH(
  avail)HY(able)YH( in any partic)HY(u)HY(lar)YH( C++ compiler this project might be built
  with.)EP(

  )BR(
  )0 P(Select)HY(ing)YH( the C++ stan)HY(dard)YH( for our project is a messy issue. If we don't
  specify the stan)HY(dard)YH( explic)HY(itly)YH( with )SM(cxx.std)ES(, then the default
  stan)HY(dard)YH( in each compiler will be used, which, currently, can range from
  C++98 to C++14. So unless you care)HY(fully)YH( write your code to work with any
  stan)HY(dard)YH(, this is prob)HY(a)HY(bly)YH( not a good idea.)EP(

  )0 P(Fixing the stan)HY(dard)YH( \201for example, to )SM(c++11)ES(,
  )SM(c++14)ES(, etc\202 should work theo)HY(ret)HY(i)HY(cally)YH(. In prac)HY(tice)YH(, however,
  compil)HY(ers)YH( add support for new stan)HY(dards)YH( incre)HY(men)HY(tally)YH( and many versions,
  while perfectly usable, are not feature-complete. As a result, a better
  prac)HY(ti)HY(cal)YH( strat)HY(egy)YH( is to specify the set of minimum supported compiler
  versions rather than the C++ stan)HY(dard)YH(.)EP(

  )0 P(There is also the issue of using libraries that require a newer stan)HY(dard)YH(
  in old code. For example, headers from a library that relies on C++14
  features will not compile when included in a project that is built as C++11.
   And, even if the headers compile \201that is, C++14 features are only used in
  the imple)HY(men)HY(ta)HY(tion)YH(\202, strictly speak)HY(ing)YH(, there is no guar)HY(an)HY(tee)YH( that code)HY(bases)YH(
  compiled with differ)HY(ent)YH( C++ stan)HY(dards)YH( are ABI compat)HY(i)HY(ble)YH( \201in fact, some
  changes to the C++ language leave the imple)HY(men)HY(ta)HY(tions)YH( no choice but to break
  the ABI\202.)EP(

  )0 P(As result, our recom)HY(men)HY(da)HY(tion)YH( is to set the stan)HY(dard)YH( to
  )SM(latest)ES( and specify the minimum supported compil)HY(ers)YH( and versions
  in your project's docu)HY(men)HY(ta)HY(tion)YH( \201see package mani)HY(fest)YH( )0 2 A()SM(requires)ES()EA(
  value for one possi)HY(ble)YH( place\202. Prac)HY(ti)HY(cally)YH(, this should allow you to include
  and link any library, regard)HY(less)YH( of the C++ stan)HY(dard)YH( that it uses.)EP(
  )BR(

  )0 P(Let's now take a look at the root )SM(build)HY(file)YH()ES(:)EP(

  ) 1 16 PR(./: {*/ -build/})RP(

  )0 P(In plain English, this )SM(build)HY(file)YH()ES( declares that build)HY(ing)YH( this
  direc)HY(tory)YH( \201and, since it's the root of our project, build)HY(ing)YH( this entire
  project\202 means build)HY(ing)YH( all its subdi)HY(rec)HY(to)HY(ries)YH( exclud)HY(ing)YH(
  )SM(build/)ES(. Let's now try to under)HY(stand)YH( how this is actu)HY(ally)YH(
  achieved.)EP(

  )0 P(We already know this is a depen)HY(dency)YH( decla)HY(ra)HY(tion)YH(, )SM(./)ES( is the
  target, and what's after )SM(:)ES( are its prereq)HY(ui)HY(sites)YH(, which seem to
  be gener)HY(ated)YH( with some kind of a name pattern \201the wild)HY(card)YH( char)HY(ac)HY(ter)YH( in
  )SM(*/)ES( should be the give)HY(away)YH(\202. What's unusual about this
  decla)HY(ra)HY(tion)YH(, however, is the lack of any target types plus that
  strange-looking )SM(./)ES(.)EP(

  )0 P(Let's start with the missing target types. In fact, the above
  )SM(build)HY(file)YH()ES( can be rewrit)HY(ten)YH( as:)EP(

  ) 1 21 PR(dir{.}: dir{* -build})RP(

  )0 P(So the trail)HY(ing)YH( slash \201always forward, even on Windows\202 is a special
  short)HY(hand)YH( nota)HY(tion)YH( for )SM(dir{})ES(. As we will see shortly, it fits
  natu)HY(rally)YH( with other uses of direc)HY(to)HY(ries)YH( in )SM(build)HY(files)YH()ES( \201for
  example, in scopes\202.)EP(

  )0 P(The )SM(dir{})ES( target type is an )I(alias)ES( \201and, in fact, is
  derived from more general )SM(alias{})ES(; see )0 27 1 A(Target Types)27 0 TN TL()Ec /AF f D( for details\202. Build)HY(ing)YH( it means
  build)HY(ing)YH( all its prereq)HY(ui)HY(sites)YH(.)EP(

  )BR(
  )0 P(If you are famil)HY(iar)YH( with )SM(make)ES(, then you can prob)HY(a)HY(bly)YH( see the
  simi)HY(lar)HY(ity)YH( with the ubiq)HY(ui)HY(tous)YH( )SM(all)ES( pseudo-target. In
  )SM(build2)ES( we instead use direc)HY(tory)YH( names as more natural aliases
  for the "build every)HY(thing)YH( in this direc)HY(tory)YH(" seman)HY(tics)YH(.)EP(

  )0 P(Note also that )SM(dir{})ES( is purely an alias and doesn't have
  anything to do with the filesys)HY(tem)YH(. In partic)HY(u)HY(lar)YH(, it does not create any
  direc)HY(to)HY(ries)YH(. If you do want explicit direc)HY(tory)YH( creation \201which should be
  rarely needed\202, use the )SM(fsdir{})ES( target type instead.)EP(
  )BR(

  )0 P(The )SM(./)ES( target is a special )I(default target)ES(. If we run
  the build system without spec)HY(i)HY(fy)HY(ing)YH( the target explic)HY(itly)YH(, then this target
  is built by default. Every )SM(build)HY(file)YH()ES( has the )SM(./)ES(
  target. If we don't declare it explic)HY(itly)YH(, then its decla)HY(ra)HY(tion)YH( is implied
  with the first target in the )SM(build)HY(file)YH()ES( as its prereq)HY(ui)HY(site)YH(.
  Recall our )SM(build)HY(file)YH()ES( from the simple )SM(hello)ES(
  project:)EP(

  ) 1 22 PR(exe{hello}: cxx{hello})RP(

  )0 P(It is equiv)HY(a)HY(lent)YH( to:)EP(

  ) 2 22 PR(./: exe{hello}
exe{hello}: cxx{hello})RP(

  )0 P(If, however, we had several targets in the same direc)HY(tory)YH( that we wanted
  built by default, then we would need to explic)HY(itly)YH( list them as
  prereq)HY(ui)HY(sites)YH( of the default target. For example:)EP(

  ) 5 24 PR(./: exe{hello}
exe{hello}: cxx{hello}

./: exe{goodby}
exe{goodby}: cxx{goodby})RP(

  )0 P(While straight)HY(for)HY(ward)YH(, this is some)HY(what)YH( inel)HY(e)HY(gant)YH( in its repet)HY(i)HY(tive)HY(ness)YH(.
  To tidy things up we can use )I(depen)HY(dency)YH( decla)HY(ra)HY(tion)YH( chains)ES( that allow
  us to chain together several target-prereq)HY(ui)HY(site)YH( decla)HY(ra)HY(tions)YH( in a single
  line. For example:)EP(

  ) 3 28 PR(./: exe{hello}: cxx{hello}

./: exe{goodby}: cxx{goodby})RP(

  )0 P(With depen)HY(dency)YH( chains a prereq)HY(ui)HY(site)YH( of the preced)HY(ing)YH( target becomes a
  target itself for the follow)HY(ing)YH( prereq)HY(ui)HY(sites)YH(.)EP(

  )0 P(Let's get back to our root )SM(build)HY(file)YH()ES(:)EP(

  ) 1 16 PR(./: {*/ -build/})RP(

  )0 P(The last unex)HY(plained)YH( bit is the )SM({*/\240-build/})ES( name
  pattern. All it does is exclude )SM(build/)ES( from the subdi)HY(rec)HY(to)HY(ries)YH(
  to build. See )0 160 1 A(Name Patterns)160 0 TN TL()Ec /AF f D( for details.)EP(

  )0 P(Let's take a look at a slightly more real)HY(is)HY(tic)YH( root
  )SM(build)HY(file)YH()ES(:)EP(

  ) 1 48 PR(./: {*/ -build/} doc{README.md LICENSE} manifest)RP(

  )0 P(Here we have the custom)HY(ary)YH( )SM(README.md)ES( and
  )SM(LICENSE)ES( files as well as the package )SM(mani)HY(fest)YH()ES(.
  Listing them as prereq)HY(ui)HY(sites)YH( achieves two things: they will be installed
  if/when our project is installed and, as mentioned earlier, they will be
  included into the project source distri)HY(bu)HY(tion)YH(.)EP(

  )0 P(The )SM(README.md)ES( and )SM(LICENSE)ES( files use the
  )SM(doc{})ES( target type. We could have used the generic
  )SM(file{})ES( but using the more precise )SM(doc{})ES( makes sure
  that they are installed into the appro)HY(pri)HY(ate)YH( docu)HY(men)HY(ta)HY(tion)YH( direc)HY(tory)YH(. The
  )SM(mani)HY(fest)YH()ES( file doesn't need an explicit target type since it has
  a fixed name \201)SM(mani)HY(fest)YH({mani)HY(fest)YH(})ES( is valid but redun)HY(dant)YH(\202.)EP(

  )0 P(Stan)HY(dard)YH( project infras)HY(truc)HY(ture)YH( in place, where should we put our source
  code? While we could have every)HY(thing)YH( in the root direc)HY(tory)YH( of our project,
  just like we did with the simple layout, it is recom)HY(mended)YH( to instead place
  the source code into a subdi)HY(rec)HY(tory)YH( named the same as the project. For
  example:)EP(

  ) 9 17 PR(hello/
|-- build/
|   \267-- ...
|-- hello/
|   |-- hello.cxx
|   \267-- buildfile
|-- buildfile
|-- manifest
\267-- README.md)RP(

  )BR(
  )0 P(There are several reasons for this layout: It imple)HY(ments)YH( the canon)HY(i)HY(cal)YH(
  inclu)HY(sion)YH( scheme where each header is prefixed with its project name. It
  also has a predictable name where users can expect to find our project's
  source code. Finally, this layout prevents clutter in the project's root
  direc)HY(tory)YH( which usually contains various other files. See )0 2 A(Canon)HY(i)HY(cal)YH(
  Project Struc)HY(ture)YH()EA( for details.)EP(

  )0 P(Note, however, that this layout is not manda)HY(tory)YH( and )SM(build2)ES(
  is flex)HY(i)HY(ble)YH( enough to support various arrange)HY(ments)YH( used in today's C and C++
  projects. Further)HY(more)YH(, the )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  command provides a number of customiza)HY(tion)YH( options and chances are you will
  be able to create your preferred layout auto)HY(mat)HY(i)HY(cally)YH(. See )0 2 A(SOURCE LAYOUT)EA( for more
  infor)HY(ma)HY(tion)YH( and exam)HY(ples)YH(.)EP(

  )0 P(Note also that while we can name our header and source files however we
  like \201but, again, see )0 2 A(Canon)HY(i)HY(cal)YH(
  Project Struc)HY(ture)YH()EA( for some sensi)HY(ble)YH( guide)HY(lines)YH(\202, C++ module inter)HY(face)YH(
  files need to embed a suffi)HY(cient)YH( amount of the module name suffix in their
  names to unam)HY(bigu)HY(ously)YH( resolve all the modules within a project. See )0 201 1 A(Build)HY(ing)YH( Modules)201 0 TN TL()Ec /AF f D( for details.)EP(
  )BR(

  )0 P(The source subdi)HY(rec)HY(tory)YH( )SM(build)HY(file)YH()ES( is iden)HY(ti)HY(cal)YH( to that of
  the simple project minus the parts moved to )SM(root.build)ES(:)EP(

  ) 1 25 PR(exe{hello}: {hxx cxx}{**})RP(

  )0 P(Let's now build our project and see where the build system output ends up
  in this new layout:)EP(

  ) 21 41 PR($ cd hello/  # Change to project root.
$ b
c++ hello/cxx{hello} -> hello/obje{hello}
ld hello/exe{hello}

$ tree ./
./
|-- build/
|   \267-- ...
|-- hello/
|   |-- hello.cxx
|   |-- hello
|   |-- hello.d
|   |-- hello.o
|   |-- hello.o.d
|   \267-- buildfile
|-- buildfile
\267-- manifest

$ hello/hello
Hello, World!)RP(

  )0 P(If we don't specify a target to build \201as in the example above\202, then
  )SM(build2)ES( will build the current direc)HY(tory)YH( or, more precisely, the
  default target in the )SM(build)HY(file)YH()ES( in the current direc)HY(tory)YH(. We
  can also build a direc)HY(tory)YH( other than the current, for example:)EP(

  ) 1 10 PR($ b hello/)RP(

  )BR(
  )0 P(Note that the trail)HY(ing)YH( slash is required. In fact, )SM(hello/)ES( in
  the above command line is a target and is equiv)HY(a)HY(lent)YH( to
  )SM(dir{hello})ES(, just like in the )SM(build)HY(files)YH()ES(.)EP(
  )BR(

  )0 P(Or we can build a specific target:)EP(

  ) 1 20 PR($ b hello/exe{hello})RP(

  )0 P(Natu)HY(rally)YH(, nothing prevents us from build)HY(ing)YH( multi)HY(ple)YH( targets or even
  projects in the same build system invo)HY(ca)HY(tion)YH(. For example, if we had the
  )SM(libhello)ES( project next to our )SM(hello/)ES(, then we could
  build both at once:)EP(

  ) 5 20 PR($ ls -1
hello/
libhello/

$ b hello/ libhello/)RP(

  )0 P(Speak)HY(ing)YH( of libraries, let's see what the stan)HY(dard)YH( project struc)HY(ture)YH(
  looks like for one, using )SM(libhello)ES( created by )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA( as
  an example:)EP(

  ) 19 43 PR($ bdep new --no-init -l c++ -t lib libhello

$ tree libhello/
libhello/
|-- build/
|   |-- bootstrap.build
|   |-- root.build
|   \267-- export.build
|-- libhello/
|   |-- hello.hxx
|   |-- hello.cxx
|   |-- export.hxx
|   |-- version.hxx.in
|   \267-- buildfile
|-- tests/
|   \267--  ...
|-- buildfile
|-- manifest
\267-- README.md)RP(

  )0 P(The overall layout \201)SM(build/)ES(, )SM(libhello/)ES( source
  subdi)HY(rec)HY(tory)YH(\202 as well as the contents of the root files
  \201)SM(boot)HY(strap)YH(.build)ES(, )SM(root.build)ES(, root
  )SM(build)HY(file)YH()ES(\202 are exactly the same. There is, however, the new
  file )SM(export.build)ES( in )SM(build/)ES(, the new subdi)HY(rec)HY(tory)YH(
  )SM(tests/)ES(, and the contents of the project's source subdi)HY(rec)HY(tory)YH(
  )SM(libhello/)ES( look quite a bit differ)HY(ent)YH(. We will examine all of
  these differ)HY(ences)YH( in the coming sections, as we learn more about the build
  system.)EP(

  )BR(
  )0 P(Again, this layout is not manda)HY(tory)YH( and )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA( can
  create a number of alter)HY(na)HY(tive)YH( library struc)HY(tures)YH(. For example, if you
  prefer the )SM(include/src)ES( split, try:)EP(

  ) 1 49 PR($ bdep new --no-init -l c++ -t lib,split libhello)RP(

  )0 P(See )0 2 A(SOURCE LAYOUT)EA(
  for more exam)HY(ples)YH(.)EP(
  )BR(

  )BR(
  )0 P(The stan)HY(dard)YH( project struc)HY(ture)YH( is not type \201executable, library, etc\202 or
  even language specific. In fact, the same project can contain multi)HY(ple)YH(
  executa)HY(bles)YH( and/or libraries \201for example, both )SM(hello)ES( and
  )SM(libhello)ES(\202. However, if you plan to package your projects, it is
  a good idea to keep them as sepa)HY(rate)YH( build system projects \201they can still
  reside in the same version control repos)HY(i)HY(tory)YH(, though\202.)EP(

  )0 P(Speak)HY(ing)YH( of projects, this term is unfor)HY(tu)HY(nately)YH( over)HY(loaded)YH( to mean two
  differ)HY(ent)YH( things at differ)HY(ent)YH( levels of soft)HY(ware)YH( orga)HY(ni)HY(za)HY(tion)YH(. At the bottom
  we have )I(build system projects)ES( which, if pack)HY(aged)YH(, become
  )I(pack)HY(ages)YH()ES(. And at the top, related pack)HY(ages)YH( are often grouped into
  what is also commonly referred to as )I(projects)ES(. At this point both
  usages are prob)HY(a)HY(bly)YH( too well estab)HY(lished)YH( to look for alter)HY(na)HY(tives)YH(.)EP(
  )BR(

  )0 P(And this completes the conver)HY(sion)YH( of our simple )SM(hello)ES(
  project to the stan)HY(dard)YH( struc)HY(ture)YH(. Earlier, when exam)HY(in)HY(ing)YH(
  )SM(boot)HY(strap)YH(.build)ES(, we mentioned that modules loaded in this file
  usually provide addi)HY(tional)YH( oper)HY(a)HY(tions)YH(. So we still need to discuss what
  exactly the term )I(build system oper)HY(a)HY(tion)YH()ES( means and see how to use
  oper)HY(a)HY(tions)YH( that are provided by the modules we have loaded. But before we do
  that, let's see how we can build our projects )I(out of source)ES( tree and
  learn about another corner)HY(stone)YH( )SM(build2)ES( concept:
  )I(scopes)ES(.)EP(

  )0 2 4 H(1.3)WB 215 Sn()WB 6 Sn( Output Direc)HY(to)HY(ries)YH( and Scopes)EH(

  )0 P(Two common require)HY(ments)YH( placed on modern build systems are the ability to
  build projects out of the source direc)HY(tory)YH( tree \201referred to as just )I(out
  of source)ES( vs )I(in source)ES(\202 as well as isola)HY(tion)YH( of
  )SM(build)HY(files)YH()ES( from each other when it comes to target and vari)HY(able)YH(
  names. In )SM(build2)ES( these mech)HY(a)HY(nisms)YH( are closely-related, inte)HY(gral)YH(
  parts of the build system.)EP(

  )BR(
  )0 P(This tight inte)HY(gra)HY(tion)YH( has advan)HY(tages)YH(, like being always avail)HY(able)YH( and
  working well with other build system mech)HY(a)HY(nisms)YH(, as well as disad)HY(van)HY(tages)YH(,
  like the inabil)HY(ity)YH( to imple)HY(ment)YH( a completely differ)HY(ent)YH( out of source
  arrange)HY(ment)YH( and/or isola)HY(tion)YH( model. In the end, if you find your)HY(self)YH(
  "fight)HY(ing)YH(" this aspect of )SM(build2)ES(, it will likely be easier to
  use a differ)HY(ent)YH( build system than subvert it.)EP(
  )BR(

  )0 P(Let's start with an example of an out of source build for our
  )SM(hello)ES( project. To recap, this is what we have:)EP(

  ) 11 13 PR($ ls -1
hello/

$ tree hello/
hello/
|-- build/
|   \267-- ...
|-- hello/
|   \267-- ...
|-- buildfile
\267-- manifest)RP(

  )0 P(To start, let's build it in the )SM(hello-out/)ES( direc)HY(tory)YH( next to
  the project:)EP(

  ) 17 57 PR($ b hello/@hello-out/
mkdir fsdir{hello-out/}
mkdir hello-out/fsdir{hello/}
c++ hello/hello/cxx{hello} -> hello-out/hello/obje{hello}
ld hello-out/hello/exe{hello}

$ ls -1
hello/
hello-out/

$ tree hello-out/
hello-out/
\267-- hello/
    |-- hello
    |-- hello.d
    |-- hello.o
    \267-- hello.o.d)RP(

  )0 P(This defi)HY(nitely)YH( requires some explain)HY(ing)YH(. Let's start from the bottom,
  with the )SM(hello-out/)ES( layout. It is )I(paral)HY(lel)YH()ES( to the source
  direc)HY(tory)YH(. This mirrored side-by-side listing \201of the rele)HY(vant)YH( parts\202 should
  illus)HY(trate)YH( this clearly:)EP(

  ) 3 39 PR(hello/             ~~>  hello-out/
\267-- hello/         ~~>  \267-- hello/
    \267-- hello.cxx  ~~>      \267-- hello.o)RP(

  )0 P(In fact, if we copy the contents of )SM(hello-out/)ES( over to
  )SM(hello/)ES(, we will end up with exactly the same result as in the
  in source build. And this is not acci)HY(den)HY(tal)YH(: an in source build is just a
  special case of an out of source build where the )I(out)ES( direc)HY(tory)YH( is the
  same as )I(src)ES(.)EP(

  )BR(
  )0 P(In )SM(build2)ES( this paral)HY(lel)YH( struc)HY(ture)YH( of the out and src
  direc)HY(to)HY(ries)YH( is a corner)HY(stone)YH( design deci)HY(sion)YH( and is non-nego)HY(tiable)YH(, so to
  speak. In partic)HY(u)HY(lar)YH(, out cannot be inside src. And while we can stash the
  build system output \201object files, executa)HY(bles)YH(, etc\202 into \201poten)HY(tially)YH(
  differ)HY(ent)YH(\202 subdi)HY(rec)HY(to)HY(ries)YH(, this is not recom)HY(mended)YH(. As will be shown later,
  )SM(build2)ES( offers better mech)HY(a)HY(nisms)YH( to achieve the same bene)HY(fits)YH(
  \201like reduced clutter, ability to run executa)HY(bles)YH(\202 but without the draw)HY(backs)YH(
  \201like name clashes\202.)EP(
  )BR(

  )0 P(Let's now examine how we invoked the build system to achieve this out of
  source build. Specif)HY(i)HY(cally)YH(, if we were build)HY(ing)YH( in source, our command line
  would have been:)EP(

  ) 1 10 PR($ b hello/)RP(

  )0 P(but for the out of source build, we have:)EP(

  ) 1 21 PR($ b hello/@hello-out/)RP(

  )0 P(In fact, that strange-looking construct, )SM(hello/@hello-out/)ES(
  is just a more elab)HY(o)HY(rate)YH( target spec)HY(i)HY(fi)HY(ca)HY(tion)YH( that explic)HY(itly)YH( spells out the
  target's src and out direc)HY(to)HY(ries)YH(. Let's add an explicit target type to make
  it clearer:)EP(

  ) 1 27 PR($ b hello/@hello-out/dir{.})RP(

  )0 P(What we have on the right of )SM(@)ES( is the target in the out
  direc)HY(tory)YH( and on the left \235 its src direc)HY(tory)YH(. In plain English, this
  command line says "build me the default target from )SM(hello/)ES( in
  the )SM(hello-out/)ES( direc)HY(tory)YH(".)EP(

  )0 P(As an example, if instead we wanted to build only the )SM(hello)ES(
  executable out of source, then the invo)HY(ca)HY(tion)YH( would have looked like
  this:)EP(

  ) 1 43 PR($ b hello/hello/@hello-out/hello/exe{hello})RP(

  )0 P(We could have also spec)HY(i)HY(fied)YH( out for an in source build, but that's
  redun)HY(dant)YH(:)EP(

  ) 1 17 PR($ b hello/@hello/)RP(

  )0 P(There is another example of this elab)HY(o)HY(rate)YH( target spec)HY(i)HY(fi)HY(ca)HY(tion)YH( that can
  be seen in the build diag)HY(nos)HY(tics)YH(, for instance, when installing headers of a
  library \201the )SM(install)ES( oper)HY(a)HY(tion)YH( is discussed in the next
  section\202:)EP(

  ) 4 62 PR($ b install: libhello/@libhello-out/
...
install libhello/libhello/hxx{hello}@libhello-out/libhello/ ->
        /usr/local/include/)RP(

  )0 P(Notice, however, that now the target \201)SM(hxx{hello})ES(\202 is on the
  left of )SM(@)ES(, that is, in the src direc)HY(tory)YH(. It does, however,
  make sense if you think about it: our )SM(hello.hxx)ES( is a )I(source
  file)ES(, in a sense that it is not built and it resides in the project's
  source direc)HY(tory)YH(. This is in contrast, for example, to the
  )SM(exe{hello})ES( target which is the output of the build system and
  goes to the out direc)HY(tory)YH(. So in )SM(build2)ES( targets can be either
  in src or in out \201there can also be )I(out of any project)ES( targets, for
  example, installed files\202.)EP(

  )0 P(The elab)HY(o)HY(rate)YH( target spec)HY(i)HY(fi)HY(ca)HY(tion)YH( can also be used in
  )SM(build)HY(files)YH()ES(. We haven't encoun)HY(tered)YH( any so far because targets
  mentioned without explicit src/out default to out and, natu)HY(rally)YH(, most of
  the targets we mention in )SM(build)HY(files)YH()ES( are things we want built.
  One situ)HY(a)HY(tion)YH( where you may encounter an src target mentioned explic)HY(itly)YH( is
  when spec)HY(i)HY(fy)HY(ing)YH( its instal)HY(la)HY(bil)HY(ity)YH( \201discussed in the next section\202. For
  example, if our project includes the custom)HY(ary)YH( )SM(INSTALL)ES( file, it
  prob)HY(a)HY(bly)YH( doesn't make sense to install it. However, since it is a source
  file, we have to use the elab)HY(o)HY(rate)YH( target spec)HY(i)HY(fi)HY(ca)HY(tion)YH( when disabling its
  instal)HY(la)HY(tion)YH(:)EP(

  ) 1 32 PR(doc{INSTALL}@./: install = false)RP(

  )0 P(Note also that only targets and not prereq)HY(ui)HY(sites)YH( have this notion of
  src/out direc)HY(to)HY(ries)YH(. In a sense, prereq)HY(ui)HY(sites)YH( are rela)HY(tive)YH( to the target
  they are prereq)HY(ui)HY(sites)YH( of and are resolved to targets in a manner that is
  specific to their target types. For )SM(file{})ES(-based prereq)HY(ui)HY(sites)YH(
  the corre)HY(spond)HY(ing)YH( target in out is first looked up and, if found, used.
  Other)HY(wise)YH(, an exist)HY(ing)YH( file in src is searched for and, if found, the
  corre)HY(spond)HY(ing)YH( target \201now in src\202 is used. In partic)HY(u)HY(lar)YH(, this seman)HY(tics)YH(
  gives pref)HY(er)HY(ence)YH( to gener)HY(ated)YH( code over static.)EP(

  )BR(
  )0 P(More precisely, a prereq)HY(ui)HY(site)YH( is rela)HY(tive)YH( to the scope \201discussed below\202
  in which the depen)HY(dency)YH( is declared and not to the target that it is a
  prereq)HY(ui)HY(site)YH( of. However, in most prac)HY(ti)HY(cal)YH( cases, this means the same
  thing.)EP(
  )BR(

  )0 P(And this pretty much covers out of source builds. Let's summa)HY(rize)YH( the key
  points we have estab)HY(lished)YH( so far: Every build has two paral)HY(lel)YH( direc)HY(tory)YH(
  trees, src and out, with the in source build being just a special case where
  they are the same. Targets in a project can be either in the src or out
  direc)HY(tory)YH( though most of the time targets we mention in our
  )SM(build)HY(files)YH()ES( will be in out, which is the default. Prereq)HY(ui)HY(sites)YH(
  are rela)HY(tive)YH( to targets they are prereq)HY(ui)HY(sites)YH( of and
  )SM(file{})ES(-based prereq)HY(ui)HY(sites)YH( are first searched for as declared
  targets in out and then as exist)HY(ing)YH( files in src.)EP(

  )0 P(Note also that we can have as many out of source builds as we want and we
  can place them anywhere we want \201but not inside src\202, say, on a RAM-backed
  disk/filesys)HY(tem)YH(. As an example, let's build our )SM(hello)ES( project
  with two differ)HY(ent)YH( compil)HY(ers)YH(:)EP(

  ) 2 43 PR($ b hello/@hello-gcc/    config.cxx=g++
$ b hello/@hello-clang/  config.cxx=clang++)RP(

  )0 P(In the next section we will see how to perma)HY(nently)YH( config)HY(ure)YH( our out of
  source builds so that we don't have to keep repeat)HY(ing)YH( these long command
  lines.)EP(

  )BR(
  )0 P(While tech)HY(ni)HY(cally)YH( you can have both in source and out of source builds at
  the same time, this is not recom)HY(mended)YH(. While it may work for basic
  projects, as soon as you start using gener)HY(ated)YH( source code \201which is fairly
  common in )SM(build2)ES(\202, it becomes diffi)HY(cult)YH( to predict where the
  compiler will pick gener)HY(ated)YH( headers. There is support for remap)HY(ping)YH(
  mis-picked headers but this may not always work with older C/C++ compil)HY(ers)YH(.
  Plus, as we will see in the next section, )SM(build2)ES( supports
  )I(forwarded config)HY(u)HY(ra)HY(tions)YH()ES( which provide most of the bene)HY(fits)YH( of an in
  source build but without the draw)HY(backs)YH(.)EP(
  )BR(

  )0 P(Let's now turn to )SM(build)HY(file)YH()ES( isola)HY(tion)YH(. It is a common,
  well-estab)HY(lished)YH( prac)HY(tice)YH( to orga)HY(nize)YH( complex soft)HY(ware)YH( projects in direc)HY(tory)YH(
  hier)HY(ar)HY(chies)YH(. One of the bene)HY(fits)YH( of this orga)HY(ni)HY(za)HY(tion)YH( is isola)HY(tion)YH(: we can
  use the same, short file names in differ)HY(ent)YH( subdi)HY(rec)HY(to)HY(ries)YH(. In
  )SM(build2)ES( the project's direc)HY(tory)YH( tree is used as a basis for its
  )I(scope)ES( hier)HY(ar)HY(chy)YH(. In a sense, scopes are like C++ names)HY(paces)YH( that
  auto)HY(mat)HY(i)HY(cally)YH( track the project's filesys)HY(tem)YH( struc)HY(ture)YH( and use direc)HY(to)HY(ries)YH(
  as their names. The follow)HY(ing)YH( listing illus)HY(trates)YH( the paral)HY(lel)YH( direc)HY(tory)YH( and
  scope hier)HY(ar)HY(chies)YH( for our )SM(hello)ES( project. The
  )SM(build/)ES( subdi)HY(rec)HY(tory)YH( is special and does not have a
  corre)HY(spond)HY(ing)YH( scope.)EP(

  ) 7 33 PR(hello/                   hello/
|                        {
\267-- hello/                 hello/
    |                      {
    \267-- ...                  ...
                           }
                         })RP(

  )0 P(Every )SM(build)HY(file)YH()ES( is loaded in its corre)HY(spond)HY(ing)YH( scope,
  vari)HY(ables)YH( set in a )SM(build)HY(file)YH()ES( are set in this scope and rela)HY(tive)YH(
  targets mentioned in a )SM(build)HY(file)YH()ES( are rela)HY(tive)YH( to this scope's
  direc)HY(tory)YH(. Let's "load" the )SM(build)HY(file)YH()ES( contents from our
  )SM(hello)ES( project to the above listing:)EP(

  ) 9 54 PR(hello/                   hello/
|                        {
|-- buildfile              ./: {*/ -build/}
|
\267-- hello/                 hello/
    |                      {
    \267-- buildfile            exe{hello}: {hxx cxx}{**}
                           }
                         })RP(

  )0 P(In fact, to be abso)HY(lutely)YH( precise, we should also add the contents of
  )SM(boot)HY(strap)YH(.build)ES( and )SM(root.build)ES( to the project's
  root scope \201module loading is omitted for brevity\202:)EP(

  ) 16 54 PR(hello/                   hello/
|                        {
|-- build/
|   |-- bootstrap.build    project = hello
|   |
|   \267-- root.build         cxx.std = latest
|                          hxx{*}: extension = hxx
|                          cxx{*}: extension = cxx
|
|-- buildfile              ./: {*/ -build/}
|
\267-- hello/                 hello/
    |                      {
    \267-- buildfile            exe{hello}: {hxx cxx}{**}
                           }
                         })RP(

  )0 P(The above scope struc)HY(ture)YH( is very similar to what you will see \201besides a
  lot of other things\202 if you build with )SM(--dump\240match)ES(. With
  this option the build system driver dumps the build state after match)HY(ing)YH(
  rules to targets \201see )0 21 1 A(Diag)HY(nos)HY(tics)YH( and
  Debug)HY(ging)YH()21 0 TN TL()Ec /AF f D( for more infor)HY(ma)HY(tion)YH(\202. Here is an abbre)HY(vi)HY(ated)YH( output of
  build)HY(ing)YH( our )SM(hello)ES( with )SM(--dump)ES( \201assum)HY(ing)YH( an in
  source build in )SM(/tmp/hello)ES(\202:)EP(

  ) 55 52 PR($ b --dump match

/
{
  [target_triplet] build.host = x86_64-linux-gnu
  [string] build.host.class = linux
  [string] build.host.cpu = x86_64
  [string] build.host.system = linux-gnu

  /tmp/hello/
  {

    [dir_path] src_root = /tmp/hello/
    [dir_path] out_root = /tmp/hello/

    [dir_path] src_base = /tmp/hello/
    [dir_path] out_base = /tmp/hello/

    [project_name] project = hello
    [string] project.summary = hello executable
    [string] project.url = https://example.org/hello

    [string] version = 1.2.3
    [uint64] version.major = 1
    [uint64] version.minor = 2
    [uint64] version.patch = 3

    [string] cxx.std = latest

    [string] cxx.id = gcc
    [string] cxx.version = 8.1.0)WR(
    [uint64] cxx.version.major = 8
    [uint64] cxx.version.minor = 1
    [uint64] cxx.version.patch = 0

    [target_triplet] cxx.target = x86_64-w64-mingw32
    [string] cxx.target.class = windows
    [string] cxx.target.cpu = x86_64
    [string] cxx.target.system = mingw32

    hxx{*}: [string] extension = hxx
    cxx{*}: [string] extension = cxx

    hello/
    {
      [dir_path] src_base = /tmp/hello/hello/
      [dir_path] out_base = /tmp/hello/hello/

      dir{./}: exe{hello}
      exe{hello.}: cxx{hello.cxx}
    }

    dir{./}: dir{hello/} manifest{manifest}
  }
})RP(

  )0 P(This is prob)HY(a)HY(bly)YH( quite a bit more infor)HY(ma)HY(tion)YH( than what you've expected
  to see so let's explain a couple of things. Firstly, it appears there is
  another scope outer to our project's root. In fact, )SM(build2)ES(
  extends scoping outside of projects with the root of the filesys)HY(tem)YH( \201denoted
  by the special )SM(/)ES(\202 being the )I(global scope)ES(. This exten)HY(sion)YH(
  becomes useful when we try to build multi)HY(ple)YH( unre)HY(lated)YH( projects or import
  one project into another. In this model all projects are part of a single
  scope hier)HY(ar)HY(chy)YH( with the global scope at its root.)EP(

  )0 P(The global scope is read-only and contains a number of pre-defined
  )I(build-wide)ES( vari)HY(ables)YH( such as the build system version, host plat)HY(form)YH(
  \201shown in the above listing\202, etc.)EP(

  )0 P(Next, inside the global scope, we see our project's root scope
  \201)SM(/tmp/hello/)ES(\202. Besides the vari)HY(ables)YH( that we have set ourselves
  \201like )SM(project)ES(\202, it also contains a number of vari)HY(ables)YH( set by
  the build system core \201for example, )SM(out_base)ES(,
  )SM(src_root)ES(, etc\202 as well by build system modules \201for example,
  )SM(project.*)ES( and )SM(version.*)ES( vari)HY(ables)YH( set by the
  )SM(version)ES( module and )SM(cxx.*)ES( vari)HY(ables)YH( set by the
  )SM(cxx)ES( module\202.)EP(

  )0 P(The scope for our project's source direc)HY(tory)YH( \201)SM(hello/)ES(\202 should
  look famil)HY(iar)YH(. We again have a few special vari)HY(ables)YH( \201)SM(out_base)ES(,
  )SM(src_base)ES(\202. Notice also that the name patterns in prereq)HY(ui)HY(sites)YH(
  have been expanded to the actual files.)EP(

  )0 P(As you can prob)HY(a)HY(bly)YH( guess from their names, the )SM(src_*)ES( and
  )SM(out_*)ES( vari)HY(ables)YH( track the asso)HY(ci)HY(a)HY(tion)YH( between scopes and
  src/out direc)HY(to)HY(ries)YH(. They are main)HY(tained)YH( auto)HY(mat)HY(i)HY(cally)YH( by the build system
  core with the )SM(src/out_base)ES( pair set on each scope within the
  project and an addi)HY(tional)YH( )SM(src/out_root)ES( pair set on the
  project's root scope so that we can get the project's root direc)HY(to)HY(ries)YH( from
  anywhere in the project. Note that direc)HY(tory)YH( paths in these vari)HY(ables)YH( are
  always abso)HY(lute)YH( and normal)HY(ized)YH(.)EP(

  )0 P(In the above example the corre)HY(spond)HY(ing)YH( src/out vari)HY(able)YH( pairs have the
  same values because we were build)HY(ing)YH( in source. As an example, this is what
  the asso)HY(ci)HY(a)HY(tion)YH( will look like for an out of source build:)EP(

  ) 14 61 PR(hello/  ~~>      hello-out/                   <~~  hello-out/
|                {                                 |
|                  src_root = .../hello/           |
|                  out_root = .../hello-out/       |
|                                                  |
|                  src_base = .../hello/           |
|                  out_base = .../hello-out/       |
|                                                  |
\267-- hello/  ~~>    hello/                     <~~  \267-- hello/
                   {
                     src_base = .../hello/hello/
                     out_base = .../hello-out/hello/
                   }
                 })RP(

  )0 P(Now that we have some scopes and vari)HY(ables)YH( to play with, it's a good time
  to intro)HY(duce)YH( vari)HY(able)YH( expan)HY(sion)YH(. To get the value stored in a vari)HY(able)YH( we
  use )SM($)ES( followed by the vari)HY(able)YH('s name. The vari)HY(able)YH( is first
  looked up in the current scope \201that is, the scope in which the expan)HY(sion)YH(
  was encoun)HY(tered)YH(\202 and, if not found, in the outer scopes all the way to the
  global scope.)EP(

  )BR(
  )0 P(To be precise, this is for the default )I(vari)HY(able)YH( visi)HY(bil)HY(ity)YH()ES(.
  Vari)HY(ables)YH(, however, can have more limited visi)HY(bil)HY(i)HY(ties)YH(, such as
  )I(project)ES(, )I(scope)ES(, )I(target)ES(, or )I(prereq)HY(ui)HY(site)YH()ES(.)EP(
  )BR(

  )0 P(To illus)HY(trate)YH( the lookup seman)HY(tics)YH(, let's add the follow)HY(ing)YH( line to each
  )SM(build)HY(file)YH()ES( in our )SM(hello)ES( project:)EP(

  ) 9 38 PR($ cd hello/  # Change to project root.

$ cat buildfile
...
info "src_base: $src_base"

$ cat hello/buildfile
...
info "src_base: $src_base")RP(

  )0 P(And then build it:)EP(

  ) 3 54 PR($ b
buildfile:3:1: info: src_base: /tmp/hello/
hello/buildfile:8:1: info: src_base: /tmp/hello/hello/)RP(

  )0 P(In this case )SM(src_base)ES( is defined in each of the two scopes
  and we get their respec)HY(tive)YH( values. If, however, we change the above line to
  print )SM(src_root)ES( instead of )SM(src_base)ES(, we will get
  the same value from the root scope:)EP(

  ) 2 48 PR(buildfile:3:1: info: src_root: /tmp/hello/
hello/buildfile:8:1: info: src_root: /tmp/hello/)RP(

  )BR(
  )0 P(In this section we've only scratched the surface when it comes to
  vari)HY(ables)YH(. In partic)HY(u)HY(lar)YH(, vari)HY(ables)YH( and vari)HY(able)YH( values in
  )SM(build2)ES( are option)HY(ally)YH( typed \201those )SM([string])ES(,
  )SM([uint64])ES( we've seen in the build state dump\202. And in certain
  contexts the lookup seman)HY(tics)YH( actu)HY(ally)YH( starts from the target, not from the
  scope \201target-specific vari)HY(ables)YH(; there are also prereq)HY(ui)HY(site)YH(-specific\202.
  These and other vari)HY(able)YH(-related topics will be covered in subse)HY(quent)YH(
  sections.)EP(
  )BR(

  )0 P(One typical place to find )SM(src/out_root)ES( expan)HY(sions)YH( is in the
  include search path options. For example, the source subdi)HY(rec)HY(tory)YH(
  )SM(build)HY(file)YH()ES( gener)HY(ated)YH( by )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA( for
  an executable project actu)HY(ally)YH( looks like this \201)SM(poptions)ES( stands
  for )I(prepro)HY(ces)HY(sor)YH( options)ES(\202:)EP(

  ) 3 43 PR(exe{hello}: {hxx cxx}{**}

cxx.poptions =+ "-I$out_root" "-I$src_root")RP(

  )BR(
  )0 P(The strange-looking )SM(=+)ES( line is a )I(prepend)ES( vari)HY(able)YH(
  assign)HY(ment)YH(. It adds the value on the right hand side to the begin)HY(ning)YH( of the
  exist)HY(ing)YH( value. So, in the above example, the two header search paths will
  be added before any of the exist)HY(ing)YH( prepro)HY(ces)HY(sor)YH( options \201and thus will be
  consid)HY(ered)YH( first\202.)EP(

  )0 P(There are also the )I(append)ES( assign)HY(ment)YH(, )SM(+=)ES(, which adds
  the value on the right hand side to the end of the exist)HY(ing)YH( value, as well
  as, of course, the normal or )I(replace)ES( assign)HY(ment)YH(, )SM(=)ES(,
  which replaces the exist)HY(ing)YH( value with the right hand side. One way to
  remem)HY(ber)YH( where the exist)HY(ing)YH( and new values end up in the )SM(=+)ES( and
  )SM(+=)ES( results is to imagine the new value taking the posi)HY(tion)YH( of
  )SM(=)ES( and the exist)HY(ing)YH( value \235 of )SM(+)ES(.)EP(
  )BR(

  )0 P(The above )SM(build)HY(file)YH()ES( allows us to include our headers using
  the project's name as a prefix, inline with the )0 2 A(Canon)HY(i)HY(cal)YH(
  Project Struc)HY(ture)YH()EA( guide)HY(lines)YH(. For example, if we added the
  )SM(utility.hxx)ES( header to our )SM(hello)ES( project, we would
  include it like this:)EP(

  ) 8 28 PR(#include <iostream>

#include <hello/utility.hxx>

int main \201\202
{
...
})RP(

  )BR(
  )0 P(Besides )SM(poptions)ES(, there are also )SM(coptions)ES(
  \201compile options\202, )SM(loptions)ES( \201link options\202,
  )SM(aoptions)ES( \201archive options\202 and )SM(libs)ES( \201extra
  libraries to link\202. If you are famil)HY(iar)YH( with )SM(make)ES(, these are
  roughly equiv)HY(a)HY(lent)YH( to )SM(CPPFLAGS)ES(,
  )SM(CFLAGS)ES(/)SM(CXXFLAGS)ES(, )SM(LDFLAGS)ES(,
  )SM(ARFLAGS)ES(, and )SM(LIBS)ES(/)SM(LDLIBS)ES(,
  respec)HY(tively)YH(. Here they are again in the tabular form:)EP(

  ) 5 46 PR(*.poptions   preprocess        CPPFLAGS
*.coptions   compile           CFLAGS/CXXFLAGS
*.loptions   link              LDFLAGS
*.aoptions   archive           ARFLAGS
*.libs       extra libraries   LIBS/LDLIBS)RP(

  )0 P(More specif)HY(i)HY(cally)YH(, there are three sets of these vari)HY(ables)YH(:
  )SM(cc.*)ES( \201stands for )I(C-common)ES(\202 which applies to all C-like
  languages as well as )SM(c.*)ES( and )SM(cxx.*)ES( which only
  apply during the C and C++ compi)HY(la)HY(tion)YH(, respec)HY(tively)YH(. We can use these
  vari)HY(ables)YH( in our )SM(build)HY(files)YH()ES( to adjust the compiler/linker
  behav)HY(ior)YH(. For example:)EP(

  ) 8 51 PR(if \201$cc.class == 'gcc'\202
{
  cc.coptions  += -fno-strict-aliasing  # C and C++
  cxx.coptions += -fno-exceptions       # only C++
}

if \201$c.target.class != 'windows'\202
  c.libs += -ldl  # only C)RP(

  )0 P(Addi)HY(tion)HY(ally)YH(, as we will see in )0 8 1 A(Config)HY(ur)HY(ing)YH()8 0 TN TL()Ec /AF f D(, there are also the
  )SM(config.cc.*)ES(, )SM(config.c.*)ES(, and
  )SM(config.cxx.*)ES( sets which are used by the users of our projects
  to provide exter)HY(nal)YH( config)HY(u)HY(ra)HY(tion)YH(. The initial values of the
  )SM(cc.*)ES(, )SM(c.*)ES(, and )SM(cxx.*)ES( vari)HY(ables)YH( are
  taken from the corre)HY(spond)HY(ing)YH( )SM(config.*.*)ES( values.)EP(

  )0 P(And, as we will learn in )0 13 1 A(Library Expor)HY(ta)HY(tion)YH()13 0 TN TL()Ec /AF f D(,
  there are also the )SM(cc.export.*)ES(, )SM(c.export.*)ES(, and
  )SM(cxx.export.*)ES( sets that are used to specify options that should
  be exported to the users of our library.)EP(

  )0 P(If we adjust the )SM(cc.*)ES(, )SM(c.*)ES(, and
  )SM(cxx.*)ES( vari)HY(ables)YH( at the scope level, as in the above frag)HY(ment)YH(,
  then the changes will apply when build)HY(ing)YH( every target in this scope \201as
  well as in the nested scopes, if any\202. Usually this is what we want but
  some)HY(times)YH( we may need to pass addi)HY(tional)YH( options only when compil)HY(ing)YH( certain
  source files or linking certain libraries or executa)HY(bles)YH(. For that we use
  the target-specific vari)HY(able)YH( assign)HY(ment)YH(. For example:)EP(

  ) 4 38 PR(exe{hello}: {hxx cxx}{**}

obj{utility}: cxx.poptions += -DNDEBUG
exe{hello}: cxx.loptions += -static)RP(

  )0 P(Note that we set these vari)HY(ables)YH( on targets which they affect. In
  partic)HY(u)HY(lar)YH(, those with a back)HY(ground)YH( in other build systems may, for example,
  erro)HY(neously)YH( expect that setting )SM(poptions)ES( on a library target
  will affect compi)HY(la)HY(tion)YH( of its prereq)HY(ui)HY(sites)YH(. For example, the follow)HY(ing)YH(
  does not work:)EP(

  ) 1 36 PR(exe{hello}: cxx.poptions += -DNDEBUG)RP(

  )0 P(The recom)HY(mended)YH( way to achieve this behav)HY(ior)YH( in )SM(build2)ES( is to
  orga)HY(nize)YH( your targets into subdi)HY(rec)HY(to)HY(ries)YH(, in which case we can just set the
  vari)HY(ables)YH( on the scope. And if this is impos)HY(si)HY(ble)YH( or unde)HY(sir)HY(able)YH(, then we
  can use target type/pattern-specific vari)HY(ables)YH( \201if there is a common
  pattern\202 or simply list the affected targets explic)HY(itly)YH(. For example:)EP(

  ) 2 43 PR(obj{*.test}: cxx.poptions += -DDEFINE_MAIN
obj{main utility}: cxx.poptions += -DNDEBUG)RP(

  )0 P(The first line covers compi)HY(la)HY(tion)YH( of source files that have the
  )SM(.test)ES( second-level exten)HY(sion)YH( \201see )0 20 1 A(Imple)HY(ment)HY(ing)YH( Unit Testing)20 0 TN TL()Ec /AF f D( for back)HY(ground)YH(\202 while
  the second simply lists the targets explic)HY(itly)YH(.)EP(

  )0 P(It is also possi)HY(ble)YH( to specify differ)HY(ent)YH( options when produc)HY(ing)YH( differ)HY(ent)YH(
  types of object files \201)SM(obje{})ES( \235 executable,
  )SM(obja{})ES( \235 static library, or )SM(objs{})ES( \235
  shared library\202 or when linking differ)HY(ent)YH( libraries \201)SM(liba{})ES(
  \235 static library or )SM(libs{})ES( \235 shared library\202. See
  )0 13 1 A(Library Expor)HY(ta)HY(tion)YH( and Version)HY(ing)YH()13 0 TN TL()Ec /AF f D( for an
  example.)EP(
  )BR(

  )0 P(As mentioned above, each )SM(build)HY(file)YH()ES( in a project is loaded
  into its corre)HY(spond)HY(ing)YH( scope. As a result, we rarely need to open scopes
  explic)HY(itly)YH(. In the few cases that we do, we use the follow)HY(ing)YH( syntax:)EP(

  ) 4 12 PR(<directory>/
{
  ...
})RP(

  )0 P(If the scope direc)HY(tory)YH( is rela)HY(tive)YH(, then it is assumed to be rela)HY(tive)YH( to
  the current scope. As an exer)HY(cise)YH( for under)HY(stand)HY(ing)YH(, let's reim)HY(ple)HY(ment)YH( our
  )SM(hello)ES( project as a single )SM(build)HY(file)YH()ES(. That is, we
  move the contents of the source subdi)HY(rec)HY(tory)YH( )SM(build)HY(file)YH()ES( into the
  root )SM(build)HY(file)YH()ES(:)EP(

  ) 16 31 PR($ tree hello/
hello/
|-- build/
|   \267-- ...
|-- hello/
|   \267-- hello.cxx
\267-- buildfile

$ cat hello/buildfile

./: hello/

hello/
{
  ./: exe{hello}: {hxx cxx}{**}
})RP(

  )BR(
  )0 P(While this single )SM(build)HY(file)YH()ES( setup is not recom)HY(mended)YH( for new
  projects, it can be useful for non-intru)HY(sive)YH( conver)HY(sion)YH( of exist)HY(ing)YH( projects
  to )SM(build2)ES(. One approach is to place the unmod)HY(i)HY(fied)YH( orig)HY(i)HY(nal)YH(
  project into a subdi)HY(rec)HY(tory)YH( \201poten)HY(tially)YH( automat)HY(ing)YH( this with a mech)HY(a)HY(nism)YH(
  such as )SM(git\2011\202)ES( submod)HY(ules)YH(\202 then adding the )SM(build/)ES(
  subdi)HY(rec)HY(tory)YH( and the root )SM(build)HY(file)YH()ES( which explic)HY(itly)YH( opens
  scopes to define the build over the upstream project's subdi)HY(rec)HY(tory)YH(
  struc)HY(ture)YH(.)EP(
  )BR(

  )0 P(Seeing this merged )SM(build)HY(file)YH()ES( may make you wonder what
  exactly caused the loading of the source subdi)HY(rec)HY(tory)YH( )SM(build)HY(file)YH()ES(
  in our normal setup. In other words, when we build our )SM(hello)ES(
  from the project root, who loads )SM(hello/build)HY(file)YH()ES( and why?)EP(

  )0 P(Actu)HY(ally)YH(, in the earlier days of )SM(build2)ES(, we had to
  explic)HY(itly)YH( load )SM(build)HY(files)YH()ES( that define targets we depend on
  with the )SM(include)ES( direc)HY(tive)YH(. In fact, we still can \201and have to
  if we are depend)HY(ing)YH( on targets other than direc)HY(to)HY(ries)YH(\202. For example:)EP(

  ) 3 23 PR(./: hello/

include hello/buildfile)RP(

  )0 P(We can also omit )SM(build)HY(file)YH()ES( for brevity and have just:)EP(

  ) 1 14 PR(include hello/)RP(

  )0 P(This explicit inclu)HY(sion)YH(, however, quickly becomes tire)HY(some)YH( as the number
  of direc)HY(to)HY(ries)YH( grows. It also makes using wild)HY(card)YH( patterns for subdi)HY(rec)HY(tory)YH(
  prereq)HY(ui)HY(sites)YH( a lot less appeal)HY(ing)YH(.)EP(

  )0 P(To over)HY(come)YH( this the )SM(dir{})ES( target type imple)HY(ments)YH( an
  inter)HY(est)HY(ing)YH( prereq)HY(ui)HY(site)YH( to target reso)HY(lu)HY(tion)YH( seman)HY(tics)YH(: if there is no
  exist)HY(ing)YH( target with this name, a )SM(build)HY(file)YH()ES( that \201presum)HY(ably)YH(\202
  defines this target is auto)HY(mat)HY(i)HY(cally)YH( loaded from the corre)HY(spond)HY(ing)YH(
  direc)HY(tory)YH(. In fact, this mech)HY(a)HY(nism)YH( goes a step further and, if the
  )SM(build)HY(file)YH()ES( does not exist, then it assumes one with the
  follow)HY(ing)YH( contents was implied:)EP(

  ) 1 6 PR(./: */)RP(

  )0 P(That is, it simply builds all the subdi)HY(rec)HY(to)HY(ries)YH(. This is espe)HY(cially)YH(
  handy when orga)HY(niz)HY(ing)YH( related tests into direc)HY(tory)YH( hier)HY(ar)HY(chies)YH(.)EP(

  )BR(
  )0 P(As mentioned above, this auto)HY(matic)YH( inclu)HY(sion)YH( is only trig)HY(gered)YH( if the
  target we depend on is )SM(dir{})ES( and we still have to explic)HY(itly)YH(
  include the neces)HY(sary)YH( )SM(build)HY(files)YH()ES( for other targets. One common
  example is a project consist)HY(ing)YH( of a library and an executable that links
  it, each resid)HY(ing)YH( in a sepa)HY(rate)YH( direc)HY(tory)YH( next to each other \201as noted
  earlier, this is not recom)HY(mended)YH( for projects that you plan to package\202. For
  example:)EP(

  ) 11 17 PR(hello/
|-- build/
|   \267-- ...
|-- hello/
|   |-- main.cxx
|   \267-- buildfile
|-- libhello/
|   |-- hello.hxx
|   |-- hello.cxx
|   \267-- buildfile
\267-- buildfile)RP(

  )0 P(In this case the executable )SM(build)HY(file)YH()ES( would look along these
  lines:)EP(

  ) 3 48 PR(include ../libhello/ # Include lib{hello}.

exe{hello}: {hxx cxx}{**} ../libhello/lib{hello})RP(

  )0 P(Note also that )SM(build)HY(file)YH()ES( inclu)HY(sion)YH( should only be used for
  access)HY(ing)YH( targets within the same project. For cross-project refer)HY(ences)YH( we
  use )0 12 1 A(Target Impor)HY(ta)HY(tion)YH()12 0 TN TL()Ec /AF f D(.)EP(
  )BR(

  )0 2 5 H(1.4)WB 216 Sn()WB 7 Sn( Oper)HY(a)HY(tions)YH()EH(

  )0 P(Modern build systems have to perform oper)HY(a)HY(tions)YH( other than just build)HY(ing)YH(:
  clean)HY(ing)YH( the build output, running tests, installing/unin)HY(stalling)YH( the build
  results, prepar)HY(ing)YH( source distri)HY(bu)HY(tions)YH(, and so on. And, if the build system
  has inte)HY(grated)YH( config)HY(u)HY(ra)HY(tion)YH( support, config)HY(ur)HY(ing)YH( the project would
  natu)HY(rally)YH( belong to this list as well.)EP(

  )BR(
  )0 P(If you are famil)HY(iar)YH( with )SM(make)ES(, you should recog)HY(nize)YH( the
  paral)HY(lel)YH( with the common )SM(clean)ES( )SM(test)ES(,
  )SM(install)ES(, and )SM(dist)ES(, "oper)HY(a)HY(tion)YH(" pseudo-targets.)EP(
  )BR(

  )0 P(In )SM(build2)ES( we have the concept of a )I(build system
  oper)HY(a)HY(tion)YH()ES( performed on a target. The two pre-defined oper)HY(a)HY(tions)YH( are
  )SM(update)ES( and )SM(clean)ES( with other oper)HY(a)HY(tions)YH( provided by
  build system modules.)EP(

  )0 P(Oper)HY(a)HY(tions)YH( to be performed and targets to perform them on are spec)HY(i)HY(fied)YH(
  on the command line. As discussed earlier, )SM(update)ES( is the
  default oper)HY(a)HY(tion)YH( and )SM(./)ES( in the current direc)HY(tory)YH( is the
  default target if no oper)HY(a)HY(tion)YH( and/or target is spec)HY(i)HY(fied)YH( explic)HY(itly)YH(. And,
  similar to targets, we can specify multi)HY(ple)YH( oper)HY(a)HY(tions)YH( \201not neces)HY(sar)HY(ily)YH( on
  the same target\202 in a single build system invo)HY(ca)HY(tion)YH(. The list of oper)HY(a)HY(tions)YH(
  to perform and targets to perform them on is called a )I(build
  spec)HY(i)HY(fi)HY(ca)HY(tion)YH()ES( or )I(build)HY(spec)YH()ES( for short \201see )0 2 A()SM()BD(b\2011\202)ES()ES()EA( for details\202. Here are a few
  exam)HY(ples)YH(:)EP(

  ) 13 55 PR($ cd hello        # Change to project root.

$ b               # Update current directory.
$ b ./            # Same as above.
$ b update        # Same as above.
$ b update: ./    # Same as above.

$ b clean update  # Rebuild.

$ b clean:  hello/             # Clean specific target.
$ b update: hello/exe{hello}   # Update specific target

$ b update: libhello/ tests/   # Update two targets.)RP(

  )BR(
  )0 P(If you are running )SM(build2)ES( from Power)HY(Shell)YH(, then you will
  need to use quoting when updat)HY(ing)YH( specific targets, for example:)EP(

  ) 1 30 PR($ b update: 'hello/exe{hello}')RP(
  )BR(

  )0 P(Let's revisit )SM(build/boot)HY(strap)YH(.build)ES( from our
  )SM(hello)ES( project:)EP(

  ) 7 15 PR(project = hello

using version
using config
using test
using install
using dist)RP(

  )0 P(Other than )SM(version)ES(, all the modules we load define new
  oper)HY(a)HY(tions)YH(. Let's examine each of them start)HY(ing)YH( with
  )SM(config)ES(.)EP(

  )0 3 6 H(1.4.1)WB 217 Sn()WB 8 Sn( Config)HY(ur)HY(ing)YH()EH(

  )0 P(As mentioned briefly earlier, the )0 161 1 A()SM(config)ES()161 0 TN TL()Ec /AF f D( module provides support for
  persist)HY(ing)YH( config)HY(u)HY(ra)HY(tions)YH( by having us )I(config)HY(ure)YH()ES( our projects. At
  first it may feel natural to call )SM(config)HY(ure)YH()ES( an oper)HY(a)HY(tion)YH(. There
  is, however, a concep)HY(tual)YH( problem: we don't really config)HY(ure)YH( a target. And,
  perhaps after some medi)HY(ta)HY(tion)YH(, it should become clear that what we are
  really doing is config)HY(ur)HY(ing)YH( oper)HY(a)HY(tions)YH( on targets. For example, config)HY(ur)HY(ing)YH(
  updat)HY(ing)YH( a C++ project might involve detect)HY(ing)YH( and saving infor)HY(ma)HY(tion)YH( about
  the C++ compiler while config)HY(ur)HY(ing)YH( installing it may require spec)HY(i)HY(fy)HY(ing)YH( the
  instal)HY(la)HY(tion)YH( direc)HY(tory)YH(.)EP(

  )0 P(In other words, )SM(config)HY(ure)YH()ES( is an oper)HY(a)HY(tion)YH( on oper)HY(a)HY(tion)YH( on
  targets \235 a meta-oper)HY(a)HY(tion)YH(.  And so in )SM(build2)ES( we have the
  concept of a )I(build system meta-oper)HY(a)HY(tion)YH()ES(.  If not spec)HY(i)HY(fied)YH(
  explic)HY(itly)YH( \201as part of the build)HY(spec)YH(\202, the default is )SM(perform)ES(,
  which is to simply perform the oper)HY(a)HY(tion)YH(.)EP(

  )0 P(Back to )SM(config)ES(, this module provides two meta-oper)HY(a)HY(tions)YH(:
  )SM(config)HY(ure)YH()ES( which saves the config)HY(u)HY(ra)HY(tion)YH( of a project into the
  )SM(build/config.build)ES( file as well as )SM(disfig)HY(ure)YH()ES( which
  removes it.)EP(

  )BR(
  )0 P(While the common meaning of the word )I(disfig)HY(ure)YH()ES( is some)HY(what)YH(
  differ)HY(ent)YH( to what we make it mean in this context, we still prefer it over
  the commonly suggested alter)HY(na)HY(tive)YH( \201)I(decon)HY(fig)HY(ure)YH()ES(\202 for the symme)HY(try)YH( of
  their Latin )I(con-)ES( \201"together"\202 and )I(dis-)ES( \201"apart"\202 prefixes.)EP(
  )BR(

  )0 P(Let's say for the in source build of our )SM(hello)ES( project we
  want to use )SM(Clang)ES( and enable debug infor)HY(ma)HY(tion)YH(. Without
  persis)HY(tence)YH( we would have to repeat this config)HY(u)HY(ra)HY(tion)YH( on every build system
  invo)HY(ca)HY(tion)YH(:)EP(

  ) 3 45 PR($ cd hello/  # Change to project root.

$ b config.cxx=clang++ config.cxx.coptions=-g)RP(

  )0 P(Instead, we can config)HY(ure)YH( our project with this infor)HY(ma)HY(tion)YH( once and from
  then on invoke the build system without any argu)HY(ments)YH(:)EP(

  ) 13 55 PR($ b configure config.cxx=clang++ config.cxx.coptions=-g

$ tree ./
./
|-- build/
|   |-- ...
|   \267-- config.build
\267-- ...

$ b
$ b clean
$ b
...)RP(

  )0 P(To remove the persis)HY(tent)YH( config)HY(u)HY(ra)HY(tion)YH( we use the )SM(disfig)HY(ure)YH()ES(
  meta-oper)HY(a)HY(tion)YH(:)EP(

  ) 1 13 PR($ b disfigure)RP(

  )0 P(Let's again config)HY(ure)YH( our project and take a look at
  )SM(config.build)ES(:)EP(

  ) 11 55 PR($ b configure config.cxx=clang++ config.cxx.coptions=-g

$ cat build/config.build

config.cxx = clang++
config.cxx.poptions = [null]
config.cxx.coptions = -g
config.cxx.loptions = [null]
config.cxx.aoptions = [null]
config.cxx.libs = [null]
...)RP(

  )0 P(As you can see, it's just a build)HY(file)YH( with a bunch of vari)HY(able)YH(
  assign)HY(ments)YH(. In partic)HY(u)HY(lar)YH(, this means you can tweak your build
  config)HY(u)HY(ra)HY(tion)YH( by modi)HY(fy)HY(ing)YH( this file with your favorite editor. Or,
  alter)HY(na)HY(tively)YH(, you can adjust the config)HY(u)HY(ra)HY(tion)YH( by recon)HY(fig)HY(ur)HY(ing)YH( the
  project:)EP(

  ) 11 28 PR($ b configure config.cxx=g++

$ cat build/config.build

config.cxx = g++
config.cxx.poptions = [null]
config.cxx.coptions = -g
config.cxx.loptions = [null]
config.cxx.aoptions = [null]
config.cxx.libs = [null]
...)RP(

  )0 P(Any vari)HY(able)YH( value spec)HY(i)HY(fied)YH( on the command line over)HY(rides)YH( those
  spec)HY(i)HY(fied)YH( in the )SM(build)HY(files)YH()ES(. As a result,
  )SM(config.cxx)ES( was updated while the value of
  )SM(config.cxx.coptions)ES( was preserved.)EP(

  )BR(
  )0 P(To revert a config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH( to its default value, list its name in
  the special )SM(config.config.disfig)HY(ure)YH()ES( vari)HY(able)YH(. For example:)EP(

  ) 1 48 PR($ b configure config.config.disfigure=config.cxx)RP(
  )BR(

  )0 P(Command line vari)HY(able)YH( over)HY(rides)YH( are also handy to adjust the
  config)HY(u)HY(ra)HY(tion)YH( for a single build system invo)HY(ca)HY(tion)YH(. For example, let's say
  we want to quickly check that our project builds with opti)HY(miza)HY(tion)YH( but
  without perma)HY(nently)YH( chang)HY(ing)YH( the config)HY(u)HY(ra)HY(tion)YH(:)EP(

  ) 2 48 PR($ b config.cxx.coptions=-O3  # Rebuild with -O3.
$ b                          # Rebuild with -g.)RP(

  )BR(
  )0 P(Besides the various )SM(*.?options)ES( vari)HY(ables)YH(, we can also
  specify the "compiler mode" options as part of the compiler executable in
  )SM(config.c)ES( and )SM(config.cxx)ES(. Such options cannot be
  modi)HY(fied)YH( by build)HY(files)YH( and they will appear last on the command lines. For
  example:)EP(

  ) 1 35 PR($ b configure config.cxx="g++ -m32")RP(

  )0 P(The compiler mode options are also the correct place to specify
  )I(system-like)ES( header \201)SM(-I)ES(\202 and library \201)SM(-L)ES(,
  )SM(/LIBPATH)ES(\202 search paths. Where by system-like we mean common
  instal)HY(la)HY(tion)YH( direc)HY(to)HY(ries)YH( like )SM(/usr/include)ES( or
  )SM(/usr/local/lib)ES( which may contain older versions of the
  libraries we are trying to build and/or use. By spec)HY(i)HY(fy)HY(ing)YH( these paths as
  part of the mode options \201as opposed to )SM(config.*.poptions)ES( and
  )SM(config.*.loptions)ES(\202 we make sure they will be consid)HY(ered)YH( last,
  similar to the compiler's build-in search paths. For example:)EP(

  ) 1 45 PR($ b configure config.cxx="g++ -L/opt/install")RP(
  )BR(

  )0 P(If we would like to prevent subse)HY(quent)YH( changes to the envi)HY(ron)HY(ment)YH( from
  affect)HY(ing)YH( our build config)HY(u)HY(ra)HY(tion)YH(, we can make it )I(hermetic)ES( \201see )0 162 1 A(Hermetic Build Config)HY(u)HY(ra)HY(tions)YH()162 0 TN TL()Ec /AF f D( for
  details\202:)EP(

  ) 1 45 PR($ b configure config.config.hermetic=true ...)RP(

  )BR(
  )0 P(One promi)HY(nent)YH( use of hermetic config)HY(u)HY(ra)HY(tions)YH( is to preserve the build
  envi)HY(ron)HY(ment)YH( of the Visual Studio devel)HY(op)HY(ment)YH( command prompt. That is,
  hermet)HY(i)HY(cally)YH( config)HY(ur)HY(ing)YH( our project in a suit)HY(able)YH( Visual Studio command
  prompt makes us free to build it from any other prompt or shell, IDE,
  etc.)EP(
  )BR(

  )0 P(We can also config)HY(ure)YH( out of source builds of our projects. In this case,
  besides )SM(config.build)ES(, )SM(config)HY(ure)YH()ES( also saves the
  loca)HY(tion)YH( of the source direc)HY(tory)YH( so that we don't have to repeat that
  either. Remem)HY(ber)YH(, this is how we used to build our )SM(hello)ES( out of
  source:)EP(

  ) 2 42 PR($ b hello/@hello-gcc/   config.cxx=g++
$ b hello/@hello-clang/ config.cxx=clang++)RP(

  )0 P(And now we can do:)EP(

  ) 13 53 PR($ b configure: hello/@hello-gcc/   config.cxx=g++
$ b configure: hello/@hello-clang/ config.cxx=clang++

$ hello-clang/
hello-clang/
\267-- build/
    |-- bootstrap/
    |   \267-- src-root.build
    \267-- config.build

$ b hello-gcc/
$ b hello-clang/
$ b hello-gcc/ hello-clang/)RP(

  )0 P(One major benefit of an in source build is the ability to run executa)HY(bles)YH(
  as well as examine build and test output \201test results, gener)HY(ated)YH( source
  code, docu)HY(men)HY(ta)HY(tion)YH(, etc\202 without leaving the source direc)HY(tory)YH(.
  Unfor)HY(tu)HY(nately)YH(, we cannot have multi)HY(ple)YH( in source builds and as was discussed
  earlier, mixing in and out of source builds is not recom)HY(mended)YH(.)EP(

  )0 P(To over)HY(come)YH( this limi)HY(ta)HY(tion)YH( )SM(build2)ES( has a notion of
  )I(forwarded config)HY(u)HY(ra)HY(tions)YH()ES(. As the name suggests, we can config)HY(ure)YH( a
  project's source direc)HY(tory)YH( to forward to one of its out of source builds.
  Once done, when)HY(ever)YH( we run the build system from the source direc)HY(tory)YH(, it
  will auto)HY(mat)HY(i)HY(cally)YH( build in the corre)HY(sponded)YH( forwarded output direc)HY(tory)YH(.
  Addi)HY(tion)HY(ally)YH(, it will )I(back)HY(link)YH()ES( \201using symlinks or another suit)HY(able)YH(
  mech)HY(a)HY(nism)YH(\202 certain "inter)HY(est)HY(ing)YH(" targets \201)SM(exe{})ES(,
  )SM(doc{})ES(\202 to the source direc)HY(tory)YH( for easy access. As an example,
  let's config)HY(ure)YH( our )SM(hello/)ES( source direc)HY(tory)YH( to forward to the
  )SM(hello-gcc/)ES( build:)EP(

  ) 7 54 PR($ b configure: hello/@hello-gcc/,forward

$ cd hello/  # Change to project root.
$ b
c++ hello/cxx{hello} -> ../hello-gcc/hello/obje{hello}
ld ../hello-gcc/hello/exe{hello}
ln ../hello-gcc/hello/exe{hello} -> hello/)RP(

  )0 P(Notice the last line in the above listing: it indi)HY(cates)YH( that
  )SM(exe{hello)ES(} from the out direc)HY(tory)YH( was back)HY(linked)YH( in our
  project's source subdi)HY(rec)HY(tory)YH(:)EP(

  ) 13 45 PR($ tree ./
./
|-- build/
|   |-- bootstrap/
|   |   \267-- out-root.build
|   \267-- ...
|-- hello/
|   |-- ...
|   \267-- hello -> ../../hello-gcc/hello/hello*
\267-- ...

$ ./hello/hello
Hello World!)RP(

  )BR(
  )0 P(By default only )SM(exe{})ES( and )SM(doc{})ES( targets are
  back)HY(linked)YH(. This, however, can be customized with the )SM(back)HY(link)YH()ES(
  target-specific vari)HY(able)YH(.)EP(
  )BR(

  )0 3 7 H(1.4.2)WB 218 Sn()WB 9 Sn( Testing)EH(

  )0 P(The next module we load in )SM(boot)HY(strap)YH(.build)ES( is )0 163 1 A()SM(test)ES()163 0 TN TL()Ec /AF f D( which defines the
  )SM(test)ES( oper)HY(a)HY(tion)YH(. As the name suggests, this module provides
  support for running tests.)EP(

  )0 P(There are two types of tests that we can run with the )SM(test)ES(
  module: simple and scripted.)EP(

  )0 P(A simple test is just an executable target with the )SM(test)ES(
  target-specific vari)HY(able)YH( set to )SM(true)ES(. For example:)EP(

  ) 1 23 PR(exe{hello}: test = true)RP(

  )0 P(A simple test is executed once and in its most basic form \201typical for
  unit testing\202 doesn't take any inputs nor produce any output, indi)HY(cat)HY(ing)YH(
  success via the zero exit status. If we test our )SM(hello)ES( project
  with the above addi)HY(tion)YH( to the )SM(build)HY(file)YH()ES(, then we will see the
  follow)HY(ing)YH( output:)EP(

  ) 3 21 PR($ b test
test hello/exe{hello}
Hello, World!)RP(

  )0 P(While the test passes \201since it exited with zero status\202, we prob)HY(a)HY(bly)YH(
  don't want to see that )SM(Hello, World!)ES( every time we run it \201this
  can, however, be quite useful when running exam)HY(ples)YH(\202. More impor)HY(tantly)YH(, we
  don't really test its func)HY(tion)HY(al)HY(ity)YH( and if tomor)HY(row)YH( our )SM(hello)ES(
  starts swear)HY(ing)YH( rather than greet)HY(ing)YH(, the test will still pass.)EP(

  )0 P(Besides check)HY(ing)YH( its exit status we can also supply some basic
  infor)HY(ma)HY(tion)YH( to a simple test \201more common for inte)HY(gra)HY(tion)YH( testing\202.
  Specif)HY(i)HY(cally)YH(, we can pass command line options \201)SM(test.options)ES(\202
  and argu)HY(ments)YH( \201)SM(test.argu)HY(ments)YH()ES(\202 as well as input
  \201)SM(test.stdin)ES(, used to supply test's )SM(stdin)ES(\202 and
  output \201)SM(test.stdout)ES(, used to compare to test's
  )SM(stdout)ES(\202.)EP(

  )0 P(Let's see how we can use this to fix our )SM(hello)ES( test by
  making sure our program prints the expected greet)HY(ing)YH(. First, we need to add
  a file that will contain the expected output, let's call it
  )SM(test.out)ES(:)EP(

  ) 7 20 PR($ ls -1 hello/
hello.cxx
test.out
buildfile

$ cat hello/test.out
Hello, World!)RP(

  )0 P(Next, we arrange for it to be compared to our test's )SM(stdout)ES(.
  Here is the new )SM(hello/build)HY(file)YH()ES(:)EP(

  ) 2 46 PR(exe{hello}: {hxx cxx}{**}
exe{hello}: file{test.out}: test.stdout = true)RP(

  )0 P(The last line looks new. What we have here is a )I(prereq)HY(ui)HY(site)YH(-specific
  vari)HY(able)YH()ES( assign)HY(ment)YH(. By setting )SM(test.stdout)ES( for the
  )SM(file{test.out})ES( prereq)HY(ui)HY(site)YH( of target )SM(exe{hello})ES(
  we mark it as expected )SM(stdout)ES( output of )I(this)ES( target
  \201theo)HY(ret)HY(i)HY(cally)YH(, we could have marked it as )SM(test.input)ES( for
  another target\202. Notice also that we no longer need the )SM(test)ES(
  target-specific vari)HY(able)YH(; it's unnec)HY(es)HY(sary)YH( if one of the other
  )SM(test.*)ES( vari)HY(ables)YH( is spec)HY(i)HY(fied)YH(.)EP(

  )0 P(Now, if we run our test, we won't see any output:)EP(

  ) 2 21 PR($ b test
test hello/exe{hello})RP(

  )0 P(And if we try to change the greet)HY(ing)YH( in )SM(hello.cxx)ES( but not in
  )SM(test.out)ES(, our test will fail print)HY(ing)YH( the )SM(diff\2011\202)ES(
  compar)HY(i)HY(son)YH( of the expected and actual output:)EP(

  ) 10 41 PR($ b test
c++ hello/cxx{hello} -> hello/obje{hello}
ld hello/exe{hello}
test hello/exe{hello}
--- test.out
+++ -
@@ -1 +1 @@
-Hello, World!
+Hi, World!
error: test hello/exe{hello} failed)RP(

  )0 P(Notice another inter)HY(est)HY(ing)YH( thing: we have modi)HY(fied)YH( )SM(hello.cxx)ES(
  to change the greet)HY(ing)YH( and our test executable was auto)HY(mat)HY(i)HY(cally)YH( rebuilt
  before testing. This happened because the )SM(test)ES( oper)HY(a)HY(tion)YH(
  performs )SM(update)ES( as its )I(pre-oper)HY(a)HY(tion)YH()ES( on all the targets
  to be tested.)EP(

  )0 P(Let's make our )SM(hello)ES( program more flex)HY(i)HY(ble)YH( by accept)HY(ing)YH( the
  name to greet on the command line:)EP(

  ) 12 56 PR(#include <iostream>

int main \201int argc, char* argv[]\202
{
  if \201argc < 2\202
  {
    std::cerr << "error: missing name" << std::endl;
    return 1;
  }

  std::cout << "Hello, " << argv[1] << '!' << std::endl;
})RP(

  )0 P(We can exer)HY(cise)YH( its success)HY(ful)YH( execu)HY(tion)YH( path with a simple test fairly
  easily:)EP(

  ) 2 46 PR(exe{hello}: test.arguments = 'World'
exe{hello}: file{test.out}: test.stdout = true)RP(

  )0 P(What if we also wanted to test its error handling? Since simple tests are
  single-run, this won't be easy. Even if we could over)HY(come)YH( this, having
  expected output for each test in a sepa)HY(rate)YH( file will quickly become untidy.
  And this is where script-based tests come in. Testscript is
  )SM(build2)ES('s portable language for running tests. It vaguely
  resem)HY(bles)YH( Bash and is opti)HY(mized)YH( for concise test imple)HY(men)HY(ta)HY(tion)YH( and fast,
  paral)HY(lel)YH( execu)HY(tion)YH(.)EP(

  )0 P(Just to give you an idea \201see )0 2 A(Testscript Intro)HY(duc)HY(tion)YH()EA( for
  a proper intro)HY(duc)HY(tion)YH(\202, here is what testing our )SM(hello)ES( program
  with Testscript would look like:)EP(

  ) 8 36 PR($ ls -1 hello/
hello.cxx
testscript
buildfile

$ cat hello/buildfile

exe{hello}: {hxx cxx}{**} testscript)RP(

  )0 P(And this is the contents of )SM(hello/testscript)ES(:)EP(

  ) 9 27 PR(: basics
:
$* 'World' >'Hello, World!'

: missing-name
:
$* 2>>EOE != 0
error: missing name
EOE)RP(

  )0 P(A couple of key points: The )SM(test.out)ES( file is gone with all
  the test inputs and expected outputs incor)HY(po)HY(rated)YH( into
  )SM(testscript)ES(. To test an executable with Testscript, all we have
  to do is list the corre)HY(spond)HY(ing)YH( )SM(testscript)ES( file as its
  prereq)HY(ui)HY(site)YH( \201and which, being a fixed name, doesn't need an explicit target
  type, similar to )SM(mani)HY(fest)YH()ES(\202.)EP(

  )0 P(To see Testscript in action, let's say we've made our program more
  forgiv)HY(ing)YH( by falling back to a default name if one wasn't spec)HY(i)HY(fied)YH(:)EP(

  ) 7 50 PR(#include <iostream>

int main \201int argc, char* argv[]\202
{
  const char* n \201argc > 1 ? argv[1] : "World"\202;
  std::cout << "Hello, " << n << '!' << std::endl;
})RP(

  )0 P(If we forget to adjust the )SM(missing-name)ES( test, then this is
  what we could expect to see when running the tests:)EP(

  ) 6 57 PR(b test
c++ hello/cxx{hello} -> hello/obje{hello}
ld hello/exe{hello}
test hello/exe{hello} + hello/testscript{testscript}
hello/testscript:7:1: error: hello/hello exit code 0 == 0
  info: stdout: hello/test-hello/missing-name/stdout)RP(

  )0 P(Testscript-based inte)HY(gra)HY(tion)YH( testing is the default setup for executable
  \201)SM(-t\240exe)ES(\202 projects created by )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(.
  Here is the recap of the overall layout:)EP(

  ) 9 18 PR(hello/
|-- build/
|   \267-- ...
|-- hello/
|   |-- hello.cxx
|   |-- testscript
|   \267-- buildfile
|-- buildfile
\267-- manifest)RP(

  )0 P(For libraries \201)SM(-t\240lib)ES(\202, however, the inte)HY(gra)HY(tion)YH(
  testing setup is a bit differ)HY(ent)YH(. Here are the rele)HY(vant)YH( parts of the
  layout:)EP(

  ) 19 27 PR(libhello/
|-- build/
|   \267-- ...
|-- libhello/
|   |-- hello.hxx
|   |-- hello.cxx
|   |-- export.hxx
|   |-- version.hxx.in
|   \267-- buildfile
|-- tests/
|   |-- build/
|   |   |-- bootstrap.build
|   |   \267-- root.build
|   |-- basics/
|   |   |-- driver.cxx
|   |   \267-- buildfile
|   \267-- buildfile
|-- buildfile
\267-- manifest)RP(

  )0 P(Specif)HY(i)HY(cally)YH(, there is no )SM(testscript)ES( in
  )SM(libhello/)ES(, the project's source subdi)HY(rec)HY(tory)YH(. Instead, we have
  the )SM(tests/)ES( subdi)HY(rec)HY(tory)YH( which itself looks like a project: it
  contains the )SM(build/)ES( subdi)HY(rec)HY(tory)YH( with all the famil)HY(iar)YH( files,
  etc. In fact, )SM(tests)ES( is a )I(subpro)HY(ject)YH()ES( of our
  )SM(libhello)ES( project.)EP(

  )0 P(While we will be exam)HY(in)HY(ing)YH( )SM(tests)ES( in greater detail later, in
  a nutshell, the reason it is a subpro)HY(ject)YH( is to be able to test an installed
  version of our library. By default, when )SM(tests)ES( is built as part
  of its parent project \201called )I(amal)HY(ga)HY(ma)HY(tion)YH()ES(\202, the locally built
  )SM(libhello)ES( library will be auto)HY(mat)HY(i)HY(cally)YH( imported. However, we
  can also config)HY(ure)YH( a build of )SM(tests)ES( out of its amal)HY(ga)HY(ma)HY(tion)YH(, in
  which case we can import an installed version of )SM(libhello)ES(. We
  will learn how to do all that as well as the under)HY(ly)HY(ing)YH( concepts
  \201)I(subpro)HY(ject)YH()ES(/)I(amal)HY(ga)HY(ma)HY(tion)YH()ES(, )I(import)ES(, etc\202 in the coming
  sections.)EP(

  )0 P(Inside )SM(tests/)ES( we have the )SM(basics/)ES( subdi)HY(rec)HY(tory)YH(
  which contains a simple test for our library's API. By default it doesn't
  use Testscript but if you want to, you can. You can also rename
  )SM(basics/)ES( to some)HY(thing)YH( more mean)HY(ing)HY(ful)YH( and add more tests next to
  it. For example, if we were creat)HY(ing)YH( an XML parsing and seri)HY(al)HY(iza)HY(tion)YH(
  library, then our )SM(tests/)ES( could have the follow)HY(ing)YH( layout:)EP(

  ) 8 15 PR(tests/
|-- build/
|   \267-- ...
|-- parser/
|   \267-- ...
|-- serializer/
|   \267-- ...
\267-- buildfile)RP(

  )BR(
  )0 P(Nothing prevents us from having the )SM(tests/)ES( subdi)HY(rec)HY(tory)YH( for
  executable projects. And it can be just a subdi)HY(rec)HY(tory)YH( or a subpro)HY(ject)YH(, the
  same as for libraries. Making it a subpro)HY(ject)YH( makes sense if your program
  has complex instal)HY(la)HY(tion)YH(, for example, if its execu)HY(tion)YH( requires
  config)HY(u)HY(ra)HY(tion)YH( and/or data files that need to be found, etc. For simple
  programs, however, testing the executable before installing it is usually
  suffi)HY(cient)YH(.)EP(

  )0 P(For a general discus)HY(sion)YH( of func)HY(tional)YH(/inte)HY(gra)HY(tion)YH( and unit testing refer
  to the )0 2 A(Tests)EA(
  section in the toolchain intro)HY(duc)HY(tion)YH(. For details on the unit test support
  imple)HY(men)HY(ta)HY(tion)YH( see )0 20 1 A(Imple)HY(ment)HY(ing)YH( Unit
  Testing)20 0 TN TL()Ec /AF f D(.)EP(
  )BR(

  )0 3 8 H(1.4.3)WB 219 Sn()WB 10 Sn( Installing)EH(

  )0 P(The )0 164 1 A()SM(install)ES()164 0 TN TL()Ec /AF f D( module defines the
  )SM(install)ES( and )SM(unin)HY(stall)YH()ES( oper)HY(a)HY(tions)YH(.  As the name
  suggests, this module provides support for project instal)HY(la)HY(tion)YH(.)EP(

  )BR(
  )0 P(Instal)HY(la)HY(tion)YH( in )SM(build2)ES( is modeled after UNIX-like oper)HY(a)HY(tion)YH(
  systems though the instal)HY(la)HY(tion)YH( direc)HY(tory)YH( layout is highly customiz)HY(able)YH(.
  While )SM(build2)ES( projects can import )SM(build2)ES( libraries
  directly, instal)HY(la)HY(tion)YH( is often a way to "export" them in a form usable by
  other build systems.)EP(
  )BR(

  )0 P(The root instal)HY(la)HY(tion)YH( direc)HY(tory)YH( is spec)HY(i)HY(fied)YH( with the
  )SM(config.install.root)ES( config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH(. Let's install our
  )SM(hello)ES( program into )SM(/tmp/install)ES(:)EP(

  ) 3 45 PR($ cd hello/  # Change to project root.

$ b install config.install.root=/tmp/install/)RP(

  )0 P(And see what we've got \201executa)HY(bles)YH( are marked with )SM(*)ES(\202:)EP(

  ) 9 24 PR($ tree /tmp/install/

/tmp/install/
|-- bin/
|   \267-- *hello
\267-- share/
    \267-- doc/
        \267-- hello/
            \267-- manifest)RP(

  )0 P(Similar to the )SM(test)ES( oper)HY(a)HY(tion)YH(, )SM(install)ES( performs
  )SM(update)ES( as a pre-oper)HY(a)HY(tion)YH( for targets that it installs.)EP(

  )BR(
  )0 P(We can also config)HY(ure)YH( our project with the desired
  )SM(config.install.*)ES( values so that we don't have to repeat them on
  every install/unin)HY(stall)YH(. For example:)EP(

  ) 3 47 PR($ b configure config.install.root=/tmp/install/
$ b install
$ b uninstall)RP(
  )BR(

  )0 P(Now let's try the same for )SM(libhello)ES( \201symbolic link targets
  are shown with )SM(->)ES( and actual static/shared library names may
  differ on your oper)HY(at)HY(ing)YH( system\202:)EP(

  ) 26 45 PR($ rm -r /tmp/install

$ cd libhello/  # Change to project root.

$ b install config.install.root=/tmp/install/

$ tree /tmp/install/

/tmp/install/
|-- include/
|   \267-- libhello/
|       |-- hello.hxx
|       |-- export.hxx
|       \267-- version.hxx
|-- lib/
|   |-- pkgconfig/
|   |   |-- libhello.pc
|   |   |-- libhello.shared.pc
|   |   \267-- libhello.static.pc
|   |-- libhello.a
|   |-- libhello.so -> libhello-0.1.so
|   \267-- libhello-0.1.so
\267-- share/
    \267-- doc/
        \267-- libhello/
            \267-- manifest)RP(

  )0 P(As you can see, the library headers go into the custom)HY(ary)YH(
  )SM(include/)ES( subdi)HY(rec)HY(tory)YH( while static and shared libraries \201and
  their )SM(pkg-config\2011\202)ES( files\202 \235 into )SM(lib/)ES(.
  Using this instal)HY(la)HY(tion)YH( we should be able to import this library from other
  build systems or even use it in a manual build:)EP(

  ) 1 65 PR($ g++ -I/tmp/install/include -L/tmp/install/lib greet.cxx -lhello)RP(

  )0 P(If we want to install into a system-wide loca)HY(tion)YH( like )SM(/usr)ES(
  or )SM(/usr/local)ES(, then we most likely will need to specify the
  )SM(sudo\2011\202)ES( program:)EP(

  ) 1 60 PR($ b config.install.root=/usr/local/ config.install.sudo=sudo)RP(

  )BR(
  )0 P(In )SM(build2)ES( only actual install/unin)HY(stall)YH( commands are
  executed with )SM(sudo\2011\202)ES(. And while on the topic of sensi)HY(ble)YH(
  imple)HY(men)HY(ta)HY(tions)YH(, )SM(unin)HY(stall)YH()ES( can be gener)HY(ally)YH( trusted to work
  reli)HY(ably)YH(.)EP(
  )BR(

  )0 P(The default instal)HY(la)HY(bil)HY(ity)YH( of a target as well as where it is installed
  is deter)HY(mined)YH( by its target type. For example, )SM(exe{})ES( is by
  default installed into )SM(bin/)ES(, )SM(doc{})ES( \235 into
  )SM(share/doc/<project>/)ES(, and )SM(file{})ES( is not
  installed.)EP(

  )0 P(We can, however, over)HY(ride)YH( these defaults with the )SM(install)ES(
  target-specific vari)HY(able)YH(.  Its value should be either special
  )SM(false)ES( indi)HY(cat)HY(ing)YH( that the target should not be installed or the
  direc)HY(tory)YH( to install the target to. As an example, here is what the root
  )SM(build)HY(file)YH()ES( from our )SM(libhello)ES( project looks
  like:)EP(

  ) 3 25 PR(./: {*/ -build/} manifest

tests/: install = false)RP(

  )0 P(The first line we have already seen and the purpose of the second line
  should now be clear: it makes sure we don't try to install anything in the
  )SM(tests/)ES( subdi)HY(rec)HY(tory)YH(.)EP(

  )0 P(If the value of the )SM(install)ES( vari)HY(able)YH( is not
  )SM(false)ES(, then it is normally a rela)HY(tive)YH( path with the first path
  compo)HY(nent)YH( being one of these names:)EP(

  ) 24 72 PR(name          default                        override
----          -------                        --------
root                                         config.install.root

data_root     root/                          config.install.data_root
exec_root     root/                          config.install.exec_root

bin           exec_root/bin/                 config.install.bin
sbin          exec_root/sbin/                config.install.sbin
lib           exec_root/lib/                 config.install.lib
libexec       exec_root/libexec/<project>/   config.install.libexec
pkgconfig     lib/pkgconfig/                 config.install.pkgconfig

etc           data_root/etc/                 config.install.etc
include       data_root/include/             config.install.include
include_arch  include/                       config.install.include_arch
share         data_root/share/               config.install.share
data          share/<project>/               config.install.data
buildfile     share/build2/export/<project>/ config.install.buildfile

doc           share/doc/<project>/           config.install.doc
legal         doc/                           config.install.legal
man           share/man/                     config.install.man
man<N>        man/man<N>/                    config.install.man<N>)RP(

  )0 P(Let's see what's going on here: The default install direc)HY(tory)YH( tree is
  derived from the )SM(config.install.root)ES( value but the loca)HY(tion)YH( of
  each node in this tree can be over)HY(rid)HY(den)YH( by the user that installs our
  project using the corre)HY(spond)HY(ing)YH( )SM(config.install.*)ES( vari)HY(ables)YH( \201see
  the )0 164 1 A()SM(install)ES()164 0 TN TL()Ec /AF f D( module docu)HY(men)HY(ta)HY(tion)YH(
  for details on their meaning\202. In our )SM(build)HY(files)YH()ES(, in turn, we
  use the node names instead of actual direc)HY(to)HY(ries)YH(. As an example, here is a
  )SM(build)HY(file)YH()ES( frag)HY(ment)YH( from the source subdi)HY(rec)HY(tory)YH( of our
  )SM(libhello)ES( project:)EP(

  ) 5 37 PR(hxx{*}:
{
  install         = include/libhello/
  install.subdirs = true
})RP(

  )0 P(Here we set the instal)HY(la)HY(tion)YH( loca)HY(tion)YH( for headers to be the
  )SM(libhello/)ES( subdi)HY(rec)HY(tory)YH( of the )SM(include)ES( instal)HY(la)HY(tion)YH(
  loca)HY(tion)YH(. Assum)HY(ing)YH( )SM(config.install.root)ES( is )SM(/usr/)ES(,
  the )SM(install)ES( module will perform the follow)HY(ing)YH( steps to resolve
  this rela)HY(tive)YH( path to the actual, abso)HY(lute)YH( instal)HY(la)HY(tion)YH( direc)HY(tory)YH(:)EP(

  ) 4 27 PR(include/libhello/
data_root/include/libhello/
root/include/libhello/
/usr/include/libhello/)RP(

  )0 P(In the above )SM(build)HY(file)YH()ES( frag)HY(ment)YH( we also see the use of the
  )SM(install.subdirs)ES( vari)HY(able)YH(. Setting it to )SM(true)ES(
  instructs the )SM(install)ES( module to recre)HY(ate)YH( subdi)HY(rec)HY(to)HY(ries)YH(
  start)HY(ing)YH( from this point in the project's direc)HY(tory)YH( hier)HY(ar)HY(chy)YH(. For example,
  if our )SM(libhello/)ES( source subdi)HY(rec)HY(tory)YH( had the
  )SM(details/)ES( subdi)HY(rec)HY(tory)YH( with the )SM(utility.hxx)ES( header,
  then this header would have been installed as
  )SM(.../include/libhello/details/utility.hxx)ES(.)EP(

  )BR(
  )0 P(By default the gener)HY(ated)YH( )SM(pkg-config)ES( files will contain
  )SM(install.include)ES( and )SM(install.lib)ES( direc)HY(to)HY(ries)YH( as
  header \201)SM(-I)ES(\202 and library \201)SM(-L)ES(\202 search paths,
  respec)HY(tively)YH(. However, these can be customized with the
  )SM({c,cxx}.pkgcon)HY(fig)YH(.{include,lib})ES( vari)HY(ables)YH(. For example,
  some)HY(times)YH( we may need to install headers into a subdi)HY(rec)HY(tory)YH( of the include
  direc)HY(tory)YH( but include them without this subdi)HY(rec)HY(tory)YH(:)EP(

  ) 10 60 PR(# Install headers into hello/libhello/ subdirectory of, say,
# /usr/include/ but include them as <libhello/*>.
#
hxx{*}:
{
  install         = include/hello/libhello/
  install.subdirs = true
}

lib{hello}: cxx.pkgconfig.include = include/hello/)RP(
  )BR(

  )0 3 9 H(1.4.4)WB 220 Sn()WB 11 Sn( Distribut)HY(ing)YH()EH(

  )0 P(The last module that we load in our )SM(boot)HY(strap)YH(.build)ES( is
  )SM(dist)ES( which provides support for the prepa)HY(ra)HY(tion)YH( of source
  distri)HY(bu)HY(tions)YH( and defines the )SM(dist)ES( meta-oper)HY(a)HY(tion)YH(. Similar to
  )SM(config)HY(ure)YH()ES(, )SM(dist)ES( is a meta-oper)HY(a)HY(tion)YH( rather than an
  oper)HY(a)HY(tion)YH( because, concep)HY(tu)HY(ally)YH(, we are prepar)HY(ing)YH( a distri)HY(bu)HY(tion)YH( for
  perform)HY(ing)YH( oper)HY(a)HY(tions)YH( \201like )SM(update)ES(, )SM(test)ES(\202 on
  targets rather than targets them)HY(selves)YH(.)EP(

  )0 P(The prepa)HY(ra)HY(tion)YH( of a correct distri)HY(bu)HY(tion)YH( requires that all the neces)HY(sary)YH(
  project files \201sources, docu)HY(men)HY(ta)HY(tion)YH(, etc\202 be listed as prereq)HY(ui)HY(sites)YH( in
  the project's )SM(build)HY(files)YH()ES(.)EP(

  )BR(
  )0 P(You may wonder why not just use the export support offered by many
  version control systems? The main reason is that in most real-world projects
  version control repos)HY(i)HY(to)HY(ries)YH( contain a lot more than what needs to be
  distributed. In fact, it is not uncom)HY(mon)YH( to host multi)HY(ple)YH( build system
  projects/pack)HY(ages)YH( in a single repos)HY(i)HY(tory)YH(. As a result, with this approach we
  seem to inevitably end up main)HY(tain)HY(ing)YH( an exclu)HY(sion)YH( list, which feels
  back)HY(wards)YH(: why specify all the things we don't want in a new list instead of
  making sure the already exist)HY(ing)YH( list of things that we do want is complete?
  Also, once we have the complete list, it can be put to good use by other
  tools, such as editors, IDEs, etc.)EP(
  )BR(

  )0 P(The prepa)HY(ra)HY(tion)YH( of a distri)HY(bu)HY(tion)YH( also requires an out of source build.
  This allows the )SM(dist)ES( module to distin)HY(guish)YH( between source and
  output targets. By default, targets found in src are included into the
  distri)HY(bu)HY(tion)YH( while those in out are excluded. However, we can customize this
  with the )SM(dist)ES( target-specific vari)HY(able)YH(.)EP(

  )0 P(As an example, let's prepare a distri)HY(bu)HY(tion)YH( of our )SM(hello)ES(
  project using the out of source build config)HY(ured)YH( in )SM(hello-out/)ES(.
  We use )SM(config.dist.root)ES( to specify the direc)HY(tory)YH( to write the
  distri)HY(bu)HY(tion)YH( to:)EP(

  ) 16 47 PR($ b dist: hello-out/ config.dist.root=/tmp/dist

$ ls -1 /tmp/dist
hello-0.1.0/

$ tree /tmp/dist/hello-0.1.0/
/tmp/dist/hello-0.1.0/
|-- build/
|   |-- bootstrap.build
|   \267-- root.build
|-- hello/
|   |-- hello.cxx
|   |-- testscript
|   \267-- buildfile
|-- buildfile
\267-- manifest)RP(

  )0 P(As we can see, the distri)HY(bu)HY(tion)YH( direc)HY(tory)YH( includes the project version
  \201from the )SM(version)ES( vari)HY(able)YH( which, in our case, is extracted
  from )SM(mani)HY(fest)YH()ES( by the )SM(version)ES( module\202. Inside the
  distri)HY(bu)HY(tion)YH( direc)HY(tory)YH( we have our project's source files \201but, for example,
  without any )SM(.gitig)HY(nore)YH()ES( files that we may have had in
  )SM(hello/)ES(\202.)EP(

  )0 P(We can also ask the )SM(dist)ES( module to package the distri)HY(bu)HY(tion)YH(
  direc)HY(tory)YH( into one or more archives and gener)HY(ate)YH( their check)HY(sum)YH( files for
  us. For example:)EP(

  ) 11 37 PR($ b dist: hello-out/ \200
  config.dist.root=/tmp/dist \200
  config.dist.archives="tar.gz zip" \200
  config.dist.checksums=sha256

$ ls -1 /tmp/dist
hello-0.1.0/
hello-0.1.0.tar.gz
hello-0.1.0.tar.gz.sha256
hello-0.1.0.zip
hello-0.1.0.zip.sha256)RP(

  )BR(
  )0 P(We can also config)HY(ure)YH( our project with the desired
  )SM(config.dist.*)ES( values so we don't have to repeat them every
  time. For example:)EP(

  ) 2 56 PR($ b configure: hello-out/ config.dist.root=/tmp/dist ...
$ b dist)RP(
  )BR(

  )0 P(Let's now take a look at an example of customiz)HY(ing)YH( what gets distributed.
  Most of the time you will be using this mech)HY(a)HY(nism)YH( to include certain targets
  from out. Here is a frag)HY(ment)YH( from the )SM(libhello)ES( source
  subdi)HY(rec)HY(tory)YH( )SM(build)HY(file)YH()ES(:)EP(

  ) 1 44 PR(hxx{version}: in{version} $src_root/manifest)RP(

  )0 P(Our library provides the )SM(version.hxx)ES( header that the users
  can include to obtain its version. This header is gener)HY(ated)YH( by the
  )SM(version)ES( module from the )SM(version.hxx.in)ES( template.
  In essence, the )SM(version)ES( module takes the version value from our
  )SM(mani)HY(fest)YH()ES(, splits it into various compo)HY(nents)YH( \201major, minor,
  patch, etc\202 and then prepro)HY(cesses)YH( the )SM(in{})ES( file substi)HY(tut)HY(ing)YH(
  these values \201see the )0 167 1 A()SM(version)ES()167 0 TN TL()Ec /AF f D(
  module docu)HY(men)HY(ta)HY(tion)YH( for details\202. The end result is an auto)HY(mat)HY(i)HY(cally)YH(
  main)HY(tained)YH( version header.)EP(

  )0 P(Usually there is no need to include this header into the distri)HY(bu)HY(tion)YH(
  since it will be auto)HY(mat)HY(i)HY(cally)YH( gener)HY(ated)YH( if and when neces)HY(sary)YH(. However, we
  can if we need to. For example, we could be porting an exist)HY(ing)YH( project and
  its users could be expect)HY(ing)YH( the version header to be shipped as part of the
  archive. Here is how we can achieve this:)EP(

  ) 5 44 PR(hxx{version}: in{version} $src_root/manifest
{
  dist = true
  clean = \201$src_root != $out_root\202
})RP(

  )0 P(Because this header is an output target, we have to explic)HY(itly)YH( request
  its distri)HY(bu)HY(tion)YH( with )SM(dist=true)ES(. Notice that we have also
  disabled its clean)HY(ing)YH( for the in source build so that the )SM(clean)ES(
  oper)HY(a)HY(tion)YH( results in a state iden)HY(ti)HY(cal)YH( to distributed.)EP(

  )0 2 10 H(1.5)WB 221 Sn()WB 12 Sn( Target Impor)HY(ta)HY(tion)YH()EH(

  )0 P(Recall that if we need to depend on a target defined in another
  )SM(build)HY(file)YH()ES( within our project, then we simply include the said
  )SM(build)HY(file)YH()ES( and refer)HY(ence)YH( the target. For example, if our
  )SM(hello)ES( included both an executable and a library in sepa)HY(rate)YH(
  subdi)HY(rec)HY(to)HY(ries)YH( next to each other:)EP(

  ) 9 17 PR(hello/
|-- build/
|   \267-- ...
|-- hello/
|   |-- ...
|   \267-- buildfile
\267-- libhello/
    |-- ...
    \267-- buildfile)RP(

  )0 P(Then our executable )SM(build)HY(file)YH()ES( could look like this:)EP(

  ) 3 48 PR(include ../libhello/ # Include lib{hello}.

exe{hello}: {hxx cxx}{**} ../libhello/lib{hello})RP(

  )0 P(What if instead )SM(libhello)ES( were a sepa)HY(rate)YH( project? The
  inclu)HY(sion)YH( approach would no longer work for two reasons: we don't know the
  path to )SM(libhello)ES( \201after all, it's an inde)HY(pen)HY(dent)YH( project and
  can reside anywhere\202 and we can't assume the path to the
  )SM(lib{hello})ES( target within )SM(libhello)ES( \201the project
  direc)HY(tory)YH( layout can change\202.)EP(

  )0 P(To depend on a target from a sepa)HY(rate)YH( project we use )I(impor)HY(ta)HY(tion)YH()ES(
  instead of inclu)HY(sion)YH(. This mech)HY(a)HY(nism)YH( is also used to depend on targets that
  are not part of any project, for example, installed libraries.)EP(

  )0 P(The import)HY(ing)YH( project's side is pretty simple. This is what the above
  )SM(build)HY(file)YH()ES( will look like if )SM(libhello)ES( were a
  sepa)HY(rate)YH( project:)EP(

  ) 3 33 PR(import libs = libhello%lib{hello}

exe{hello}: {hxx cxx}{**} $libs)RP(

  )0 P(The )SM(import)ES( direc)HY(tive)YH( is a kind of vari)HY(able)YH( assign)HY(ment)YH( that
  resolves a )I(project-qual)HY(i)HY(fied)YH()ES( rela)HY(tive)YH( target
  \201)SM(libhello%lib{hello})ES(\202 to an unqual)HY(i)HY(fied)YH( abso)HY(lute)YH( target and
  stores it in the vari)HY(able)YH( \201)SM(libs)ES( in our case\202. We can then
  expand the vari)HY(able)YH( \201)SM($libs)ES(\202, normally in the depen)HY(dency)YH(
  decla)HY(ra)HY(tion)YH(, to get the imported target.)EP(

  )0 P(If we needed to import several libraries, then we simply repeat the
  )SM(import)ES( direc)HY(tive)YH(, usually accu)HY(mu)HY(lat)HY(ing)YH( the result in the same
  vari)HY(able)YH(, for example:)EP(

  ) 5 36 PR(import libs  = libformat%lib{format}
import libs += libprint%lib{print}
import libs += libhello%lib{hello}

exe{hello}: {hxx cxx}{**} $libs)RP(

  )0 P(Let's now try to build our )SM(hello)ES( project that uses imported
  )SM(libhello)ES(:)EP(

  ) 4 67 PR($ b hello/
error: unable to import target libhello%lib{hello}
  info: use config.import.libhello command line variable to specify
        its project out_root)RP(

  )0 P(While that didn't work out well, it does make sense: the build system
  cannot know the loca)HY(tion)YH( of )SM(libhello)ES( or which of its builds we
  want to use. Though it does help)HY(fully)YH( suggest that we use
  )SM(config.import.libhello)ES( to specify its out direc)HY(tory)YH(
  \201)SM(out_root)ES(\202. Let's point it to )SM(libhello)ES( source
  direc)HY(tory)YH( to use its in source build
  \201)SM(out_root\240==\240src_root)ES(\202:)EP(

  ) 5 65 PR($ b hello/ config.import.libhello=libhello/
c++ libhello/libhello/cxx{hello} -> libhello/libhello/objs{hello}
ld libhello/libhello/libs{hello}
c++ hello/hello/cxx{hello} -> hello/hello/obje{hello}
ld hello/hello/exe{hello})RP(

  )0 P(And it works. Natu)HY(rally)YH(, the impor)HY(ta)HY(tion)YH( mech)HY(a)HY(nism)YH( works the same for out
  of source builds and we can persist the )SM(config.import.*)ES(
  vari)HY(ables)YH( in the project's config)HY(u)HY(ra)HY(tion)YH(. As an example, let's config)HY(ure)YH(
  Clang builds of the two projects out of source:)EP(

  ) 9 71 PR($ b configure: libhello/@libhello-clang/ config.cxx=clang++
$ b configure: hello/@hello-clang/ config.cxx=clang++ \200
  config.import.libhello=libhello-clang/

$ b hello-clang/
c++ libhello/libhello/cxx{hello} -> libhello-clang/libhello/objs{hello}
ld libhello-clang/libhello/libs{hello}
c++ hello/hello/cxx{hello} -> hello-clang/hello/obje{hello}
ld hello-clang/hello/exe{hello})RP(

  )0 P(If the corre)HY(spond)HY(ing)YH( )SM(config.import.*)ES( vari)HY(able)YH( is not
  spec)HY(i)HY(fied)YH(, )SM(import)ES( searches for a project in a couple of other
  places. First, it looks in the list of subpro)HY(jects)YH( start)HY(ing)YH( from the
  import)HY(ing)YH( project itself and then contin)HY(u)HY(ing)YH( with its outer amal)HY(ga)HY(ma)HY(tions)YH(
  and their subpro)HY(jects)YH( \201see )0 14 1 A(Subpro)HY(jects)YH( and
  Amal)HY(ga)HY(ma)HY(tions)YH()14 0 TN TL()Ec /AF f D( for details on this subject\202.)EP(

  )BR(
  )0 P(We've actu)HY(ally)YH( seen an example of this search step in action: the
  )SM(tests)ES( subpro)HY(ject)YH( in )SM(libhello)ES(. The test imports
  )SM(libhello)ES( which is auto)HY(mat)HY(i)HY(cally)YH( found as an amal)HY(ga)HY(ma)HY(tion)YH(
  contain)HY(ing)YH( this subpro)HY(ject)YH(.)EP(
  )BR(

  )BR(
  )0 P(To skip search)HY(ing)YH( in subpro)HY(jects)YH(/amal)HY(ga)HY(ma)HY(tions)YH( and proceed directly to
  the rule-specific search \201described below\202, specify the
  )SM(config.import.*)ES( vari)HY(able)YH( with an empty value. For example:)EP(

  ) 1 42 PR($ b configure: ... config.import.libhello=)RP(
  )BR(

  )0 P(If the project being imported cannot be located using any of these
  methods, then )SM(import)ES( falls back to the rule-specific search.
  That is, a rule that matches the target may provide support for import)HY(ing)YH(
  certain target types based on rule-specific knowl)HY(edge)YH(. Support for import)HY(ing)YH(
  installed libraries by the C++ link rule is a good example of this.
  Inter)HY(nally)YH(, the )SM(cxx)ES( module extracts the compiler's library
  search paths \201that is, paths that would be used to resolve
  )SM(-lfoo)ES(\202 and then the link rule uses them to search for installed
  libraries. This allows us to use the same )SM(import)ES( direc)HY(tive)YH(
  regard)HY(less)YH( of whether we import a library from a sepa)HY(rate)YH( build, from a
  subpro)HY(ject)YH(, or from an instal)HY(la)HY(tion)YH( direc)HY(tory)YH(.)EP(

  )BR(
  )0 P(Impor)HY(ta)HY(tion)YH( of an installed library will work even if it is not a
  )SM(build2)ES( project. Besides finding the library itself, the link
  rule will also try to locate its )SM(pkg-config\2011\202)ES( file and, if
  present, extract addi)HY(tional)YH( compile/link flags from it \201see )0 182 1 A(Impor)HY(ta)HY(tion)YH( of Installed Libraries)182 0 TN TL()Ec /AF f D( for
  details\202. The link rule also auto)HY(mat)HY(i)HY(cally)YH( produces
  )SM(pkg-config\2011\202)ES( files for libraries that it installs.)EP(
  )BR(

  )BR(
  )0 P(A common problem with import)HY(ing)YH( and using third-party C/C++ libraries is
  compiler warn)HY(ings)YH(. Specif)HY(i)HY(cally)YH(, we are likely to include their headers into
  our project's source files which means we may see warn)HY(ings)YH( in such headers
  \201which we cannot always fix\202 mixed with warn)HY(ings)YH( in our code \201which we
  should normally be able to fix\202. See )0 180 1 A(Compi)HY(la)HY(tion)YH( Inter)HY(nal)YH( Scope)180 0 TN TL()Ec /AF f D( for a mech)HY(a)HY(nism)YH( to
  deal with this problem.)EP(
  )BR(

  )0 P(Let's now examine the export)HY(ing)YH( side of the impor)HY(ta)HY(tion)YH( mech)HY(a)HY(nism)YH(. While
  a project doesn't need to do anything special to be found by
  )SM(import)ES(, it does need to handle locat)HY(ing)YH( the exported target \201or
  targets; there could be several\202 within the project as well as loading their
  )SM(build)HY(files)YH()ES(. And this is the job of an )I(export stub)ES(, the
  )SM(build/export.build)ES( file that you might have noticed in the
  )SM(libhello)ES( project:)EP(

  ) 4 20 PR(libhello
|-- build/
|   \267-- export.build
\267-- ...)RP(

  )0 P(Let's take a look inside:)EP(

  ) 6 40 PR($out_root/
{
  include libhello/
}

export $out_root/libhello/$import.target)RP(

  )0 P(An export stub is a special kind of )SM(build)HY(file)YH()ES( that bridges
  from the import)HY(ing)YH( project into export)HY(ing)YH(. It is loaded in a special
  tempo)HY(rary)YH( scope outside of any project, in a "no man's land" so to speak.
  The only vari)HY(ables)YH( set on the tempo)HY(rary)YH( scope are )SM(src_root)ES( and
  )SM(out_root)ES( of the project being imported as well as
  )SM(import.target)ES( contain)HY(ing)YH( the name of the target being imported
  \201without project qual)HY(i)HY(fi)HY(ca)HY(tion)YH(; that is, )SM(lib{hello})ES( in our
  example\202.)EP(

  )0 P(Typi)HY(cally)YH(, an export stub will open the scope of the export)HY(ing)YH( project,
  load the )SM(build)HY(file)YH()ES( that defines the target being exported and
  finally "return" the abso)HY(lute)YH( target name to the import)HY(ing)YH( project using the
  )SM(export)ES( direc)HY(tive)YH(. And this is exactly what the export stub in
  our )SM(libhello)ES( does.)EP(

  )0 P(We now have all the pieces of the impor)HY(ta)HY(tion)YH( puzzle in place and you can
  prob)HY(a)HY(bly)YH( see how they all fit together. To summa)HY(rize)YH(, when the build system
  sees the )SM(import)ES( direc)HY(tive)YH(, it looks for a project with the
  spec)HY(i)HY(fied)YH( name. If found, it creates a tempo)HY(rary)YH( scope, sets the
  )SM(src/out_root)ES( vari)HY(ables)YH( to point to the project and
  )SM(import.target)ES( \235 to the target name spec)HY(i)HY(fied)YH( in the
  )SM(import)ES( direc)HY(tive)YH(. And then it load the project's export stub in
  this scope. Inside the export stub we switch to the project's root scope,
  load its )SM(build)HY(file)YH()ES( and then use the )SM(export)ES(
  direc)HY(tive)YH( to return the exported target. Once the export stub is processed,
  the build system obtains the exported target and assigns it to the vari)HY(able)YH(
  spec)HY(i)HY(fied)YH( in the )SM(import)ES( direc)HY(tive)YH(.)EP(

  )BR(
  )0 P(Our export stub is quite "loose" in that it allows import)HY(ing)YH( any target
  defined in the project's source subdi)HY(rec)HY(tory)YH( )SM(build)HY(file)YH()ES(. While
  we found it to be a good balance between strict)HY(ness)YH( and flex)HY(i)HY(bil)HY(ity)YH(, if you
  would like to "tighten" your export stubs, you can. For example:)EP(

  ) 2 42 PR(if \201$import.target == lib{hello}\202
  export $out_root/libhello/$import.target)RP(

  )0 P(If no )SM(export)ES( direc)HY(tive)YH( is executed in an export stub then
  the build system assumes that the target is not exported by the project and
  issues appro)HY(pri)HY(ate)YH( diag)HY(nos)HY(tics)YH(.)EP(
  )BR(

  )0 P(Let's revisit the executable )SM(build)HY(file)YH()ES( with which we started
  this section. Recall that it is for an executable that depends on a library
  which resides in the same project:)EP(

  ) 3 48 PR(include ../libhello/ # Include lib{hello}.

exe{hello}: {hxx cxx}{**} ../libhello/lib{hello})RP(

  )0 P(If )SM(lib{hello})ES( is exported by this project, then instead of
  manu)HY(ally)YH( includ)HY(ing)YH( its )SM(build)HY(file)YH()ES( we can use )I(project-local
  impor)HY(ta)HY(tion)YH()ES(:)EP(

  ) 3 30 PR(import lib = lib{hello}

exe{hello}: {hxx cxx}{**} $lib)RP(

  )0 P(The main advan)HY(tage)YH( of project-local impor)HY(ta)HY(tion)YH( over inclu)HY(sion)YH( is the
  ability to move things around without having to adjust loca)HY(tions)YH( in multi)HY(ple)YH(
  places \201the only place we need to do it is the export stub\202. This advan)HY(tage)YH(
  becomes notice)HY(able)YH( in more complex projects with a large number of
  compo)HY(nents)YH(.)EP(

  )BR(
  )0 P(An import is project-local if the target being imported has no project
  name. Note that the target must still be exported in the project's export
  stub. In other words, project-local impor)HY(ta)HY(tion)YH( use the same mech)HY(a)HY(nism)YH( as
  the normal import.)EP(
  )BR(

  )0 P(Another special type of impor)HY(ta)HY(tion)YH( is )I(ad hoc impor)HY(ta)HY(tion)YH()ES(. It is
  trig)HY(gered)YH( if the target being imported has no project name and is either
  abso)HY(lute)YH( or is a rela)HY(tive)YH( direc)HY(tory)YH( \201in which case it is inter)HY(preted)YH( as
  rela)HY(tive)YH( to the import)HY(ing)YH( scope\202. Seman)HY(ti)HY(cally)YH( this is similar a normal
  import but with the loca)HY(tion)YH( of the project being imported hard-coded into
  the )SM(build)HY(file)YH()ES(. While this would be a bad idea in most case,
  some)HY(times)YH( we may want to create a special )I(glue )SM(build)HY(file)YH()ES()ES(
  that "pulls" together several projects, usually for conve)HY(nience)YH( of
  devel)HY(op)HY(ment)YH(.)EP(

  )0 P(One typical case that calls for such a glue )SM(build)HY(file)YH()ES( is a
  multi-package project. For example, we may have a )SM(hello)ES( project
  \201in a more general sense, as in a version control repos)HY(i)HY(tory)YH(\202 that contains
  the )SM(libhello)ES( library and )SM(hello)ES( executable pack)HY(ages)YH(
  \201which are inde)HY(pen)HY(dent)YH( build system projects\202:)EP(

  ) 16 17 PR(hello/
|-- .git/
|-- hello/
|   |-- build/
|   |   \267-- ...
|   |-- hello/
|   |   \267-- ...
|   |-- buildfile
|   \267-- manifest
\267-- libhello/
    |-- build/
    |   \267-- ...
    |-- libhello/
    |   \267-- ...
    |-- buildfile
    \267-- manifest)RP(

  )0 P(Notice that the root of this repos)HY(i)HY(tory)YH( is not a build system project and
  we cannot, for example, just run the build system driver without any
  argu)HY(ments)YH( to update all the pack)HY(ages)YH(. Instead we have to list them
  explic)HY(itly)YH(:)EP(

  ) 1 20 PR($ b hello/ libhello/)RP(

  )0 P(And that's incon)HY(ve)HY(nient)YH(. To over)HY(come)YH( this short)HY(com)HY(ing)YH( we can turn the
  repos)HY(i)HY(tory)YH( root into a simple build system project by adding a glue
  )SM(build)HY(file)YH()ES( that imports \201using ad hoc impor)HY(ta)HY(tion)YH(\202 and builds
  all the pack)HY(ages)YH(:)EP(

  ) 3 16 PR(import pkgs = */

./: $pkgs)RP(

  )BR(
  )0 P(Unlike other import types, ad hoc impor)HY(ta)HY(tion)YH( does not rely \201or require\202
  an export stub. Instead, it directly loads a )SM(build)HY(file)YH()ES( that
  could plau)HY(si)HY(bly)YH( declare the target being imported.)EP(

  )0 P(In the unlikely event of a project-local impor)HY(ta)HY(tion)YH( of a direc)HY(tory)YH(
  target, it will have to be spelled with an explicit )SM(dir{})ES(
  target type, for example:)EP(

  ) 1 22 PR(import d = dir{tests/})RP(
  )BR(

  )0 2 11 H(1.6)WB 222 Sn()WB 13 Sn( Library Expor)HY(ta)HY(tion)YH( and Version)HY(ing)YH()EH(

  )0 P(By now we have exam)HY(ined)YH( and explained every line of every
  )SM(build)HY(file)YH()ES( in our )SM(hello)ES( executable project. There
  are, however, still a few lines to be covered in the source subdi)HY(rec)HY(tory)YH(
  )SM(build)HY(file)YH()ES( in )SM(libhello)ES(. Here it is in its
  entirety:)EP(

  ) 43 68 PR(intf_libs = # Interface dependencies.
impl_libs = # Implementation dependencies.

lib{hello}: {hxx ixx txx cxx}{** -version} hxx{version} \200
  $impl_libs $intf_libs

hxx{version}: in{version} $src_root/manifest

# Build options.
#
cxx.poptions =+ "-I$out_root" "-I$src_root"

obja{*}: cxx.poptions += -DLIBHELLO_STATIC_BUILD
objs{*}: cxx.poptions += -DLIBHELLO_SHARED_BUILD

# Export options.
#
lib{hello}:
{
  cxx.export.poptions = "-I$out_root" "-I$src_root"
  cxx.export.libs = $intf_libs
}

liba{hello}: cxx.export.poptions += -DLIBHELLO_STATIC
libs{hello}: cxx.export.poptions += -DLIBHELLO_SHARED

# For pre-releases use the complete version to make sure they cannot
# be used in place of another pre-release or the final version. See
# the version module for details on the version.* variable values.
#
if $version.pre_release)WR(
  lib{hello}: bin.lib.version = "-$version.project_id"
else
  lib{hello}: bin.lib.version = "-$version.major.$version.minor"

# Install into the libhello/ subdirectory of, say, /usr/include/
# recreating subdirectories.
#
{hxx ixx txx}{*}:
{
  install         = include/libhello/
  install.subdirs = true
})RP(

  )0 P(Let's start with all those )SM(cxx.export.*)ES( vari)HY(ables)YH(. It turns
  out that merely export)HY(ing)YH( a library target is not enough for the importers
  of the library to be able to use it. They also need to know where to find
  its headers, which other libraries to link, etc. This infor)HY(ma)HY(tion)YH( is carried
  in a set of target-specific )SM(cxx.export.*)ES( vari)HY(ables)YH( that
  paral)HY(lel)YH( the )SM(cxx.*)ES( set and that together with the library's
  prereq)HY(ui)HY(sites)YH( consti)HY(tute)YH( the )I(library meta)HY(data)YH( proto)HY(col)YH()ES(. Every time a
  source file that depends on a library is compiled or a binary is linked,
  this infor)HY(ma)HY(tion)YH( is auto)HY(mat)HY(i)HY(cally)YH( extracted by the compile and link rules
  from the library depen)HY(dency)YH( chain, recur)HY(sively)YH(. And when the library is
  installed, this infor)HY(ma)HY(tion)YH( is carried over to its
  )SM(pkg-config\2011\202)ES( file.)EP(

  )BR(
  )0 P(Similar to the )SM(c.*)ES( and )SM(cc.*)ES( sets discussed
  earlier, there are also )SM(c.export.*)ES( and )SM(cc.export.*)ES(
  sets.)EP(

  )0 P(Note, however, that there is no )SM(*.export.coptions)ES( since a
  library impos)HY(ing)YH( compi)HY(la)HY(tion)YH( options on its consumers is bad prac)HY(tice)YH( \201too
  coarse-grained, does not compose, etc\202. Instead, the recom)HY(mended)YH( approach is
  to specify in the library docu)HY(men)HY(ta)HY(tion)YH( that it expects its consumers to use
  a certain compi)HY(la)HY(tion)YH( option. And if your library is unus)HY(able)YH( without
  export)HY(ing)YH( a compi)HY(la)HY(tion)YH( option and you are sure bene)HY(fits)YH( outweigh the
  draw)HY(backs)YH(, then you can specify it as part of )SM(*.export.poptions)ES(
  \201it is still a good idea to promi)HY(nently)YH( docu)HY(ment)YH( this\202.)EP(
  )BR(

  )0 P(Here are the parts rele)HY(vant)YH( to the library meta)HY(data)YH( proto)HY(col)YH( in the above
  )SM(build)HY(file)YH()ES(:)EP(

  ) 13 53 PR(intf_libs = # Interface dependencies.
impl_libs = # Implementation dependencies.

lib{hello}: ... $impl_libs $intf_libs

lib{hello}:
{
  cxx.export.poptions = "-I$out_root" "-I$src_root"
  cxx.export.libs = $intf_libs
}

liba{hello}: cxx.export.poptions += -DLIBHELLO_STATIC
libs{hello}: cxx.export.poptions += -DLIBHELLO_SHARED)RP(

  )0 P(As a first step we clas)HY(sify)YH( all our library depen)HY(den)HY(cies)YH( into
  )I(inter)HY(face)YH( depen)HY(den)HY(cies)YH()ES( and )I(imple)HY(men)HY(ta)HY(tion)YH( depen)HY(den)HY(cies)YH()ES(. A
  library is an inter)HY(face)YH( depen)HY(dency)YH( if it is refer)HY(enced)YH( from our inter)HY(face)YH(,
  for example, by includ)HY(ing)YH( \201import)HY(ing)YH(\202 one of its headers \201modules\202 from one
  of our \201public\202 headers \201modules\202 or if one of its func)HY(tions)YH( is called from
  our inline or template func)HY(tions)YH(. Other)HY(wise)YH(, it is an imple)HY(men)HY(ta)HY(tion)YH(
  depen)HY(dency)YH(.)EP(

  )0 P(To illus)HY(trate)YH( the distinc)HY(tion)YH( between inter)HY(face)YH( and imple)HY(men)HY(ta)HY(tion)YH(
  depen)HY(den)HY(cies)YH(, let's say we've reim)HY(ple)HY(mented)YH( our )SM(libhello)ES( to use
  )SM(libfor)HY(mat)YH()ES( to format the greet)HY(ing)YH( and )SM(libprint)ES( to
  print it.  Here is our new header \201)SM(hello.hxx)ES(\202:)EP(

  ) 13 66 PR(#include <libformat/format.hxx>

namespace hello
{
  void
  say_hello_formatted \201std::ostream&, const std::string& hello\202;

  inline void
  say_hello \201std::ostream& o, const std::string& name\202
  {
    say_hello_formatted \201o, format::format_hello \201"Hello", name\202\202;
  }
})RP(

  )0 P(And this is the new source file \201)SM(hello.cxx)ES(\202:)EP(

  ) 10 51 PR(#include <libprint/print.hxx>

namespace hello
{
  void
  say_hello_formatted \201ostream& o, const string& h\202
  {
    print::print_hello \201o, h\202;
  }
})RP(

  )0 P(In this case, )SM(libfor)HY(mat)YH()ES( is our inter)HY(face)YH( depen)HY(dency)YH( since we
  both include its header in our inter)HY(face)YH( and call it from one of our inline
  func)HY(tions)YH(. In contrast, )SM(libprint)ES( is only included and used in
  the source file and so we can safely treat it as an imple)HY(men)HY(ta)HY(tion)YH(
  depen)HY(dency)YH(. The corre)HY(spond)HY(ing)YH( )SM(import)ES( direc)HY(tives)YH( in our
  )SM(build)HY(file)YH()ES( will there)HY(fore)YH( look like this:)EP(

  ) 2 40 PR(import intf_libs = libformat%lib{format}
import impl_libs = libprint%lib{print})RP(

  )0 P(The prepro)HY(ces)HY(sor)YH( options \201)SM(poptions)ES(\202 of an inter)HY(face)YH(
  depen)HY(dency)YH( must be made avail)HY(able)YH( to our library's users. The library itself
  should also be explic)HY(itly)YH( linked when)HY(ever)YH( our library is linked. All this is
  achieved by listing the inter)HY(face)YH( depen)HY(den)HY(cies)YH( in the
  )SM(cxx.export.libs)ES( vari)HY(able)YH(:)EP(

  ) 4 30 PR(lib{hello}:
{
  cxx.export.libs = $intf_libs
})RP(

  )BR(
  )0 P(More precisely, the inter)HY(face)YH( depen)HY(dency)YH( should be explic)HY(itly)YH( linked if a
  user of our library may end up with a direct call to the depen)HY(dency)YH( in one
  of their object files. Not linking such a library is called
  )I(under)HY(link)HY(ing)YH()ES( while linking a library unnec)HY(es)HY(sar)HY(ily)YH( \201which can happen
  because we've included its header but are not actu)HY(ally)YH( calling any of its
  non-inline/template func)HY(tions)YH(\202 is called )I(over)HY(link)HY(ing)YH()ES(. Under)HY(link)HY(ing)YH( is
  an error on some plat)HY(forms)YH( while over)HY(link)HY(ing)YH( may slow down the process
  startup and/or waste its memory.)EP(

  )0 P(Note also that this only applies to shared libraries. In case of static
  libraries, both inter)HY(face)YH( and imple)HY(men)HY(ta)HY(tion)YH( depen)HY(den)HY(cies)YH( are always linked,
  recur)HY(sively)YH(. Specif)HY(i)HY(cally)YH(, when linking a shared library, only libraries
  spec)HY(i)HY(fied)YH( in its )SM(*.export.libs)ES( are linked. While when linking a
  static library, all its library prereq)HY(ui)HY(sites)YH( as well as those spec)HY(i)HY(fied)YH( in
  )SM(*.libs)ES( are linked. Note that )SM(*.export.libs)ES( is not
  used when linking a static library since it is natu)HY(rally)YH( assumed that all
  such libraries are also spec)HY(i)HY(fied)YH( as library prereq)HY(ui)HY(sites)YH( or in
  )SM(*.libs)ES(.)EP(
  )BR(

  )0 P(The remain)HY(ing)YH( lines in the library meta)HY(data)YH( frag)HY(ment)YH( are:)EP(

  ) 7 53 PR(lib{hello}:
{
  cxx.export.poptions = "-I$out_root" "-I$src_root"
}

liba{hello}: cxx.export.poptions += -DLIBHELLO_STATIC
libs{hello}: cxx.export.poptions += -DLIBHELLO_SHARED)RP(

  )0 P(The first line makes sure the users of our library can locate its headers
  by export)HY(ing)YH( the rele)HY(vant)YH( )SM(-I)ES( options. The last two lines define
  the library type macros that are relied upon by the )SM(export.hxx)ES(
  header to prop)HY(erly)YH( setup symbol export)HY(ing)YH(.)EP(

  )BR(
  )0 P(The )SM(liba{})ES( and )SM(libs{})ES( target types corre)HY(spond)YH(
  to the static and shared libraries, respec)HY(tively)YH(. And )SM(lib{})ES( is
  actu)HY(ally)YH( a target group that can contain one, the other, or both as its
  members.)EP(

  )0 P(Specif)HY(i)HY(cally)YH(, when we build a )SM(lib{})ES( target, which members
  will be built is deter)HY(mined)YH( by the )SM(config.bin.lib)ES( vari)HY(able)YH( with
  the )SM(static)ES(, )SM(shared)ES(, and )SM(both)ES(
  \201default\202 possi)HY(ble)YH( values. So to only build a shared library we can run:)EP(

  ) 1 25 PR($ b config.bin.lib=shared)RP(

  )0 P(When it comes to linking )SM(lib{})ES( prereq)HY(ui)HY(sites)YH(, which member
  is picked is controlled by the )SM(config.bin.{exe,liba,libs}.lib)ES(
  vari)HY(ables)YH( for the executable, static library, and shared library targets,
  respec)HY(tively)YH(. Each contains a list of )SM(shared)ES( and
  )SM(static)ES( values that deter)HY(mine)YH( the linking pref)HY(er)HY(ences)YH(. For
  example, to build both shared and static libraries but to link executable to
  static libraries we can run:)EP(

  ) 1 49 PR($ b config.bin.lib=both config.bin.exe.lib=static)RP(

  )0 P(See the )0 168 1 A()SM(bin)ES()168 0 TN TL()Ec /AF f D( module docu)HY(men)HY(ta)HY(tion)YH(
  for more infor)HY(ma)HY(tion)YH(.)EP(
  )BR(

  )0 P(Note also that we don't need to change anything in the above
  )SM(build)HY(file)YH()ES( if our library is header-only. In )SM(build2)ES(
  this is handled dynam)HY(i)HY(cally)YH( and auto)HY(mat)HY(i)HY(cally)YH( based on the absence of source
  file prereq)HY(ui)HY(sites)YH(. In fact, the same library can be header-only on some
  plat)HY(forms)YH( or in some config)HY(u)HY(ra)HY(tion)YH( and "source-ful" in others.)EP(

  )BR(
  )0 P(In )SM(build2)ES( a header-only library \201or a module inter)HY(face)YH(-only
  library\202 is not a differ)HY(ent)YH( kind of library compared to static/shared
  libraries but is rather a binary-less, or )I(binless)ES( for short, static
  or shared library. So, theo)HY(ret)HY(i)HY(cally)YH(, it is possi)HY(ble)YH( to have a library that
  has a binless static and a binary-ful \201)I(binful)ES(\202 shared vari)HY(ants)YH(. Note
  also that binless libraries can depend on binful libraries and are fully
  supported where the )SM(pkg-config\2011\202)ES( func)HY(tion)HY(al)HY(ity)YH( is
  concerned.)EP(

  )0 P(One counter-intu)HY(itive)YH( aspect of having a binless library that depends on
  a system binful library, for example, )SM(-lm)ES(, is that you still
  have to specify the system library in both )SM(*.export.libs)ES( and
  )SM(*.libs)ES( because the latter is used when linking the static
  variant of the binless library. For example:)EP(

  ) 2 33 PR(cxx.libs = -lm
lib{hello}: cxx.export.libs = -lm)RP(

  )0 P(If you are creat)HY(ing)YH( a new library with )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA( and
  are certain that it will always be binless and in all config)HY(u)HY(ra)HY(tions)YH(, then
  you can produce a simpli)HY(fied)YH( )SM(build)HY(file)YH()ES( by spec)HY(i)HY(fy)HY(ing)YH( the
  )SM(binless)ES( option, for example:)EP(

  ) 1 47 PR($ bdep new -l c++ -t lib,binless libheader-only)RP(
  )BR(

  )0 P(Let's now turn to the second subject of this section and the last
  unex)HY(plained)YH( bit in our )SM(build)HY(file)YH()ES(: shared library version)HY(ing)YH(.
  Here is the rele)HY(vant)YH( frag)HY(ment)YH(:)EP(

  ) 4 64 PR(if $version.pre_release
  lib{hello}: bin.lib.version = "-$version.project_id"
else
  lib{hello}: bin.lib.version = "-$version.major.$version.minor")RP(

  )0 P(Shared library version)HY(ing)YH( is a murky, plat)HY(form)YH(-specific area. Instead of
  trying to come up with a unified version)HY(ing)YH( scheme that few are likely to
  compre)HY(hend)YH( \201similar to )SM(auto)HY(conf)YH()ES(\202, )SM(build2)ES( provides
  a plat)HY(form)YH(-inde)HY(pen)HY(dent)YH( version)HY(ing)YH( scheme as well as the ability to specify
  plat)HY(form)YH(-specific versions in a native format.)EP(

  )0 P(The library version is spec)HY(i)HY(fied)YH( with the )SM(bin.lib.version)ES(
  target-specific vari)HY(able)YH(. Its value should be a sequence of
  )SM(@)ES(-pairs with the left hand side \201key\202 being the plat)HY(form)YH( name
  and the right hand side \201value\202 being the version. An empty key \201in which
  case )SM(@)ES( can be omitted\202 signi)HY(fies)YH( the plat)HY(form)YH(-inde)HY(pen)HY(dent)YH(
  version \201see the )0 168 1 A()SM(bin)ES()168 0 TN TL()Ec /AF f D( module
  docu)HY(men)HY(ta)HY(tion)YH( for the exact seman)HY(tics)YH(\202. For example:)EP(

  ) 1 42 PR(lib{hello}: bin.lib.version = -1.2 linux@3)RP(

  )0 P(While the inter)HY(face)YH( for plat)HY(form)YH(-specific versions is
  defined, their support is currently only imple)HY(mented)YH( on Linux.)EP(

  )0 P(A plat)HY(form)YH(-inde)HY(pen)HY(dent)YH( version is embed)HY(ded)YH( as a suffix into the library
  name \201and into its )SM(soname)ES( on rele)HY(vant)YH( plat)HY(forms)YH(\202 while
  plat)HY(form)YH(-specific versions are handled accord)HY(ing)YH( to the plat)HY(form)YH(. Contin)HY(u)HY(ing)YH(
  with the above example, these would be the result)HY(ing)YH( shared library names on
  select plat)HY(forms)YH(:)EP(

  ) 3 29 PR(libhello.so.3       # Linux
libhello-1.2.dll    # Windows
libhello-1.2.dylib  # Mac OS)RP(

  )0 P(With this back)HY(ground)YH( we can now explain what's going in our
  )SM(build)HY(file)YH()ES(:)EP(

  ) 4 64 PR(if $version.pre_release
  lib{hello}: bin.lib.version = "-$version.project_id"
else
  lib{hello}: bin.lib.version = "-$version.major.$version.minor")RP(

  )0 P(Here we only use plat)HY(form)YH(-inde)HY(pen)HY(dent)YH( library version)HY(ing)YH(. For releases we
  embed both major and minor version compo)HY(nents)YH( assum)HY(ing)YH( that patch releases
  are binary compat)HY(i)HY(ble)YH(. For pre-releases, however, we use the complete
  version to make sure it cannot be used in place of another pre-release or
  the final version.)EP(

  )BR(
  )0 P(The )SM(version.project_id)ES( vari)HY(able)YH( contains the project's \201as
  opposed to package's\202, short)HY(est)YH( "version id". See the )0 167 1 A()SM(version)ES()167 0 TN TL()Ec /AF f D( module docu)HY(men)HY(ta)HY(tion)YH( for
  details.)EP(
  )BR(

  )0 2 12 H(1.7)WB 223 Sn()WB 14 Sn( Subpro)HY(jects)YH( and Amal)HY(ga)HY(ma)HY(tions)YH()EH(

  )0 P(In )SM(build2)ES( projects can contain other projects, recur)HY(sively)YH(.
  In this arrange)HY(ment)YH( the outer project is called an )I(amal)HY(ga)HY(ma)HY(tion)YH()ES( and
  the inner \235 )I(subpro)HY(jects)YH()ES(. In contrast to impor)HY(ta)HY(tion)YH( where we
  merely refer)HY(ence)YH( a project some)HY(where)YH( else, amal)HY(ga)HY(ma)HY(tion)YH( is phys)HY(i)HY(cal)YH(
  contain)HY(ment)YH(. It can be )I(strong)ES( where the src direc)HY(tory)YH( of a subpro)HY(ject)YH(
  is within the amal)HY(ga)HY(mat)HY(ing)YH( project or )I(weak)ES( where only the out
  direc)HY(tory)YH( is contained.)EP(

  )0 P(There are several distinct use cases for amal)HY(ga)HY(ma)HY(tions)YH(. We've already
  discussed the )SM(tests/)ES( subpro)HY(ject)YH( in )SM(libhello)ES(. To
  recap: tradi)HY(tion)HY(ally)YH(, it is made a subpro)HY(ject)YH( rather than a subdi)HY(rec)HY(tory)YH( to
  support build)HY(ing)YH( it as a stan)HY(dalone)YH( project in order to test library
  instal)HY(la)HY(tions)YH(.)EP(

  )0 P(As discussed in )0 12 1 A(Target Impor)HY(ta)HY(tion)YH()12 0 TN TL()Ec /AF f D(,
  subpro)HY(jects)YH( and amal)HY(ga)HY(ma)HY(tions)YH( \201as well as their subpro)HY(jects)YH(, recur)HY(sively)YH(\202
  are auto)HY(mat)HY(i)HY(cally)YH( consid)HY(ered)YH( when resolv)HY(ing)YH( imports. As a result,
  amal)HY(ga)HY(ma)HY(tion)YH( can be used to )I(bundle)ES( depen)HY(den)HY(cies)YH( to produce an
  exter)HY(nal)YH( depen)HY(dency)YH(-free distri)HY(bu)HY(tion)YH(. For example, if our
  )SM(hello)ES( project imports )SM(libhello)ES(, then we could copy
  the )SM(libhello)ES( project into )SM(hello)ES(, for example:)EP(

  ) 25 53 PR($ tree hello/
hello/
|-- build/
|   \267-- ...
|-- hello/
|   |-- hello.cxx
|   \267-- ...
|-- libhello/
|   |-- build/
|   |   \267-- ...
|   |-- libhello/
|   |   |-- hello.hxx
|   |   |-- hello.cxx
|   |   \267-- ...
|   |-- tests/
|   |   \267-- ...
|   \267-- buildfile
\267-- buildfile

$ b hello/
c++ hello/libhello/libhello/cxx{hello} ->
    hello/libhello/libhello/objs{hello}
ld hello/libhello/libhello/libs{hello}
c++ hello/hello/cxx{hello} -> hello/hello/obje{hello}
ld hello/hello/exe{hello})RP(

  )0 P(Note, however, that while project bundling can be useful in certain
  cases, it does not scale as a general depen)HY(dency)YH( manage)HY(ment)YH( solu)HY(tion)YH(. For
  that, inde)HY(pen)HY(dent)YH( pack)HY(ag)HY(ing)YH( and proper depen)HY(dency)YH( manage)HY(ment)YH( are the
  appro)HY(pri)HY(ate)YH( mech)HY(a)HY(nisms)YH(.)EP(

  )BR(
  )0 P(By default )SM(build2)ES( looks for subpro)HY(jects)YH( only in the root
  direc)HY(tory)YH( of a project. That is, every root subdi)HY(rec)HY(tory)YH( is exam)HY(ined)YH( to see
  if it itself is a project root. If you need to place a subpro)HY(ject)YH( some)HY(where)YH(
  else in your project's direc)HY(tory)YH( hier)HY(ar)HY(chy)YH(, then you will need to specify
  its loca)HY(tion)YH( \201and of all other subpro)HY(jects)YH(\202 explic)HY(itly)YH( with the
  )SM(subpro)HY(jects)YH()ES( vari)HY(able)YH( in )SM(boot)HY(strap)YH(.build)ES(. For
  example, if above we placed )SM(libhello)ES( into the
  )SM(extras/)ES( subdi)HY(rec)HY(tory)YH( of )SM(hello)ES(, then our
  )SM(boot)HY(strap)YH(.build)ES( would need to start like this:)EP(

  ) 3 30 PR(project = hello
subprojects = extras/libhello/
...)RP(

  )0 P(Note also that while impor)HY(ta)HY(tion)YH( of specific targets from subpro)HY(jects)YH( is
  always performed, whether they are loaded and built as part of the overall
  project build is controlled using the stan)HY(dard)YH( subdi)HY(rec)HY(to)HY(ries)YH( inclu)HY(sion)YH( and
  depen)HY(dency)YH( mech)HY(a)HY(nisms)YH(. Contin)HY(u)HY(ing)YH( with the above example, if we adjust the
  root )SM(build)HY(file)YH()ES( in )SM(hello)ES( to exclude the
  )SM(extras/)ES( subdi)HY(rec)HY(tory)YH( from the build:)EP(

  ) 1 25 PR(./: {*/ -build/ -extras/})RP(

  )0 P(Then while we can still import )SM(libhello)ES( from any
  )SM(build)HY(file)YH()ES( in our project, the entire )SM(libhello)ES( \201for
  example, its tests\202 will never be built as part of the )SM(hello)ES(
  build.)EP(

  )0 P(Similar to subpro)HY(jects)YH( we can also explic)HY(itly)YH( specify the project's
  amal)HY(ga)HY(ma)HY(tion)YH( with the )SM(amal)HY(ga)HY(ma)HY(tion)YH()ES( vari)HY(able)YH( \201again, in
  )SM(boot)HY(strap)YH(.build)ES(\202. This is rarely neces)HY(sary)YH( except if you want
  to prevent the project from being amal)HY(ga)HY(mated)YH(, in which case you should set
  it to the empty value.)EP(

  )0 P(If either of these vari)HY(ables)YH( is not explic)HY(itly)YH( set, then they will
  contain the auto)HY(mat)HY(i)HY(cally)YH( discov)HY(ered)YH( values.)EP(
  )BR(

  )0 P(Besides affect)HY(ing)YH( impor)HY(ta)HY(tion)YH(, another central prop)HY(erty)YH( of amal)HY(ga)HY(ma)HY(tion)YH(
  is config)HY(u)HY(ra)HY(tion)YH( inher)HY(i)HY(tance)YH(. As an example, let's config)HY(ure)YH( the above
  bundled )SM(hello)ES( project in its src direc)HY(tory)YH(:)EP(

  ) 13 63 PR($ b configure: hello/ config.cxx=clang++ config.cxx.coptions=-g

$ tree
hello/
|-- build/
|   |-- config.build
|   \267-- ...
|-- libhello/
|   |-- build/
|   |   |-- config.build
|   |   \267-- ...
|   \267-- ...
\267-- ...)RP(

  )0 P(As you can see, we now have the )SM(config.build)ES( files in both
  projects' )SM(build/)ES( subdi)HY(rec)HY(to)HY(ries)YH(. If we examine the
  amal)HY(ga)HY(ma)HY(tion)YH('s )SM(config.build)ES(, we will see the famil)HY(iar)YH(
  picture:)EP(

  ) 10 30 PR($ cat hello/build/config.build

config.cxx = clang++
config.cxx.poptions = [null]
config.cxx.coptions = -g
config.cxx.loptions = [null]
config.cxx.aoptions = [null]
config.cxx.libs = [null]

...)RP(

  )0 P(The subpro)HY(ject)YH('s )SM(config.build)ES(, however, is pretty much
  empty:)EP(

  ) 3 39 PR($ cat hello/libhello/build/config.build

# Base configuration inherited from ../)RP(

  )0 P(As the comment suggests, the base config)HY(u)HY(ra)HY(tion)YH( is inher)HY(ited)YH( from the
  outer project. We can, however, over)HY(ride)YH( some values if we need to. For
  example \201note that we are re-config)HY(ur)HY(ing)YH( the )SM(libhello)ES(
  subpro)HY(ject)YH(\202:)EP(

  ) 7 54 PR($ b configure: hello/libhello/ config.cxx.coptions=-O2

$ cat hello/libhello/build/config.build

# Base configuration inherited from ../

config.cxx.coptions = -O2)RP(

  )0 P(This config)HY(u)HY(ra)HY(tion)YH( inher)HY(i)HY(tance)YH( combined with import reso)HY(lu)HY(tion)YH( is behind
  the most common use of amal)HY(ga)HY(ma)HY(tions)YH( in )SM(build2)ES( \235 shared
  build config)HY(u)HY(ra)HY(tions)YH(. Let's say we are devel)HY(op)HY(ing)YH( multi)HY(ple)YH( projects, for
  example, )SM(hello)ES( and )SM(libhello)ES( that it imports:)EP(

  ) 3 9 PR($ ls -1
hello/
libhello/)RP(

  )0 P(And we want to build them with several compil)HY(ers)YH(, let's say GCC and
  Clang. As we have already seen in )0 8 1 A(Config)HY(ur)HY(ing)YH()8 0 TN TL()Ec /AF f D(, we can config)HY(ure)YH( several
  out of source builds for each compiler, for example:)EP(

  ) 17 59 PR($ b configure: libhello/@libhello-gcc/   config.cxx=g++
$ b configure: libhello/@libhello-clang/ config.cxx=clang++

$ b configure: hello/@hello-gcc/   \200
               config.cxx=g++      \200
               config.import.libhello=libhello-gcc/
$ b configure: hello/@hello-clang/ \200
               config.cxx=clang++  \200
               config.import.libhello=libhello-clang/

$ ls -l
hello/
hello-gcc/
hello-clang/
libhello/
libhello-gcc/
libhello-clang/)RP(

  )0 P(Need)HY(less)YH( to say, this is a lot of repet)HY(i)HY(tive)YH( typing. Another problem is
  future changes to the config)HY(u)HY(ra)HY(tions)YH(. If, for example, we need to adjust
  compile options in the GCC config)HY(u)HY(ra)HY(tion)YH(, then we will have to \201remem)HY(ber)YH( to\202
  do it in both places.)EP(

  )0 P(You can prob)HY(a)HY(bly)YH( sense where this is going: why not create two shared
  build config)HY(u)HY(ra)HY(tions)YH( \201that is, amal)HY(ga)HY(ma)HY(tions)YH(\202, one for GCC and one for
  Clang, within each of which we build both of our projects \201as their
  subpro)HY(jects)YH(\202? This is how we can do that:)EP(

  ) 14 46 PR($ b create: build-gcc/,cc   config.cxx=g++
$ b create: build-clang/,cc config.cxx=clang++

$ b configure: libhello/@build-gcc/libhello/
$ b configure: hello/@build-gcc/hello/

$ b configure: libhello/@build-clang/libhello/
$ b configure: hello/@build-clang/hello/

$ ls -l
hello/
libhello/
build-gcc/
build-clang/)RP(

  )0 P(Let's explain what's going on here. First, we create two build
  config)HY(u)HY(ra)HY(tions)YH( using the )SM(create)ES( meta-oper)HY(a)HY(tion)YH(. These are real
  )SM(build2)ES( projects just tailored for housing other projects as
  subpro)HY(jects)YH(. In )SM(create)ES(, after the direc)HY(tory)YH( name, we specify
  the list of modules to load in the project's )SM(root.build)ES(. In our
  case we specify )SM(cc)ES( which is a common module for C-based
  languages \201see )0 2 A()SM()BD(b\2011\202)ES()ES()EA( for details on
  )SM(create)ES( and its param)HY(e)HY(ters)YH(\202.)EP(

  )BR(
  )0 P(When creat)HY(ing)YH( build config)HY(u)HY(ra)HY(tions)YH( it is a good idea to get into the
  habit of using the )SM(cc)ES( module instead of )SM(c)ES( or
  )SM(cxx)ES( since with more complex depen)HY(dency)YH( chains we may not know
  whether every project we build only uses C or C++. In fact, it is not
  uncom)HY(mon)YH( for a C++ project to have C imple)HY(men)HY(ta)HY(tion)YH( details and even the
  other way around \201yes, really, there are C libraries with C++
  imple)HY(men)HY(ta)HY(tions)YH(\202.)EP(
  )BR(

  )0 P(Once the config)HY(u)HY(ra)HY(tions)YH( are ready we simply config)HY(ure)YH( our
  )SM(libhello)ES( and )SM(hello)ES( as subpro)HY(jects)YH( in each of them.
  Note that now we neither need to specify )SM(config.cxx)ES(, because it
  will be inher)HY(ited)YH( from the amal)HY(ga)HY(ma)HY(tion)YH(, nor )SM(config.import.*)ES(,
  because the import will be auto)HY(mat)HY(i)HY(cally)YH( resolved to a subpro)HY(ject)YH(.)EP(

  )0 P(Now, to build a specific project in a partic)HY(u)HY(lar)YH( config)HY(u)HY(ra)HY(tion)YH( we simply
  build the corre)HY(spond)HY(ing)YH( subdi)HY(rec)HY(tory)YH(. We can also build the entire build
  config)HY(u)HY(ra)HY(tion)YH( if we want to. For example:)EP(

  ) 3 20 PR($ b build-gcc/hello/

$ b build-clang/)RP(

  )BR(
  )0 P(In case you've already looked into )0 2 A()SM()BD(bpkg\2011\202)ES()ES()EA( and/or )0 2 A()SM()BD(bdep\2011\202)ES()ES()EA(, their
  build config)HY(u)HY(ra)HY(tions)YH( are actu)HY(ally)YH( these same amal)HY(ga)HY(ma)HY(tions)YH( \201created
  under)HY(neath)YH( with the )SM(create)ES( meta-oper)HY(a)HY(tion)YH(\202 and their pack)HY(ages)YH(
  are just subpro)HY(jects)YH(. And with this under)HY(stand)HY(ing)YH( you are free to inter)HY(act)YH(
  with them directly using the build system inter)HY(face)YH(.)EP(
  )BR(

  )0 2 13 H(1.8)WB 224 Sn()WB 15 Sn( Build)HY(file)YH( Language)EH(

  )0 P(By now we should have a good overall sense of what writing
  )SM(build)HY(files)YH()ES( feels like. In this section we will examine the
  language in slightly more detail and with more preci)HY(sion)YH(.)EP(

  )0 P(Build)HY(file)YH( is primar)HY(ily)YH( a declar)HY(a)HY(tive)YH( language with support for vari)HY(ables)YH(,
  pure func)HY(tions)YH(, repe)HY(ti)HY(tion)YH( \201)SM(for)ES(-loop\202, condi)HY(tional)YH(
  inclu)HY(sion)YH(/exclu)HY(sion)YH( \201)SM(if-else)ES(\202, and pattern match)HY(ing)YH(
  \201)SM(switch)ES(\202. At the lexical level, )SM(build)HY(files)YH()ES( are
  UTF-8 encoded text restricted to the Unicode graphic char)HY(ac)HY(ters)YH(, tabs
  \201)SM(\200t)ES(\202, carriage returns \201)SM(\200r)ES(\202, and line feeds
  \201)SM(\200n)ES(\202.)EP(

  )0 P(Build)HY(file)YH( is a line-oriented language. That is, every construct ends at
  the end of the line unless escaped with line contin)HY(u)HY(a)HY(tion)YH( \201trail)HY(ing)YH(
  )SM(\200)ES(\202. For example:)EP(

  ) 2 27 PR(exe{hello}: {hxx cxx}{**} \200
  $libs)RP(

  )0 P(Some lines may start a )I(block)ES( if followed by )SM({)ES( on the
  next line. Such a block ends with a closing )SM(})ES( on a sepa)HY(rate)YH(
  line. Some types of blocks can nest. For example:)EP(

  ) 7 37 PR(if \201$cxx.target.class == 'windows'\202
{
  if \201$cxx.target.system == 'ming32'\202
  {
    ...
  }
})RP(

  )0 P(A comment starts with )SM(#)ES( and every)HY(thing)YH( from this char)HY(ac)HY(ter)YH(
  and until the end of the line is ignored. A multi-line comment starts with
  )SM(#\200)ES( on a sepa)HY(rate)YH( line and ends with the same char)HY(ac)HY(ter)YH(
  sequence, again on a sepa)HY(rate)YH( line. For example:)EP(

  ) 9 40 PR(# Single line comment.

info 'Hello, World!' # Trailing comment.

#\200
Multi-
line
comment.
#\200)RP(

  )0 P(The three primary Build)HY(file)YH( constructs are depen)HY(dency)YH( decla)HY(ra)HY(tion)YH(,
  direc)HY(tive)YH(, and vari)HY(able)YH( assign)HY(ment)YH(. We've already used all three but let's
  see another example:)EP(

  ) 5 63 PR(include ../libhello/                              # Directive.

exe{hello}: {hxx cxx}{**} ../libhello/lib{hello}  # Dependency.

cxx.poptions += -DNDEBUG                          # Variable.)RP(

  )0 P(There is also the scope opening \201we've seen one in
  )SM(export.build)ES(\202 as well as target-specific and
  prereq)HY(ui)HY(site)YH(-specific vari)HY(able)YH( assign)HY(ment)YH( blocks. The latter two are used to
  assign several entity-specific vari)HY(ables)YH( at once. For example:)EP(

  ) 16 58 PR(details/                          # Scope.
{
  hxx{*}: install = false
}

lib{hello}:                       # Target-specific.
{
  cxx.export.poptions = "-I$src_root"
  cxx.export.libs = $intf_libs
}

exe{test}: file{test.roundtrip}:  # Prerequisite-specific.
{
  test.stdin  = true
  test.stdout = true
})RP(

  )0 P(Vari)HY(able)YH( assign)HY(ment)YH( blocks can be combined with depen)HY(dency)YH( decla)HY(ra)HY(tions)YH(,
  for example:)EP(

  ) 8 34 PR(h{config}: in{config}
{
  in.symbol = '@'
  in.mode = lax

  SYSTEM_NAME = $c.target.system
  SYSTEM_PROCESSOR = $c.target.cpu
})RP(

  )0 P(In case of a depen)HY(dency)YH( chain, if the chain ends with a colon
  \201)SM(:)ES(\202, then the block applies to the last set of prereq)HY(ui)HY(sites)YH(.
  Other)HY(wise)YH(, it applies to the last set of targets. For example:)EP(

  ) 9 63 PR(./: exe{test}: cxx{main}
{
  test = true        # Applies to the exe{test} target.
}

./: exe{test}: libue{test}:
{
  bin.whole = false  # Applies to the libue{test} prerequisite.
})RP(

  )BR(
  )0 P(All prereq)HY(ui)HY(site)YH(-specific vari)HY(ables)YH( must be assigned at once as part of
  the depen)HY(dency)YH( decla)HY(ra)HY(tion)YH( since repeat)HY(ing)YH( the same depen)HY(dency)YH( again
  dupli)HY(cates)YH( the prereq)HY(ui)HY(site)YH( rather than refer)HY(ences)YH( the already exist)HY(ing)YH(
  one.)EP(
  )BR(

  )0 P(There is also the target type/pattern-specific vari)HY(able)YH( assign)HY(ment)YH( block,
  for example:)EP(

  ) 5 17 PR(exe{*.test}:
{
  test = true
  install = false
})RP(

  )0 P(See )0 36 1 A(Vari)HY(ables)YH()36 0 TN TL()Ec /AF f D( for a more detailed discus)HY(sion)YH( of
  vari)HY(ables)YH(.)EP(

  )0 P(Each )SM(build)HY(file)YH()ES( is processed linearly with direc)HY(tives)YH(
  executed and vari)HY(ables)YH( expanded as they are encoun)HY(tered)YH(. However, certain
  vari)HY(ables)YH(, for example )SM(cxx.poptions)ES(, are also expanded by rules
  during execu)HY(tion)YH( in which case they will "see" the final value set in the
  )SM(build)HY(file)YH()ES(.)EP(

  )BR(
  )0 P(Unlike GNU )SM(make\2011\202)ES(, which has deferred \201)SM(=)ES(\202 and
  imme)HY(di)HY(ate)YH( \201)SM(:=)ES(\202 vari)HY(able)YH( assign)HY(ments)YH(, all assign)HY(ments)YH( in
  )SM(build2)ES( are imme)HY(di)HY(ate)YH(. For example:)EP(

  ) 4 30 PR(x = x
y = $x
x = X
info $y # Prints 'x', not 'X'.)RP(
  )BR(

  )0 3 14 H(1.8.1)WB 225 Sn()WB 16 Sn( Expan)HY(sion)YH( and Quoting)EH(

  )0 P(While we've discussed vari)HY(able)YH( expan)HY(sion)YH( and lookup earlier, to recap, to
  get the vari)HY(able)YH('s value we use )SM($)ES( followed by its name. The
  vari)HY(able)YH( name is first looked up in the current scope \201that is, the scope in
  which the expan)HY(sion)YH( was encoun)HY(tered)YH(\202 and, if not found, in the outer scopes,
  recur)HY(sively)YH(.)EP(

  )0 P(There are two other kinds of expan)HY(sions)YH(: func)HY(tion)YH( calls and eval)HY(u)HY(a)HY(tion)YH(
  contexts, or )I(eval contexts)ES( for short. Let's start with the latter
  since func)HY(tion)YH( calls are built on top of eval contexts.)EP(

  )0 P(An eval context is essen)HY(tially)YH( a frag)HY(ment)YH( of a line with addi)HY(tional)YH(
  inter)HY(pre)HY(ta)HY(tions)YH( of certain char)HY(ac)HY(ters)YH( to support value compar)HY(i)HY(son)YH(, logical
  oper)HY(a)HY(tors)YH(, and a few other constructs. Eval contexts begin with
  )SM(\201)ES(, end with )SM(\202)ES(, and can nest. Here are a few
  exam)HY(ples)YH(:)EP(

  ) 8 69 PR(info \201$src_root != $out_root\202                 # Prints true or false.
info \201$src_root == $out_root ? 'in' : 'out'\202  # Prints in or out.

macos = \201$cxx.target.class == 'macos'\202  # Assigns true or false.
linux = \201$cxx.target.class == 'linux'\202  # Assigns true or false.

if \201$macos || $linux\202  # Also eval context.
  ...)RP(

  )BR(
  )0 P(Below is the eval context grammar that shows supported oper)HY(a)HY(tors)YH( and
  their prece)HY(dence)YH(.)EP(

  ) 10 68 PR(eval:         '\201' \201eval-comma | eval-qual\202? '\202'
eval-comma:   eval-ternary \201',' eval-ternary\202*
eval-ternary: eval-or \201'?' eval-ternary ':' eval-ternary\202?
eval-or:      eval-and \201'||' eval-and\202*
eval-and:     eval-comp \201'&&' eval-comp\202*
eval-comp:    eval-value \201\201'=='|'!='|'<'|'>'|'<='|'>='\202 eval-value\202*
eval-value:   value-attributes? \201<value> | eval | '!' eval-value\202
eval-qual:    <name> ':' <name>

value-attributes: '[' <key-value-pairs> ']')RP(

  )0 P(Note that )SM(?:)ES( \201ternary oper)HY(a)HY(tor)YH(\202 and )SM(!)ES( \201logical
  not\202 are right-asso)HY(cia)HY(tive)YH(. Unlike C++, all the compar)HY(i)HY(son)YH( oper)HY(a)HY(tors)YH( have
  the same prece)HY(dence)YH(. A qual)HY(i)HY(fied)YH( name cannot be combined with any other
  oper)HY(a)HY(tor)YH( \201includ)HY(ing)YH( ternary\202 unless enclosed in paren)HY(the)HY(ses)YH(. The
  )SM(eval)ES( option in the )SM(eval-value)ES( produc)HY(tion)YH( shall
  contain a single value only \201no commas\202.)EP(

  )0 P(Addi)HY(tion)HY(ally)YH(, the )SM(`)ES( \201back)HY(tick)YH(\202 and )SM(|)ES( \201bitwise
  or\202 tokens are reserved for future support of arith)HY(metic)YH( eval)HY(u)HY(a)HY(tion)YH( contexts
  and eval)HY(u)HY(a)HY(tion)YH( pipelines, respec)HY(tively)YH(.)EP(
  )BR(

  )0 P(A func)HY(tion)YH( call starts with )SM($)ES( followed by its name and an
  eval context listing its argu)HY(ments)YH(. Note that there is no space between the
  name and )SM(\201)ES(. For example:)EP(

  ) 14 51 PR(x =
y = Y

info $empty\201$x\202  # true
info $empty\201$y\202  # false

if $regex.match\201$y, '[A-Z]'\202
  ...

p = $src_base/foo.txt

info $path.leaf\201$src_base\202              # foo.txt
info $path.directory\201$src_base\202         # $src_base
info $path.base\201$path.leaf\201$src_base\202\202  # foo)RP(

  )0 P(Note that the major)HY(ity)YH( of func)HY(tions)YH( in )SM(build2)ES( are
  )I(pure)ES( in a sense that they do not alter the build state in any way
  \201see )0 37 1 A(Func)HY(tions)YH()37 0 TN TL()Ec /AF f D( for details\202.)EP(

  )BR(
  )0 P(Func)HY(tions)YH( in )SM(build2)ES( are currently defined either by the
  build system core or build system modules and are imple)HY(mented)YH( in C++. In the
  future it will be possi)HY(ble)YH( to define custom func)HY(tions)YH( in
  )SM(build)HY(files)YH()ES( \201also in C++\202.)EP(
  )BR(

  )0 P(Vari)HY(able)YH( and func)HY(tion)YH( names follow the C iden)HY(ti)HY(fier)YH( rules. We can also
  group vari)HY(ables)YH( into names)HY(paces)YH( and func)HY(tions)YH( into fami)HY(lies)YH( by combin)HY(ing)YH(
  multi)HY(ple)YH( iden)HY(ti)HY(fiers)YH( with )SM(.)ES(. These rules are used to deter)HY(mine)YH(
  the end of the vari)HY(able)YH( name in expan)HY(sions)YH(. If, however, a name is
  recog)HY(nized)YH( as being longer than desired, then we can use the eval context to
  explic)HY(itly)YH( specify its bound)HY(aries)YH(. For example:)EP(

  ) 2 18 PR(base = foo
name = $\201base\202.txt)RP(

  )0 P(What is the struc)HY(ture)YH( of a vari)HY(able)YH( value? Consider this assign)HY(ment)YH(:)EP(

  ) 1 11 PR(x = foo bar)RP(

  )0 P(The value of )SM(x)ES( could be a string, a list of two strings, or
  some)HY(thing)YH( else entirely. In )SM(build2)ES( the funda)HY(men)HY(tal)YH(, untyped
  value is a )I(list of names)ES(. A value can be typed to some)HY(thing)YH( else
  later but it always starts as a list of names. So in the above example we
  have a list of two names, )SM(foo)ES( and )SM(bar)ES(, the same as
  in this example \201notice the extra spaces\202:)EP(

  ) 1 14 PR(x = foo    bar)RP(

  )BR(
  )0 P(The moti)HY(va)HY(tion)YH( behind going with a list of names instead of a string or a
  list of strings is that at its core we are dealing with targets and their
  prereq)HY(ui)HY(sites)YH( and it would be natural to make the repre)HY(sen)HY(ta)HY(tion)YH( of their
  names \201that is, the way we refer to them\202 the default. Consider the
  follow)HY(ing)YH( two exam)HY(ples)YH(; it would be natural for them to mean the same
  thing:)EP(

  ) 1 25 PR(exe{hello}: {hxx cxx}{**})RP(

  ) 2 23 PR(prereqs = {hxx cxx}{**}
exe{hello}: $prereqs)RP(

  )0 P(Note also that the name seman)HY(tics)YH( was care)HY(fully)YH( tuned to be
  )I(reversible)ES( to its syntac)HY(tic)YH( repre)HY(sen)HY(ta)HY(tion)YH( for common non-name
  values, such as paths, command line options, etc., that are usually found in
  )SM(build)HY(files)YH()ES(.)EP(
  )BR(

  )0 P(To get to indi)HY(vid)HY(ual)YH( elements of a list, an expan)HY(sion)YH( can be followed by
  a subscript. Note that subscripts are only recog)HY(nize)YH( inside eval)HY(u)HY(a)HY(tion)YH(
  contexts and there should be no space between the expan)HY(sion)YH( and
  )SM([)ES(. For example:)EP(

  ) 4 49 PR(x = foo bar

info \201$x[0]\202                                # foo
info \201$regex.split\201'foo bar', ' ', ''\202[1]\202  # bar)RP(

  )0 P(Names are split into a list at whites)HY(pace)YH( bound)HY(aries)YH( with certain other
  char)HY(ac)HY(ters)YH( treated as syntax rather than as part of the value. Here are a
  few exam)HY(ples)YH(:)EP(

  ) 6 33 PR(x = $y          # expansion
x = \201a == b\202    # eval context
x = {foo bar}   # name generation
x = [null]      # attributes
x = name@value  # pairs
x = # start of a comment)RP(

  )0 P(The complete set of syntax char)HY(ac)HY(ters)YH( is )SM($\201\202{}@#"')ES( plus
  space and tab, as well as )SM([])ES(, but only in certain contexts \201see
  )0 159 1 A(Attributes)159 0 TN TL()Ec /AF f D( for details\202. If instead we need these
  char)HY(ac)HY(ters)YH( to appear liter)HY(ally)YH( as part of the value, then we either have to
  )I(escape)ES( or )I(quote)ES( them.)EP(

  )BR(
  )0 P(Addi)HY(tion)HY(ally)YH(, )SM(*?[)ES( will be treated as wild)HY(cards)YH( in name
  patterns \201see )0 160 1 A(Name Patterns)160 0 TN TL()Ec /AF f D( for details\202. Note
  that this treat)HY(ment)YH( can only be inhib)HY(ited)YH( with quoting and not escap)HY(ing)YH(.)EP(

  )0 P(While name patterns are recog)HY(nized)YH( inside eval)HY(u)HY(a)HY(tion)YH( contexts, in certain
  cases the )SM(?[)ES( char)HY(ac)HY(ters)YH( are treated as part of the ternary
  oper)HY(a)HY(tor)YH( and value subscript, respec)HY(tively)YH(. In such case, to be treat as
  wild)HY(cards)YH( rather than as syntax, these char)HY(ac)HY(ters)YH( have to be escaped, for
  example:)EP(

  ) 2 20 PR(x = \201foo.\200?xx\202
y = \201$foo\200[123].txt\202)RP(
  )BR(

  )0 P(To escape a special char)HY(ac)HY(ter)YH(, we prefix it with a back)HY(slash)YH(
  \201)SM(\200)ES(; to specify a literal back)HY(slash)YH(, double it\202. For
  example:)EP(

  ) 2 22 PR(x = \200$
y = C:\200\200Program\200 Files)RP(

  )0 P(Similar to UNIX shells, )SM(build2)ES( supports single
  \201)SM('')ES(\202 and double \201)SM("")ES(\202 quoting with roughly the same
  seman)HY(tics)YH(. Specif)HY(i)HY(cally)YH(, expan)HY(sions)YH( \201vari)HY(able)YH(, func)HY(tion)YH( call, and eval
  context\202 and escap)HY(ing)YH( are performed inside double-quoted strings but not in
  single-quoted. Note also that quoted strings can span multi)HY(ple)YH( lines with
  newlines treated liter)HY(ally)YH( \201unless escaped in double-quoted strings\202. For
  example:)EP(

  ) 9 26 PR(x = "\201a != b\202"  # true
y = '\201a != b\202'  # \201a != b\202

x = "C:\200\200Program Files"
y = 'C:\200Program Files'

t = 'line one
line two
line three')RP(

  )0 P(Since quote char)HY(ac)HY(ters)YH( are also part of the syntax, if you need to
  specify them liter)HY(ally)YH( in the value, then they will either have to be
  escaped or quoted. For example:)EP(

  ) 2 40 PR(cxx.poptions += -DOUTPUT='"debug"'
cxx.poptions += -DTARGET=\200"$cxx.target\200")RP(

  )0 P(An expan)HY(sion)YH( can be one of two kinds: )I(spliced)ES( or
  )I(concate)HY(nated)YH()ES(. In a spliced expan)HY(sion)YH( the vari)HY(able)YH(, func)HY(tion)YH(, or eval
  context is sepa)HY(rated)YH( from other text with whites)HY(paces)YH(. In this case, as the
  name suggests, the result)HY(ing)YH( list of names is spliced into the value. For
  example:)EP(

  ) 2 53 PR(x = 'foo fox'
y = bar $x baz  # Three names: 'bar' 'foo fox' 'baz'.)RP(

  )BR(
  )0 P(This is an impor)HY(tant)YH( differ)HY(ence)YH( compared to the seman)HY(tics)YH( of UNIX shells
  where the result of expan)HY(sion)YH( is re-parsed. In partic)HY(u)HY(lar)YH(, this is the
  reason why you won't see quoted expan)HY(sions)YH( in )SM(build)HY(files)YH()ES( as
  often as in \201well-written\202 shell scripts.)EP(
  )BR(

  )0 P(In a concate)HY(nated)YH( expan)HY(sion)YH( the vari)HY(able)YH(, func)HY(tion)YH(, or eval context are
  combined with unsep)HY(a)HY(rated)YH( text before and/or after the expan)HY(sion)YH(. For
  example:)EP(

  ) 2 46 PR(x = 'foo fox'
y = bar$\201x\202foz  # Single name: 'barfoo foxbaz')RP(

  )0 P(A concate)HY(nated)YH( expan)HY(sion)YH( is typed unless it is quoted. In a typed
  concate)HY(nated)YH( expan)HY(sion)YH( the parts are combined in a type-aware manner while
  in an untyped \235 liter)HY(ally)YH(, as string. To illus)HY(trate)YH( the differ)HY(ence)YH(,
  consider this )SM(build)HY(file)YH()ES( frag)HY(ment)YH(:)EP(

  ) 2 24 PR(info $src_root/foo.txt
info "$src_root/foo.txt")RP(

  )0 P(If we run it on a UNIX-like oper)HY(at)HY(ing)YH( system, we will see two iden)HY(ti)HY(cal)YH(
  lines, along these lines:)EP(

  ) 2 17 PR(/tmp/test/foo.txt
/tmp/test/foo.txt)RP(

  )0 P(However, if we run it on Windows \201which uses back)HY(slashes)YH( as direc)HY(tory)YH(
  sepa)HY(ra)HY(tors)YH(\202, we will see the output along these lines:)EP(

  ) 2 15 PR(C:\200test\200foo.txt
C:\200test/foo.txt)RP(

  )0 P(The typed concate)HY(na)HY(tion)YH( resulted in a native direc)HY(tory)YH( sepa)HY(ra)HY(tor)YH( because
  )SM(dir_path)ES( \201the )SM(src_root)ES( type\202 did the right
  thing.)EP(

  )0 P(Not every typed concate)HY(na)HY(tion)YH( is well defined and in certain situ)HY(a)HY(tions)YH(
  we may need to force untyped concate)HY(na)HY(tion)YH( with quoting. Options spec)HY(i)HY(fy)HY(ing)YH(
  header search paths \201)SM(-I)ES(\202 are a typical case, for example:)EP(

  ) 1 43 PR(cxx.poptions =+ "-I$out_root" "-I$src_root")RP(

  )0 P(If we were to remove the quotes, we would see the follow)HY(ing)YH( error:)EP(

  ) 2 70 PR(buildfile:6:20: error: no typed concatenation of <untyped> to dir_path
  info: use quoting to force untyped concatenation)RP(

  )0 3 15 H(1.8.2)WB 226 Sn()WB 17 Sn( Condi)HY(tions)YH( \201)SM(if-else)ES(\202)EH(

  )0 P(The )SM(if)ES( direc)HY(tive)YH( can be used to condi)HY(tion)HY(ally)YH( exclude
  )SM(build)HY(file)YH()ES( frag)HY(ments)YH( from being processed. The condi)HY(tional)YH(
  frag)HY(ment)YH( can be a single \201sepa)HY(rate)YH(\202 line or a block with the initial
  )SM(if)ES( option)HY(ally)YH( followed by a number of )SM(elif)ES(
  direc)HY(tives)YH( and a final )SM(else)ES(, which together form the
  )SM(if-else)ES( chain. An )SM(if-else)ES( block can contain nested
  )SM(if-else)ES( chains. For example:)EP(

  ) 13 43 PR(if \201$cxx.target.class == 'linux'\202
  info 'linux'
elif \201$cxx.target.class == 'windows'\202
{
  if \201$cxx.target.system == 'mingw32'\202
    info 'windows-mingw'
  elif \201$cxx.target.system == 'win32-msvc'\202
    info 'windows-msvc'
  else
    info 'windows-other'
}
else
  info 'other')RP(

  )0 P(The )SM(if)ES( and )SM(elif)ES( direc)HY(tive)YH( names must be
  followed by an expres)HY(sion)YH( that expands to a single, literal
  )SM(true)ES( or )SM(false)ES(. This can be a vari)HY(able)YH( expan)HY(sion)YH(, a
  func)HY(tion)YH( call, an eval context, or a literal value. For example:)EP(

  ) 17 45 PR(if $version.pre_release
  ...

if $regex.match\201$x, '[A-Z]'\202
  ...

if \201$cxx.target.class == 'linux'\202
  ...

if false
{
  # disabled fragment
}

x = X
if $x  # Error, must expand to true or false.
  ...)RP(

  )0 P(There are also )SM(if!)ES( and )SM(elif!)ES( direc)HY(tives)YH( which
  negate the condi)HY(tion)YH( that follows \201note that there is no space before
  )SM(!)ES(\202. For example:)EP(

  ) 4 31 PR(if! $version.pre_release
  ...
elif! $regex.match\201$x, '[A-Z]'\202
  ...)RP(

  )0 P(Note also that there is no notion of vari)HY(able)YH( local)HY(ity)YH( in
  )SM(if-else)ES( blocks and any value set inside is visible outside. For
  example:)EP(

  ) 6 22 PR(if true
{
  x = X
}

info $x  # Prints 'X'.)RP(

  )0 P(The )SM(if-else)ES( chains should not be used for condi)HY(tional)YH(
  depen)HY(dency)YH( decla)HY(ra)HY(tions)YH( since this would violate the expec)HY(ta)HY(tion)YH( that all of
  the project's source files are listed as prereq)HY(ui)HY(sites)YH(, irre)HY(spec)HY(tive)YH( of the
  config)HY(u)HY(ra)HY(tion)YH(.  Instead, use the special )SM(include)ES(
  prereq)HY(ui)HY(site)YH(-specific vari)HY(able)YH( to condi)HY(tion)HY(ally)YH( include prereq)HY(ui)HY(sites)YH( into
  the build. For example:)EP(

  ) 11 72 PR(# Incorrect.
#
if \201$cxx.target.class == 'linux'\202
  exe{hello}: cxx{hello-linux}
elif \201$cxx.target.class == 'windows'\202
  exe{hello}: cxx{hello-win32}

# Correct.
#
exe{hello}: cxx{hello-linux}: include = \201$cxx.target.class == 'linux'\202
exe{hello}: cxx{hello-win32}: include = \201$cxx.target.class == 'windows'\202)RP(

  )0 3 16 H(1.8.3)WB 227 Sn()WB 18 Sn( Pattern Match)HY(ing)YH( \201)SM(switch)ES(\202)EH(

  )0 P(The )SM(switch)ES( direc)HY(tive)YH( is similar to )SM(if-else)ES( in
  that it allows us to condi)HY(tion)HY(ally)YH( exclude )SM(build)HY(file)YH()ES( frag)HY(ments)YH(
  from being processed. The differ)HY(ence)YH( is in the way the condi)HY(tions)YH( are
  struc)HY(tured)YH(: while in )SM(if-else)ES( we can do arbi)HY(trary)YH( tests, in
  )SM(switch)ES( we match one or more values against a set of patterns.
  For instance, this is how we can reim)HY(ple)HY(ment)YH( the first example from )0 17 1 A(Condi)HY(tion)HY(als)YH( \201)SM(if-else)ES(\202)17 0 TN TL()Ec /AF f D( using
  )SM(switch)ES(:)EP(

  ) 17 44 PR(switch $cxx.target.class, $cxx.target.system
{
  case 'linux'
    info 'linux'

  case 'windows', 'mingw32'
    info 'windows-mingw'

  case 'windows', 'win32-msvc'
    info 'windows-msvc'

  case 'windows'
    info 'windows-other'

  default
    info 'other'
})RP(

  )0 P(Similar to )SM(if-else)ES(, the condi)HY(tional)YH( frag)HY(ment)YH( can be a single
  \201sepa)HY(rate)YH(\202 line or a block with a zero or more )SM(case)ES(
  lines/blocks option)HY(ally)YH( followed by )SM(default)ES(. A
  )SM(case-default)ES( block can contain nested )SM(switch)ES(
  direc)HY(tives)YH( \201though it is often more conve)HY(nient)YH( to use multi)HY(ple)YH( values in a
  single )SM(switch)ES(, as shown above\202. For example:)EP(

  ) 19 29 PR(switch $cxx.target.class
{
  ...
  case 'windows'
  {
    switch $cxx.target.system
    {
      case 'mingw32'
        info 'windows-mingw'

      case 'win32-msvc'
        info 'windows-msvc'

      default
        info 'windows-other'
    }
  }
  ...
})RP(

  )0 P(All the )SM(case)ES( frag)HY(ments)YH( are tried in the order spec)HY(i)HY(fied)YH( with
  the first that matches eval)HY(u)HY(ated)YH( and all the others ignored \201that is, there
  is no explicit )SM(break)ES( nor the ability to fall through\202. If none
  of the )SM(case)ES( patterns matched and there is the
  )SM(default)ES( frag)HY(ment)YH(, then it is eval)HY(u)HY(ated)YH(. Multi)HY(ple)YH(
  )SM(case)ES( lines can be spec)HY(i)HY(fied)YH( for a single condi)HY(tional)YH( frag)HY(ment)YH(.
  For example:)EP(

  ) 6 33 PR(switch $cxx.target.class, $cxx.id
{
  case 'windows', 'msvc'
  case 'windows', 'clang'
    info 'msvcrt'
})RP(

  )0 P(The )SM(switch)ES( direc)HY(tive)YH( name must be followed by one or more
  )I(value expres)HY(sions)YH()ES( sepa)HY(rated)YH( with a comma \201)SM(,)ES(\202. Simi)HY(larly)YH(,
  the )SM(case)ES( direc)HY(tive)YH( name must be followed by one or more
  )I(pattern expres)HY(sions)YH()ES( sepa)HY(rated)YH( with a comma \201)SM(,)ES(\202. These
  expres)HY(sions)YH( can be vari)HY(able)YH( expan)HY(sions)YH(, func)HY(tion)YH( calls, eval contexts, or
  literal values.)EP(

  )0 P(If multi)HY(ple)YH( values/patterns are spec)HY(i)HY(fied)YH(, then all the )SM(case)ES(
  patterns must match in order for the corre)HY(spond)HY(ing)YH( frag)HY(ment)YH( to be eval)HY(u)HY(ated)YH(.
  However, if some trail)HY(ing)YH( patterns are omitted, then they are consid)HY(ered)YH( as
  match)HY(ing)YH(. For example:)EP(

  ) 11 44 PR(switch $cxx.target.class, $cxx.target.system
{
  case 'windows', 'mingw32'
    info 'windows-mingw'

  case 'windows', 'win32-msvc'
    info 'windows-msvc'

  case 'windows'
    info 'windows-other'
})RP(

  )0 P(The first pattern in the pattern expres)HY(sion)YH( can be option)HY(ally)YH( followed by
  one or more alter)HY(na)HY(tive)YH( patterns sepa)HY(rated)YH( by a verti)HY(cal)YH( bar
  \201)SM(|)ES(\202. Only one of the alter)HY(na)HY(tives)YH( need to match in order for
  the whole pattern expres)HY(sion)YH( to be consid)HY(ered)YH( as match)HY(ing)YH(. For example:)EP(

  ) 5 30 PR(switch $cxx.id
{
  case 'clang' | 'clang-apple'
    ...
})RP(

  )0 P(The value in the value expres)HY(sion)YH( can be option)HY(ally)YH( followed by a colon
  \201)SM(:)ES(\202 and a )I(match func)HY(tion)YH()ES(. If the match func)HY(tion)YH( is not
  spec)HY(i)HY(fied)YH(, then equal)HY(ity)YH( is used by default. For example:)EP(

  ) 8 35 PR(switch $cxx.target.cpu: regex.match
{
  case 'i[3-6]86'
    ...

  case 'x86_64'
    ...
})RP(

  )0 P(The match func)HY(tion)YH( name can be option)HY(ally)YH( followed by addi)HY(tional)YH( values
  that are passed as the third argu)HY(ment)YH( to the match func)HY(tion)YH(. This is
  normally used to specify addi)HY(tional)YH( match flags, for example:)EP(

  ) 4 41 PR(switch $cxx.target.cpu: regex.match icase
{
  ...
})RP(

  )0 P(Other commonly used match func)HY(tions)YH( are )SM(regex.search\201\202)ES(
  \201similar to )SM(regex.match\201\202)ES( but searches for any match rather
  than match)HY(ing)YH( the whole value\202, )SM(path.match\201\202)ES( \201match using shell
  wild)HY(card)YH( patterns\202 and )SM(string.icas)HY(ecmp)YH(\201\202)ES( \201match using equal)HY(ity)YH(
  but ignor)HY(ing)YH( case\202. Addi)HY(tion)HY(ally)YH(, any other func)HY(tion)YH( that takes the value as
  its first argu)HY(ment)YH(, the pattern as its second, and returns )SM(bool)ES(
  can be used as a match func)HY(tion)YH(.)EP(

  )BR(
  )0 P(Note that there is no special wild)HY(card)YH( or match-anything pattern at the
  syntax level. In most common cases the desired seman)HY(tics)YH( can be achieved
  with )SM(default)ES( and/or by omit)HY(ting)YH( trail)HY(ing)YH( patterns. If you do
  need it, then we recom)HY(mend)YH( using )SM(path.match\201\202)ES( and its
  )SM(*)ES( wild)HY(card)YH(. For example:)EP(

  ) 7 40 PR(switch $cxx.target.class: path.match, \200
       $cxx.target.system: path.match, \200
       $cxx.id: path.match
{
  case 'windows', '*', 'clang'
    ...
})RP(
  )BR(

  )0 P(Note also that similar to )SM(if-else)ES(, there is no notion of
  vari)HY(able)YH( local)HY(ity)YH( in the )SM(switch)ES( and )SM(case-default)ES(
  blocks and any value set inside is visible outside. Addi)HY(tion)HY(ally)YH(, the same
  consid)HY(er)HY(a)HY(tions)YH( about condi)HY(tional)YH( depen)HY(dency)YH( decla)HY(ra)HY(tions)YH( apply.)EP(

  )0 3 17 H(1.8.4)WB 228 Sn()WB 19 Sn( Repe)HY(ti)HY(tions)YH( \201)SM(for)ES(\202)EH(

  )0 P(The )SM(for)ES( direc)HY(tive)YH( can be used to repeat the same
  )SM(build)HY(file)YH()ES( frag)HY(ment)YH( multi)HY(ple)YH( times, once for each element of a
  list. The frag)HY(ment)YH( to repeat can be a single \201sepa)HY(rate)YH(\202 line or a block,
  which together form the )SM(for)ES( loop. A )SM(for)ES( block can
  contain nested )SM(for)ES( loops. For example:)EP(

  ) 4 18 PR(for n: foo bar baz
{
  exe{$n}: cxx{$n}
})RP(

  )0 P(The )SM(for)ES( direc)HY(tive)YH( name must be followed by the vari)HY(able)YH( name
  \201called )I(loop vari)HY(able)YH()ES(\202 that on each iter)HY(a)HY(tion)YH( will be assigned the
  corre)HY(spond)HY(ing)YH( element, )SM(:)ES(, and an expres)HY(sion)YH( that expands to a
  poten)HY(tially)YH( empty list of values. This can be a vari)HY(able)YH( expan)HY(sion)YH(, a
  func)HY(tion)YH( call, an eval context, or a literal list as in the above frag)HY(ment)YH(.
  Here is a some)HY(what)YH( more real)HY(is)HY(tic)YH( example that splits a space-sepa)HY(rated)YH(
  envi)HY(ron)HY(ment)YH( vari)HY(able)YH( value into names and then gener)HY(ates)YH( a depen)HY(dency)YH(
  decla)HY(ra)HY(tion)YH( for each of them:)EP(

  ) 4 45 PR(for n: $regex.split\201$getenv\201NAMES\202, ' +', ''\202
{
  exe{$n}: cxx{$n}
})RP(

  )0 P(Note also that there is no notion of vari)HY(able)YH( local)HY(ity)YH( in
  )SM(for)ES( blocks and any value set inside is visible outside. At the
  end of the iter)HY(a)HY(tion)YH( the loop vari)HY(able)YH( contains the value of the last
  element, if any. For example:)EP(

  ) 7 22 PR(for x: x X
{
  y = Y
}

info $x  # Prints 'X'.
info $y  # Prints 'Y'.)RP(

  )0 2 18 H(1.9)WB 229 Sn()WB 20 Sn( Imple)HY(ment)HY(ing)YH( Unit Testing)EH(

  )0 P(As an example of how many of these features fit together to imple)HY(ment)YH(
  more advanced func)HY(tion)HY(al)HY(ity)YH(, let's examine a )SM(build)HY(file)YH()ES( that
  provides support for unit testing. This support is added by the )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  command if we specify the )SM(unit-tests)ES( option when creat)HY(ing)YH(
  executable \201)SM(-t\240exe,unit-tests)ES(\202 or library
  \201)SM(-t\240lib,unit-tests)ES(\202 projects. Here is the source
  subdi)HY(rec)HY(tory)YH( )SM(build)HY(file)YH()ES( of an executable created with this
  option:)EP(

  ) 20 55 PR(./: exe{hello}: libue{hello}: {hxx cxx}{** -**.test...}

# Unit tests.
#
exe{*.test}:
{
  test = true
  install = false
}

for t: cxx{**.test...}
{
  d = $directory\201$t\202
  n = $name\201$t\202...

  ./: $d/exe{$n}: $t $d/hxx{+$n} $d/testscript{+$n}
  $d/exe{$n}: libue{hello}: bin.whole = false
}

cxx.poptions =+ "-I$out_root" "-I$src_root")RP(

  )0 P(The basic idea behind this unit testing arrange)HY(ment)YH( is to keep unit tests
  next to the source code files that they test and auto)HY(mat)HY(i)HY(cally)YH( recog)HY(nize)YH( and
  build them into test executa)HY(bles)YH( without having to manu)HY(ally)YH( list each in the
  )SM(build)HY(file)YH()ES(. Specif)HY(i)HY(cally)YH(, if we have )SM(hello.hxx)ES( and
  )SM(hello.cxx)ES(, then to add a unit test for this module all we have
  to do is drop the )SM(hello.test.cxx)ES( source file next to them and
  it will be auto)HY(mat)HY(i)HY(cally)YH( picked up, built into an executable, and run during
  the )SM(test)ES( oper)HY(a)HY(tion)YH(.)EP(

  )0 P(As an example, let's say we've renamed )SM(hello.cxx)ES( to
  )SM(main.cxx)ES( and factored the print)HY(ing)YH( code into the
  )SM(hello.hxx/hello.cxx)ES( module that we would like to unit-test.
  Here is the new layout:)EP(

  ) 10 22 PR(hello/
|-- build
|   \267-- ...
|-- hello
|   |-- hello.cxx
|   |-- hello.hxx
|   |-- hello.test.cxx
|   |-- main.cxx
|   \267-- buildfile
\267-- ...)RP(

  )0 P(Let's examine how this support is imple)HY(mented)YH( in our
  )SM(build)HY(file)YH()ES(, line by line. Because now we link
  )SM(hello.cxx)ES( object code into multi)HY(ple)YH( executa)HY(bles)YH( \201unit tests and
  the )SM(hello)ES( program itself\202, we have to place it into a
  )I(utility library)ES(. This is what the first line does \201it has to
  explic)HY(itly)YH( list )SM(exe{hello})ES( as a prereq)HY(ui)HY(site)YH( of the default
  targets since we now have multi)HY(ple)YH( targets that should be built by
  default\202:)EP(

  ) 1 55 PR(./: exe{hello}: libue{hello}: {hxx cxx}{** -**.test...})RP(

  )0 P(A utility library \201)SM()BD(u)ES()ES( in )SM(lib)BD(u)ES(e)ES(\202 is
  a static library that is built for a specific type of a )I(primary
  target)ES( \201)SM()BD(e)ES()ES( in )SM(libu)BD(e)ES()ES( for
  executable\202. If we were build)HY(ing)YH( a utility library for a library then we
  would have used the )SM(libul{})ES( target type instead. In fact, this
  would be the only differ)HY(ence)YH( in the above unit testing imple)HY(men)HY(ta)HY(tion)YH( if it
  were for a library project instead of an executable:)EP(

  ) 14 55 PR(./: lib{hello}: libul{hello}: {hxx cxx}{** -**.test...}

...

# Unit tests.
#
...

for t: cxx{**.test...}
{
  ...

  $d/exe{$n}: libul{hello}: bin.whole = false
})RP(

  )0 P(Going back to the first three lines of the executable
  )SM(build)HY(file)YH()ES(, notice that we had to exclude source files in the
  )SM(*.test.cxx)ES( form from the utility library. This makes sense
  since we don't want unit testing code \201each with its own
  )SM(main\201\202)ES(\202 to end up in the utility library.)EP(

  )0 P(The exclu)HY(sion)YH( pattern, )SM(-**.test...)ES(, looks a bit cryptic.
  What we have here is a second-level exten)HY(sion)YH( \201)SM(.test)ES(\202 which we
  use to clas)HY(sify)YH( our source files as belong)HY(ing)YH( to unit tests. Because it is a
  second-level exten)HY(sion)YH(, we have to indi)HY(cate)YH( this fact to the pattern
  match)HY(ing)YH( machin)HY(ery)YH( with the trail)HY(ing)YH( triple dot \201meaning "there are more
  exten)HY(sions)YH( coming"\202. If we didn't do that, )SM(.test)ES( would have
  been treated as a first-level exten)HY(sion)YH( explic)HY(itly)YH( spec)HY(i)HY(fied)YH( for our source
  files \201see )0 27 1 A(Target Types)27 0 TN TL()Ec /AF f D( for details\202.)EP(

  )0 P(The next couple of lines set target type/pattern-specific vari)HY(ables)YH( to
  treat all unit test executa)HY(bles)YH( as tests that should not be installed:)EP(

  ) 5 17 PR(exe{*.test}:
{
  test = true
  install = false
})RP(

  )BR(
  )0 P(You may be wonder)HY(ing)YH( why we had to escape the second-level
  )SM(.test)ES( exten)HY(sion)YH( in the name pattern above but not here. The
  answer is that these are differ)HY(ent)YH( kinds of patterns in differ)HY(ent)YH( contexts.
  In partic)HY(u)HY(lar)YH(, patterns in the target type/pattern-specific vari)HY(ables)YH( are
  only matched against target names without regard for exten)HY(sions)YH(. See )0 160 1 A(Name Patterns)160 0 TN TL()Ec /AF f D( for details.)EP(
  )BR(

  )0 P(Then we have the )SM(for)ES(-loop that declares an executable target
  for each unit test source file. The list of these files is gener)HY(ated)YH( with a
  name pattern that is the inverse of what we've used for the utility
  library:)EP(

  ) 8 51 PR(for t: cxx{**.test...}
{
  d = $directory\201$t\202
  n = $name\201$t\202...

  ./: $d/exe{$n}: $t $d/hxx{+$n} $d/testscript{+$n}
  $d/exe{$n}: libue{hello}: bin.whole = false
})RP(

  )0 P(In the loop body we first split the test source file into the direc)HY(tory)YH(
  \201remem)HY(ber)YH(, we can have sources, includ)HY(ing)YH( tests, in subdi)HY(rec)HY(to)HY(ries)YH(\202 and name
  \201which contains the )SM(.test)ES( second-level exten)HY(sion)YH( and which we
  imme)HY(di)HY(ately)YH( escape with )SM(...)ES(\202. And then we use these compo)HY(nents)YH(
  to declare a depen)HY(dency)YH( for the corre)HY(spond)HY(ing)YH( unit test executable. There is
  nothing here that we haven't already seen except for using vari)HY(able)YH(
  expan)HY(sions)YH( instead of literal names.)EP(

  )0 P(By default utility libraries are linked in the "whole archive" mode where
  every object file from the static library ends up in the result)HY(ing)YH(
  executable or library. This behav)HY(ior)YH( is what we want when linking the
  primary target but can normally be relaxed for unit tests to speed up
  linking. This is what the last line in the loop does using the
  )SM(bin.whole)ES( prereq)HY(ui)HY(site)YH(-specific vari)HY(able)YH(.)EP(

  )BR(
  )0 P(You can easily customize this and other aspects on a test-by-test basis
  by exclud)HY(ing)YH( the specific test\201s\202 from the loop and then provid)HY(ing)YH( a custom
  imple)HY(men)HY(ta)HY(tion)YH(. For example:)EP(

  ) 6 59 PR(for t: cxx{**.test... -special.test...}
{
  ...
}

./: exe{special.test...}: cxx{special.test...} libue{hello})RP(

  )0 P(Note also that if you plan to link any of your unit tests in the whole
  archive mode, then you will also need to exclude the source file contain)HY(ing)YH(
  the primary executable's )SM(main\201\202)ES( from the utility library. For
  example:)EP(

  ) 2 45 PR(./: exe{hello}: cxx{main} libue{hello}
libue{hello}: {hxx cxx}{** -main -**.test...})RP(
  )BR(

  )0 2 19 H(1.10)WB 230 Sn()WB 21 Sn( Diag)HY(nos)HY(tics)YH( and Debug)HY(ging)YH()EH(

  )0 P(Sooner or later we will run into a situ)HY(a)HY(tion)YH( where our
  )SM(build)HY(files)YH()ES( don't do what we expect them to. In this section we
  examine a number of tech)HY(niques)YH( and mech)HY(a)HY(nisms)YH( that can help us under)HY(stand)YH(
  the cause of a misbe)HY(hav)HY(ing)YH( build.)EP(

  )0 P(To perform a build the build system goes through several phases. During
  the )I(load)ES( phase the )SM(build)HY(files)YH()ES( are loaded and processed.
  The result of this phase is the in-memory )I(build state)ES( that contains
  the scopes, targets, vari)HY(ables)YH(, etc., defined by the
  )SM(build)HY(files)YH()ES(. Next is the )I(match)ES( phase during which rules
  are matched to the targets that need to be built, recur)HY(sively)YH(. Finally,
  during the )I(execute)ES( phase the matched rules are executed to perform
  the build.)EP(

  )0 P(The load phase is always serial and stops at the first error. In
  contrast, by default, both match and execute are paral)HY(lel)YH( and continue in
  the pres)HY(ence)YH( of errors \201similar to the "keep going" )SM(make)ES( mode\202.
  While bene)HY(fi)HY(cial)YH( in normal circum)HY(stances)YH(, during debug)HY(ging)YH( this can lead to
  both inter)HY(leaved)YH( output that is hard to corre)HY(late)YH( as well as extra noise
  from cascad)HY(ing)YH( errors. As a result, for debug)HY(ging)YH(, it is usually helpful to
  run seri)HY(ally)YH( and stop at the first error, which can be achieved with the
  )SM(--serial-stop|-s)ES( option.)EP(

  )BR(
  )0 P(The match phase can be temporar)HY(ily)YH( switched to either \201serial\202 load or
  \201paral)HY(lel)YH(\202 execute. The former is used, for example, to load addi)HY(tional)YH(
  )SM(build)HY(files)YH()ES( during the )SM(dir{})ES( prereq)HY(ui)HY(site)YH( to target
  reso)HY(lu)HY(tion)YH(, as described in )0 6 1 A(Output Direc)HY(to)HY(ries)YH(
  and Scopes)6 0 TN TL()Ec /AF f D(. While the latter is used to update gener)HY(ated)YH( source code
  \201such as headers\202 that is required to complete the match.)EP(
  )BR(

  )0 P(Debug)HY(ging)YH( issues in each phase requires differ)HY(ent)YH( tech)HY(niques)YH(. Let's start
  with the load phase. As mentioned in )0 15 1 A(Build)HY(file)YH(
  Language)15 0 TN TL()Ec /AF f D(, )SM(build)HY(files)YH()ES( are processed linearly with direc)HY(tives)YH(
  executed and vari)HY(ables)YH( expanded as they are encoun)HY(tered)YH(. As we have already
  seen, to print a vari)HY(able)YH( value we can use the )SM(info)ES( direc)HY(tive)YH(.
  For example:)EP(

  ) 2 7 PR(x = X
info $x)RP(

  )0 P(This will print some)HY(thing)YH( along these lines:)EP(

  ) 1 22 PR(buildfile:2:1: info: X)RP(

  )0 P(Or, if we want to clearly see where the value begins and ends \201useful
  when inves)HY(ti)HY(gat)HY(ing)YH( whites)HY(pace)YH(-related issues\202:)EP(

  ) 2 11 PR(x = " X "
info "'$x'")RP(

  )0 P(Which prints:)EP(

  ) 1 26 PR(buildfile:2:1: info: ' X ')RP(

  )0 P(Besides the )SM(info)ES( direc)HY(tive)YH(, there are also
  )SM(text)ES(, which doesn't print the )SM(info:)ES( prefix,
  )SM(warn)ES(, which prints a warning, as well as )SM(fail)ES(
  which prints an error and causes the build system to exit with an error.
  Here is an example of using each:)EP(

  ) 4 41 PR(text 'note: we are about to get an error'
warn 'the error is imminent'
fail 'this is the end'
info 'we will never get here')RP(

  )0 P(This will produce the follow)HY(ing)YH( output:)EP(

  ) 3 49 PR(buildfile:1:1: note: we are about to get an error
buildfile:2:1: warning: the error is imminent
buildfile:3:1: error: this is the end)RP(

  )0 P(If you find your)HY(self)YH( writing code like this:)EP(

  ) 2 35 PR(if \201$cxx.target.class == 'windows'\202
  fail 'Windows is not supported')RP(

  )0 P(Then the )SM(assert)ES( direc)HY(tive)YH( is a more concise way to express
  the same:)EP(

  ) 1 66 PR(assert \201$cxx.target.class != 'windows'\202 'Windows is not supported')RP(

  )0 P(The assert condi)HY(tion)YH( must be an expres)HY(sion)YH( that eval)HY(u)HY(ates)YH( to
  )SM(true)ES( or )SM(false)ES(, similar to the )SM(if)ES(
  direc)HY(tive)YH( \201see )0 17 1 A(Condi)HY(tions)YH(
  \201)SM(if-else)ES(\202)17 0 TN TL()Ec /AF f D( for details\202. The descrip)HY(tion)YH( after the condi)HY(tion)YH(
  is optional and, similar to )SM(if)ES(, there is also the
  )SM(assert!)ES( variant, which fails if the condi)HY(tion)YH( is
  )SM(true)ES(.)EP(

  )0 P(All the diag)HY(nos)HY(tics)YH( direc)HY(tives)YH( write to )SM(stderr)ES(. If instead
  we need to write some)HY(thing)YH( to )SM(stdout)ES( to, for example, send some
  infor)HY(ma)HY(tion)YH( back to our caller, then we can use the )SM(print)ES(
  direc)HY(tive)YH(. For example, this will print the C++ compiler id and its
  target:)EP(

  ) 1 27 PR(print "$cxx.id $cxx.target")RP(

  )BR(
  )0 P(To query the value of a target-specific vari)HY(able)YH( we use the qual)HY(i)HY(fied)YH(
  name syntax \201the )SM(eval-qual)ES( produc)HY(tion)YH(\202 of eval context, for
  example:)EP(

  ) 2 33 PR(obj{main}: cxx.poptions += -DMAIN
info $\201obj{main}: cxx.poptions\202)RP(

  )0 P(There is no direct way to query the value of a prereq)HY(ui)HY(site)YH(-specific
  vari)HY(able)YH( since a prereq)HY(ui)HY(site)YH( has no iden)HY(tity)YH(. Instead, we can use the
  )SM(dump)ES( direc)HY(tive)YH( discussed next to print the entire depen)HY(dency)YH(
  decla)HY(ra)HY(tion)YH(, includ)HY(ing)YH( prereq)HY(ui)HY(site)YH(-specific vari)HY(ables)YH( for each
  prereq)HY(ui)HY(site)YH(.)EP(
  )BR(

  )0 P(While print)HY(ing)YH( vari)HY(able)YH( values is the most common mech)HY(a)HY(nism)YH( for
  diag)HY(nos)HY(ing)YH( )SM(build)HY(file)YH()ES( issues, some)HY(times)YH( it is also helpful to
  examine targets and scopes. For that we use the )SM(dump)ES(
  direc)HY(tive)YH(.)EP(

  )0 P(Without any argu)HY(ments)YH(, )SM(dump)ES( prints \201to )SM(stderr)ES(\202
  the contents of the scope it was encoun)HY(tered)YH( in and at that point of
  process)HY(ing)YH( the )SM(build)HY(file)YH()ES(. Its output includes vari)HY(ables)YH(,
  targets and their prereq)HY(ui)HY(sites)YH(, as well as nested scopes, recur)HY(sively)YH(. As
  an example, let's print the source subdi)HY(rec)HY(tory)YH( scope of our
  )SM(hello)ES( executable project. Here is its )SM(build)HY(file)YH()ES(
  with the )SM(dump)ES( direc)HY(tive)YH( at the end:)EP(

  ) 5 43 PR(exe{hello}: {hxx cxx}{**}

cxx.poptions =+ "-I$out_root" "-I$src_root"

dump)RP(

  )0 P(This will produce the output along these lines:)EP(

  ) 11 54 PR(buildfile:5:1: dump:
  /tmp/hello/hello/
  {
    [strings] cxx.poptions = -I/tmp/hello -I/tmp/hello
    [dir_path] out_base = /tmp/hello/hello/
    [dir_path] src_base = /tmp/hello/hello/

    buildfile{buildfile.}:

    exe{hello.?}: cxx{hello.?}
  })RP(

  )BR(
  )0 P(The ques)HY(tion)YH( marks \201)SM(?)ES(\202 in the depen)HY(dency)YH( decla)HY(ra)HY(tion)YH( mean
  that the file exten)HY(sions)YH( haven't been assigned yet, which happens during the
  match phase.)EP(
  )BR(

  )0 P(Instead of print)HY(ing)YH( the entire scope, we can also print indi)HY(vid)HY(ual)YH(
  targets by spec)HY(i)HY(fy)HY(ing)YH( one or more target names in )SM(dump)ES(. To make
  things more inter)HY(est)HY(ing)YH(, let's convert our )SM(hello)ES( project to use
  a utility library, similar to the unit testing setup \201)0 20 1 A(Imple)HY(ment)HY(ing)YH( Unit Testing)20 0 TN TL()Ec /AF f D(\202. We will also link to
  the )SM(dl)ES( library to see an example of a target-specific vari)HY(able)YH(
  being dumped:)EP(

  ) 5 43 PR(exe{hello}: libue{hello}: bin.whole = false
exe{hello}: cxx.libs += -ldl
libue{hello}: {hxx cxx}{**}

dump exe{hello})RP(

  )0 P(The output will look along these lines:)EP(

  ) 9 66 PR(buildfile:5:1: dump:
  /tmp/hello/hello/exe{hello.?}:
  {
    [strings] cxx.libs = -ldl
  }
  /tmp/hello/hello/exe{hello.?}: /tmp/hello/hello/:libue{hello.?}:
  {
    [bool] bin.whole = false
  })RP(

  )0 P(The output of )SM(dump)ES( might look famil)HY(iar)YH(: in )0 6 1 A(Output Direc)HY(to)HY(ries)YH( and Scopes)6 0 TN TL()Ec /AF f D( we've used the
  )SM(--dump)ES( option to print the entire build state, which looks
  pretty similar. In fact, the )SM(dump)ES( direc)HY(tive)YH( uses the same
  mech)HY(a)HY(nism)YH( but allows us to print indi)HY(vid)HY(ual)YH( scopes and targets from within a
  )SM(build)HY(file)YH()ES(.)EP(

  )0 P(There is, however, an impor)HY(tant)YH( differ)HY(ence)YH( to keep in mind:
  )SM(dump)ES( prints the state of a target or scope at the point in the
  )SM(build)HY(file)YH()ES( load phase where it was executed. In contrast, the
  )SM(--dump)ES( option can be used to print the state after the load
  phase \201)SM(--dump load)ES(\202 and/or after the match phase \201)SM(--dump
  match)ES(\202. In partic)HY(u)HY(lar)YH(, the after match print)HY(out)YH( reflects the changes
  to the build state made by the match)HY(ing)YH( rules, which may include enter)HY(ing)YH( of
  addi)HY(tional)YH( depen)HY(den)HY(cies)YH(, setting of addi)HY(tional)YH( vari)HY(ables)YH(, reso)HY(lu)HY(tion)YH( of
  prereq)HY(ui)HY(sites)YH( to targets, assign)HY(ment)YH( of file exten)HY(sions)YH(, etc. As a result,
  while the )SM(dump)ES( direc)HY(tive)YH( should be suffi)HY(cient)YH( in most cases,
  some)HY(times)YH( you may need to use the )SM(--dump)ES( option to examine the
  build state just before rule execu)HY(tion)YH(.)EP(

  )BR(
  )0 P(It is possi)HY(ble)YH( to limit the output of )SM(--dump)ES( to specific
  scopes and/or targets with the )SM(--dump-scope)ES( and
  )SM(--dump-target)ES( options.)EP(
  )BR(

  )0 P(Let's now move from state to behav)HY(ior)YH(. As we already know, to see the
  under)HY(ly)HY(ing)YH( commands executed by the build system we use the )SM(-v)ES(
  options \201which is equiv)HY(a)HY(lent)YH( to )SM(--verbose\2402)ES(\202. Note,
  however, that these are )I(logical)ES( rather than actual commands. You can
  still run them and they should produce the desired result, but in reality
  the build system may have achieved the same result in a differ)HY(ent)YH( way. To
  see the actual commands we use the )SM(-V)ES( option instead
  \201equiv)HY(a)HY(lent)YH( to )SM(--verbose\2403)ES(\202. Let's see the differ)HY(ence)YH( in
  an example. Here is what build)HY(ing)YH( our )SM(hello)ES( executable with
  )SM(-v)ES( might look like:)EP(

  ) 3 27 PR($ b -s -v
g++ -o hello.o -c hello.cxx
g++ -o hello hello.o)RP(

  )0 P(And here is the same build with )SM(-V)ES(:)EP(

  ) 5 66 PR($ b -s -V
g++ -MD -E -fdirectives-only -MF hello.o.t -o hello.o.ii hello.cxx
g++ -E -fpreprocessed -fdirectives-only hello.o.ii
g++ -o hello.o -c -fdirectives-only hello.o.ii
g++ -o hello hello.o)RP(

  )0 P(From the second listing we can see that in reality )SM(build2)ES(
  first partially prepro)HY(cessed)YH( )SM(hello.cxx)ES( while extract)HY(ing)YH( its
  header depen)HY(dency)YH( infor)HY(ma)HY(tion)YH(. It then prepro)HY(cessed)YH( it fully, which is used
  to extract module depen)HY(dency)YH( infor)HY(ma)HY(tion)YH(, calcu)HY(late)YH( the check)HY(sum)YH( for
  ignor)HY(able)YH( change detec)HY(tion)YH(, etc.  When it comes to produc)HY(ing)YH(
  )SM(hello.o)ES(, the build system compiled the partially prepro)HY(cessed)YH(
  output rather than the orig)HY(i)HY(nal)YH( )SM(hello.cxx)ES(. The end result,
  however, is the same as in the first listing.)EP(

  )0 P(Verbosity level )SM(3)ES( \201)SM(-V)ES(\202 also trig)HY(gers)YH( print)HY(ing)YH(
  of the build system module config)HY(u)HY(ra)HY(tion)YH( infor)HY(ma)HY(tion)YH(. Here is what we would
  see for the )SM(cxx)ES( module:)EP(

  ) 15 67 PR(cxx hello@/tmp/hello/
  cxx        g++@/usr/bin/g++
  id         gcc
  version    7.2.0 \201Ubuntu 7.2.0-1ubuntu1~16.04\202
  major      7
  minor      2
  patch      0
  build      \201Ubuntu 7.2.0-1ubuntu1~16.04\202
  signature  gcc version 7.2.0 \201Ubuntu 7.2.0-1ubuntu1~16.04\202
  checksum   09b3b59d337eb9a760dd028fa0df585b307e6a49c2bfa00b3[...]
  target     x86_64-linux-gnu
  runtime    libgcc
  stdlib     libstdc++
  c stdlib   glibc
...)RP(

  )0 P(Verbosity levels higher than )SM(3)ES( enable build system tracing.
  In partic)HY(u)HY(lar)YH(, level )SM(4)ES( is useful for under)HY(stand)HY(ing)YH( why a rule
  doesn't match a target or if it does, why it deter)HY(mined)YH( the target to be out
  of date. For example, assum)HY(ing)YH( we have an up-to-date build of our
  )SM(hello)ES(, let's change a compile option:)EP(

  ) 7 64 PR($ b -s --verbose 4
info: /tmp/hello/dir{hello/} is up to date

$ b -s --verbose 4 config.cxx.poptions+=-DNDEBUG
trace: cxx::compile_rule::apply: options mismatch forcing update
of /tmp/hello/hello/obje{hello.o}
...)RP(

  )0 P(Higher verbosity levels result in more and more tracing state)HY(ments)YH( being
  printed. These include )SM(build)HY(file)YH()ES( loading and parsing,
  prereq)HY(ui)HY(site)YH( to target reso)HY(lu)HY(tion)YH(, as well as build system module and
  rule-specific logic.)EP(

  )0 P(While the tracing state)HY(ments)YH( can be helpful in under)HY(stand)HY(ing)YH( what is
  happen)HY(ing)YH(, they don't make it easy to see why things are happen)HY(ing)YH( a certain
  way. In partic)HY(u)HY(lar)YH(, one ques)HY(tion)YH( that is often encoun)HY(tered)YH( during build
  trou)HY(bleshoot)HY(ing)YH( is which depen)HY(dency)YH( chain causes match)HY(ing)YH( or execu)HY(tion)YH( of a
  partic)HY(u)HY(lar)YH( target. These ques)HY(tions)YH( can be answered with the help of the
  )SM(--trace-match)ES( and )SM(--trace-execute)ES( options. For
  example, if we want to under)HY(stand)YH( what causes the update of
  )SM(obje{hello})ES( in the )SM(hello)ES( project above:)EP(

  ) 7 41 PR($ b -s --trace-execute 'obje{hello}'
info: updating hello/obje{hello}
  info: using rule cxx.compile
  info: while updating hello/libue{hello}
  info: while updating hello/exe{hello}
  info: while updating dir{hello/}
  info: while updating dir{./})RP(

  )0 P(Another useful diag)HY(nos)HY(tics)YH( option is )SM(--mtime-check)ES(. When
  spec)HY(i)HY(fied)YH(, the build system performs a number of file modi)HY(fi)HY(ca)HY(tion)YH( time
  sanity checks that can be helpful in diag)HY(nos)HY(ing)YH( spuri)HY(ous)YH( rebuilds.)EP(

  )0 P(If neither state dumps nor behav)HY(ior)YH( anal)HY(y)HY(sis)YH( are suffi)HY(cient)YH( to under)HY(stand)YH(
  the problem, there is always an option of running the build system under a
  C++ debug)HY(ger)YH( in order to better under)HY(stand)YH( what's going on. This can be
  partic)HY(u)HY(larly)YH( produc)HY(tive)YH( for debug)HY(ging)YH( complex rules.)EP(

  )0 P(Finally, to help with diag)HY(nos)HY(ing)YH( the build system perfor)HY(mance)YH( issues,
  there is the )SM(--stat)ES( option. It causes )SM(build2)ES( to
  print various execu)HY(tion)YH( statis)HY(tics)YH( which can be useful for pin-point)HY(ing)YH( the
  bottle)HY(necks)YH(. There are also a number of options for tuning the build
  system's perfor)HY(mance)YH(, such as, the number of jobs to perform in paral)HY(lel)YH(,
  the stack size, queue depths, etc. See the )0 2 A()SM()BD(b\2011\202)ES()ES()EA( man pages for details.)EP(

  )0 1 20 H(2)WB 231 Sn()WB 22 Sn( Project Config)HY(u)HY(ra)HY(tion)YH()EH(

  )0 P(As discussed in the intro)HY(duc)HY(tion)YH( \201specif)HY(i)HY(cally)YH(, )0 5 1 A(Project Struc)HY(ture)YH()5 0 TN TL()Ec /AF f D(\202 support for build
  config)HY(u)HY(ra)HY(tions)YH( is an inte)HY(gral)YH( part of )SM(build2)ES( with the same
  mech)HY(a)HY(nism)YH( used by the build system core \201for example, for project
  impor)HY(ta)HY(tion)YH( via the )SM(config.import.*)ES( vari)HY(ables)YH(\202, by the build
  system modules \201for example, for supply)HY(ing)YH( compile options such as
  )SM(config.cxx.coptions)ES(\202, as well as by our projects to provide any
  project-specific config)HY(ura)HY(bil)HY(ity)YH(. Project config)HY(u)HY(ra)HY(tion)YH( is the topic of this
  chapter.)EP(

  )BR(
  )0 P(The )SM(build2)ES( build system currently provides no support for
  )SM(auto)HY(conf)YH()ES(-style probing of the build envi)HY(ron)HY(ment)YH( in order to
  auto)HY(mat)HY(i)HY(cally)YH( discover avail)HY(able)YH( libraries, func)HY(tions)YH(, features, etc.)EP(

  )0 P(The main reason for omit)HY(ting)YH( this support is the funda)HY(men)HY(tal)YH( ambi)HY(gu)HY(ity)YH(
  and the result)HY(ing)YH( brit)HY(tle)HY(ness)YH( of such probing due to the reliance on
  compiler, linker, or test execu)HY(tion)YH( fail)HY(ures)YH(. Specif)HY(i)HY(cally)YH(, in many such
  tests it is impos)HY(si)HY(ble)YH( for a build system to distin)HY(guish)YH( between a missing
  feature, a broken test, and a miscon)HY(fig)HY(ured)YH( build envi)HY(ron)HY(ment)YH(. This leads to
  requir)HY(ing)YH( a user inter)HY(ven)HY(tion)YH( in the best case and to a silently
  miscon)HY(fig)HY(ured)YH( build in the worst. Other issues with this approach include
  porta)HY(bil)HY(ity)YH(, speed \201compil)HY(ing)YH( and linking takes time\202, as well as limited
  appli)HY(ca)HY(bil)HY(ity)YH( during cross-compi)HY(la)HY(tion)YH( \201specif)HY(i)HY(cally)YH(, inabil)HY(ity)YH( to run
  tests\202.)EP(

  )0 P(As a result, we recom)HY(mend)YH( using )I(expec)HY(ta)HY(tion)YH(-based)ES( config)HY(u)HY(ra)HY(tion)YH(
  where your project assumes a feature to be avail)HY(able)YH( if certain condi)HY(tions)YH(
  are met. Exam)HY(ples)YH( of such condi)HY(tions)YH( at the source code level include
  feature test macros, plat)HY(form)YH( macros, runtime library macros, compiler
  macros, etc., with the build system modules expos)HY(ing)YH( some of the same
  infor)HY(ma)HY(tion)YH( via vari)HY(ables)YH( to allow making similar deci)HY(sions)YH( in
  )SM(build)HY(files)YH()ES(. The stan)HY(dard)YH( pre-installed )R2 2 A()SM(auto)HY(conf)YH()ES()EA(
  build system module provides emula)HY(tion)YH( of GNU )SM(auto)HY(conf)YH()ES( using
  this approach.)EP(

  )0 P(Another alter)HY(na)HY(tive)YH( is to auto)HY(mat)HY(i)HY(cally)YH( adapt to missing features using
  more advanced tech)HY(niques)YH( such as C++ SFINAE. And in situ)HY(a)HY(tions)YH( where none of
  this is possi)HY(ble)YH(, we recom)HY(mend)YH( dele)HY(gat)HY(ing)YH( the deci)HY(sion)YH( to the user via a
  config)HY(u)HY(ra)HY(tion)YH( value.  Our expe)HY(ri)HY(ence)YH( with )SM(build2)ES( as well as
  those of other large cross-plat)HY(form)YH( projects such as Boost show that this is
  a viable strat)HY(egy)YH(.)EP(

  )0 P(Having said that, )SM(build2)ES( does provide the ability to extract
  config)HY(u)HY(ra)HY(tion)YH( infor)HY(ma)HY(tion)YH( from the envi)HY(ron)HY(ment)YH( \201)SM($getenv\201\202)ES(
  func)HY(tion)YH(\202 or other tools \201)SM($process.run*\201\202)ES( family of func)HY(tions)YH(\202.
  Note, however, that for this to work reli)HY(ably)YH( there should be no ambi)HY(gu)HY(ity)YH(
  between the "no config)HY(u)HY(ra)HY(tion)YH( avail)HY(able)YH(" case \201if such a case is possi)HY(ble)YH(\202
  and the "some)HY(thing)YH( went wrong" case. We show a real)HY(is)HY(tic)YH( example of this in
  )0 24 1 A(Config)HY(u)HY(ra)HY(tion)YH( Report)24 0 TN TL()Ec /AF f D( where we extract the
  GCC plugin direc)HY(tory)YH( while dealing with the possi)HY(bil)HY(ity)YH( of it being
  config)HY(ured)YH( without plugin support.)EP(
  )BR(

  )0 P(Before we delve into the tech)HY(ni)HY(cal)YH( details, let's discuss the overall
  need for project config)HY(ura)HY(bil)HY(ity)YH(. While it may seem that making one's
  project more user-config)HY(urable)YH( is always a good idea, there are costs: by
  having a choice we increase the complex)HY(ity)YH( and open the door for poten)HY(tial)YH(
  incom)HY(pat)HY(i)HY(bil)HY(ity)YH(. Specif)HY(i)HY(cally)YH(, we may end up with two projects in the same
  build needing a shared depen)HY(dency)YH( with incom)HY(pat)HY(i)HY(ble)YH( config)HY(u)HY(ra)HY(tions)YH(.)EP(

  )BR(
  )0 P(While some languages, such as Rust, support having multi)HY(ple)YH(
  differ)HY(ently)YH(-config)HY(ured)YH( projects in the same build, this is not some)HY(thing)YH(
  that is done often in C/C++. This ability is also not without its draw)HY(backs)YH(,
  most notably code bloat.)EP(
  )BR(

  )0 P(As a result, our recom)HY(men)HY(da)HY(tion)YH( is to strive for simplic)HY(ity)YH( and avoid
  user config)HY(ura)HY(bil)HY(ity)YH( when)HY(ever)YH( possi)HY(ble)YH(. For example, there is a common
  desire to make certain func)HY(tion)HY(al)HY(ity)YH( optional in order not to make the user
  pay for things they don't need. This, however, is often better addressed
  either by always provid)HY(ing)YH( the optional func)HY(tion)HY(al)HY(ity)YH( if it's fairly small
  or by factor)HY(ing)YH( it into a sepa)HY(rate)YH( project if it's substan)HY(tial)YH(. If a
  config)HY(u)HY(ra)HY(tion)YH( value is to be provided, it should have a sensi)HY(ble)YH( default
  with a bias for simplic)HY(ity)YH( and compat)HY(i)HY(bil)HY(ity)YH( rather than the optimal result.
  For example, in the optional func)HY(tion)HY(al)HY(ity)YH( case, the default should prob)HY(a)HY(bly)YH(
  be to provide it.)EP(

  )0 P(As discussed in the intro)HY(duc)HY(tion)YH(, the central part of the build
  config)HY(u)HY(ra)HY(tion)YH( func)HY(tion)HY(al)HY(ity)YH( are the )I(config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH()ES(. One of
  the key features that make them special is support for auto)HY(matic)YH( persis)HY(tence)YH(
  in the )SM(build/config.build)ES( file provided by the )0 161 1 A()SM(config)ES()161 0 TN TL()Ec /AF f D( module \201see )0 8 1 A(Config)HY(ur)HY(ing)YH()8 0 TN TL()Ec /AF f D( for details\202.)EP(

  )BR(
  )0 P(Another mech)HY(a)HY(nism)YH( that can be used for project config)HY(u)HY(ra)HY(tion)YH( is
  envi)HY(ron)HY(ment)YH( vari)HY(ables)YH(. While not recom)HY(mended)YH(, some)HY(times)YH( it may be forced on
  us by exter)HY(nal)YH( factors. In such cases, envi)HY(ron)HY(ment)YH( vari)HY(ables)YH( that affect the
  build result should be reported with the )SM(config.envi)HY(ron)HY(ment)YH()ES(
  direc)HY(tive)YH( as discussed in )0 162 1 A(Hermetic Build
  Config)HY(u)HY(ra)HY(tions)YH()162 0 TN TL()Ec /AF f D(.)EP(
  )BR(

  )0 P(The follow)HY(ing)YH( example, based on the )SM(libhello)ES( project from
  the intro)HY(duc)HY(tion)YH(, gives an overview of the project config)HY(u)HY(ra)HY(tion)YH(
  func)HY(tion)HY(al)HY(ity)YH( with the remain)HY(der)YH( of the chapter provid)HY(ing)YH( the detailed
  expla)HY(na)HY(tion)YH( of all the parts shown as well as the alter)HY(na)HY(tive)YH(
  approaches.)EP(

  ) 9 18 PR(libhello/
|-- build/
|   |-- root.build
|   \267-- ...
|-- libhello/
|   |-- hello.cxx
|   |-- buildfile
|   \267-- ...
\267-- ...)RP(

  ) 3 51 PR(# build/root.build

config [string] config.libhello.greeting ?= 'Hello')RP(

  ) 3 67 PR(# libhello/buildfile

cxx.poptions += "-DLIBHELLO_GREETING=\200"$config.libhello.greeting\200"")RP(

  ) 6 50 PR(// libhello/hello.cxx

void say_hello \201ostream& o, const string& n\202
{
  o << LIBHELLO_GREETING ", " << n << '!' << endl;
})RP(

  ) 9 44 PR($ b configure config.libhello.greeting=Hi -v
config libhello@/tmp/libhello/
  greeting   Hi

$ cat build/config.build
config.libhello.greeting = Hi

$ b -v
g++ ... -DLIBHELLO_GREETING="Hi" ...)RP(

  )0 P(By \201enforced\202 conven)HY(tion)YH(, config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( start with
  )SM(config.)ES(, for example, )SM(config.import.libhello)ES(. In
  case of a build system module, the second compo)HY(nent)YH( in its config)HY(u)HY(ra)HY(tion)YH(
  vari)HY(ables)YH( should be the module name, for example, )SM(config.cxx)ES(,
  )SM(config.cxx.coptions)ES(. Simi)HY(larly)YH(, project-specific config)HY(u)HY(ra)HY(tion)YH(
  vari)HY(ables)YH( should have the project name as their second compo)HY(nent)YH(, for
  example, )SM(config.libhello.greet)HY(ing)YH()ES(.)EP(

  )BR(
  )0 P(More precisely, a project config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH( must match the
  )SM(config[.**].<project>.**)ES( pattern where addi)HY(tional)YH( compo)HY(nents)YH(
  may be present after )SM(config.)ES( in case of subpro)HY(jects)YH(. Overall,
  the recom)HY(men)HY(da)HY(tion)YH( is to use hier)HY(ar)HY(chi)HY(cal)YH( names, such as
  )SM(config.libcurl.tests.remote)ES( for subpro)HY(jects)YH(, similar to build
  system submod)HY(ules)YH(.)EP(

  )0 P(If a build system module for a tool \201such as a source code gener)HY(a)HY(tor)YH(\202 and
  the tool itself share a name, then they may need to coor)HY(di)HY(nate)YH( their
  config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH( names in order to avoid clashes. Note also that when
  import)HY(ing)YH( an executable target in the
  )SM(<project>%exe{<project>})ES( form, the
  )SM(config.<project>)ES( vari)HY(able)YH( is treated as an alias for
  )SM(config.import.<project>.<project>.exe)ES(.)EP(

  )0 P(For an imported )SM(build)HY(file)YH()ES(, )SM(<project>)ES( may
  refer to either the import)HY(ing)YH( project or the project from which the said
  )SM(build)HY(file)YH()ES( was imported.)EP(

  )0 P(The build system core reserves )SM(build)ES( and )SM(import)ES(
  as the second compo)HY(nent)YH( in config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( as well as
  )SM(config)HY(ured)YH()ES( as the third and subse)HY(quent)YH( compo)HY(nents)YH(.)EP(
  )BR(

  )0 P(A vari)HY(able)YH( in the )SM(config.<project>.develop)ES( form has
  pre-defined seman)HY(tics)YH(: it allows a project to distin)HY(guish)YH( between
  )I(devel)HY(op)HY(ment)YH()ES( and )I(consump)HY(tion)YH()ES( builds. While normally there is no
  distinc)HY(tion)YH( between these two modes, some)HY(times)YH( a project may need to provide
  addi)HY(tional)YH( func)HY(tion)HY(al)HY(ity)YH( during devel)HY(op)HY(ment)YH(. For example, a source code
  gener)HY(a)HY(tor)YH( which uses its own gener)HY(ated)YH( code in its imple)HY(men)HY(ta)HY(tion)YH( may need
  to provide a boot)HY(strap)YH( step from the pre-gener)HY(ated)YH( code. Normally, such a
  step is only needed during devel)HY(op)HY(ment)YH(.)EP(

  )BR(
  )0 P(While some commu)HY(ni)HY(ties)YH(, such as Rust, believe that build)HY(ing)YH( and running
  tests is only done during devel)HY(op)HY(ment)YH(, we believe its reason)HY(able)YH( for an
  end-user to want to run tests for all their depen)HY(den)HY(cies)YH(. As a result, we
  strongly discour)HY(age)YH( restrict)HY(ing)YH( tests to the devel)HY(op)HY(ment)YH( mode only. Test are
  an inte)HY(gral)YH( part of the project and should always be avail)HY(able)YH(.)EP(
  )BR(

  )0 P(If used, the )SM(config.<project>.develop)ES( vari)HY(able)YH( should be
  explic)HY(itly)YH( defined by the project with the )SM(bool)ES( type and the
  )SM(false)ES( default value. For example:)EP(

  ) 3 46 PR(# build/root.build

config [bool] config.libhello.develop ?= false)RP(

  )BR(
  )0 P(If the )SM(config.<project>.develop)ES( vari)HY(able)YH( is spec)HY(i)HY(fied)YH( by
  the user of the project but the project does not define it \201that is, the
  project does not distin)HY(guish)YH( between devel)HY(op)HY(ment)YH( and consump)HY(tion)YH(\202, then this
  vari)HY(able)YH( is silently ignored. By default )0 2 A()SM()BD(bdep-init\2011\202)ES()ES()EA(
  config)HY(ures)YH( projects being initial)HY(ized)YH( for devel)HY(op)HY(ment)YH(. This can be
  over)HY(rid)HY(den)YH( with explicit )SM(config.<project>.develop=false)ES(.)EP(
  )BR(

  )0 2 21 H(2.1)WB 232 Sn()WB 23 Sn( )SM(config)ES( Direc)HY(tive)YH()EH(

  )0 P(To define a project config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH( we add the )SM(config)ES(
  direc)HY(tive)YH( into the project's )SM(build/root.build)ES( file \201see )0 5 1 A(Project Struc)HY(ture)YH()5 0 TN TL()Ec /AF f D(\202. For example:)EP(

  ) 2 51 PR(config [bool]   config.libhello.fancy    ?= false
config [string] config.libhello.greeting ?= 'Hello')RP(

  )BR(
  )0 P(The irony does not escape us: these config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( are exactly
  of the kind that we advo)HY(cate)YH( against. However, finding a reason)HY(able)YH( example
  of build-time config)HY(ura)HY(bil)HY(ity)YH( in a )I("Hello, World!")ES( library is not
  easy. In fact, it prob)HY(a)HY(bly)YH( shouldn't have any. So, for this chapter, do as
  we say, not as we do.)EP(
  )BR(

  )0 P(Similar to )SM(import)ES( \201see )0 12 1 A(Target
  Impor)HY(ta)HY(tion)YH()12 0 TN TL()Ec /AF f D(\202, the )SM(config)ES( direc)HY(tive)YH( is a special kind of
  vari)HY(able)YH( assign)HY(ment)YH(. Let's examine all its parts in turn.)EP(

  )0 P(First comes the optional list of vari)HY(able)YH( attributes inside
  )SM([\240])ES(. The only attribute that we have in the above example
  is the vari)HY(able)YH( type, )SM(bool)ES( and )SM(string)ES(,
  respec)HY(tively)YH(. It is gener)HY(ally)YH( a good idea to assign static types to
  config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( because their values will be spec)HY(i)HY(fied)YH( by the users
  of our project and the more auto)HY(matic)YH( vali)HY(da)HY(tion)YH( we provide the better \201see
  )0 36 1 A(Vari)HY(ables)YH()36 0 TN TL()Ec /AF f D( for the list of avail)HY(able)YH( types\202. For
  example, this is what will happen if we misspell the value of the
  )SM(fancy)ES( vari)HY(able)YH(:)EP(

  ) 2 66 PR($ b configure config.libhello.fancy=fals
error: invalid bool value 'fals' in variable config.libhello.fancy)RP(

  )0 P(After the attribute list we have the vari)HY(able)YH( name. The
  )SM(config)ES( direc)HY(tive)YH( will vali)HY(date)YH( that it matches the
  )SM(config[.**].<project>.**)ES( pattern \201with one excep)HY(tion)YH(
  discussed in )0 24 1 A(Config)HY(u)HY(ra)HY(tion)YH( Report)24 0 TN TL()Ec /AF f D(\202.)EP(

  )0 P(Finally, after the vari)HY(able)YH( name comes the optional default value. Note
  that unlike normal vari)HY(ables)YH(, the default value assign)HY(ment)YH( \201)SM(?=)ES(\202
  is the only valid form of assign)HY(ment)YH( in the )SM(config)ES(
  direc)HY(tive)YH(.)EP(

  )0 P(The seman)HY(tics)YH( of the )SM(config)ES( direc)HY(tive)YH( is as follows: First
  an over)HY(rid)HY(able)YH( vari)HY(able)YH( is entered with the spec)HY(i)HY(fied)YH( name, type \201if any\202,
  and global visi)HY(bil)HY(ity)YH(. Then, if the vari)HY(able)YH( is unde)HY(fined)YH( and the default
  value is spec)HY(i)HY(fied)YH(, it is assigned the default value. After this, if the
  vari)HY(able)YH( is defined \201either as user-defined or default\202, it is marked for
  persis)HY(tence)YH(. Finally, a defined vari)HY(able)YH( is also marked for report)HY(ing)YH( as
  discussed in )0 24 1 A(Config)HY(u)HY(ra)HY(tion)YH( Report)24 0 TN TL()Ec /AF f D(. Note
  that if the vari)HY(able)YH( is user-defined, then the default value is not
  eval)HY(u)HY(ated)YH(.)EP(

  )0 P(Note also that if the config)HY(u)HY(ra)HY(tion)YH( value is not spec)HY(i)HY(fied)YH( by the user
  and you haven't provided the default, the vari)HY(able)YH( will be unde)HY(fined)YH(, not
  )SM(null)ES(, and, as a result, omitted from the persis)HY(tent)YH(
  config)HY(u)HY(ra)HY(tion)YH( \201)SM(build/config.build)ES( file\202. In fact, unlike other
  vari)HY(ables)YH(, project config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( are by default not
  )I(nullable)ES(. For example:)EP(

  ) 2 64 PR($ b configure config.libhello.fancy=[null]
error: null value in non-nullable variable config.libhello.fancy)RP(

  )0 P(There are two ways to make )SM(null)ES( a valid value of a project
  config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH(. Firstly, if the default value is )SM(null)ES(,
  then natu)HY(rally)YH( the vari)HY(able)YH( is assumed nullable. This is tradi)HY(tion)HY(ally)YH( used
  for )I(optional)ES( config)HY(u)HY(ra)HY(tion)YH( values. For example:)EP(

  ) 1 55 PR(config [string] config.libhello.fallback_name ?= [null])RP(

  )0 P(If we need a nullable config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH( but with a
  non-)SM(null)ES( default value \201or no default value at all\202, then we
  have to use the )SM(null)ES( vari)HY(able)YH( attribute. For example:)EP(

  ) 1 62 PR(config [string, null] config.libhello.fallback_name ?= "World")RP(

  )0 P(A common approach for repre)HY(sent)HY(ing)YH( an C/C++ enum-like value is to use
  )SM(string)ES( as a type and pattern match)HY(ing)YH( for vali)HY(da)HY(tion)YH(. In fact,
  vali)HY(da)HY(tion)YH( and prop)HY(a)HY(ga)HY(tion)YH( can often be combined. For example, if our
  library needed to use a database for some reason, we could handle it like
  this:)EP(

  ) 24 50 PR(config [string] config.libhello.database ?= [null]

using cxx

switch $config.libhello.database
{
  case [null]
  {
    # No database in use.
  }
  case 'sqlite'
  {
    cxx.poptions += -DLIBHELLO_WITH_SQLITE
  }
  case 'pgsql'
  {
    cxx.poptions += -DLIBHELLO_WITH_PGSQL
  }
  default
  {
    fail "invalid config.libhello.database value \200
'$config.libhello.database'"
  }
})RP(

  )0 P(While it is gener)HY(ally)YH( a good idea to provide a sensi)HY(ble)YH( default for all
  your config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH(, if you need to force the user to specify its
  value explic)HY(itly)YH(, this can be achieved with an extra check. For example:)EP(

  ) 4 51 PR(config [string] config.libhello.database

if! $defined\201config.libhello.database\202
  fail 'config.libhello.database must be specified')RP(

  )BR(
  )0 P(A config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH( without a default value is omitted from
  )SM(config.build)ES( unless the value is spec)HY(i)HY(fied)YH( by the user. This
  seman)HY(tics)YH( is useful for values that are normally derived from other
  config)HY(u)HY(ra)HY(tion)YH( values but could also be spec)HY(i)HY(fied)YH( by the user. If the value
  is derived, then we don't want it saved in )SM(config.build)ES( since
  that would prevent it from being re-derived if the config)HY(u)HY(ra)HY(tion)YH( values it
  is based on are changed. For example:)EP(

  ) 13 71 PR(config [strings] config.hello.database

assert \201$size\201$config.hello.database\202 > 0\202 \200
  'database must be specified with config.hello.database'

config [bool, config.report.variable=multi] config.hello.multi_database

multi = \201$defined\201config.hello.multi_database\202 \200
         ? $config.hello.multi_database        \200
         : $size\201config.hello.database\202 > 1\202

assert \201$multi || $size\201config.hello.database\202 == 1\202 \200
  'one database can be specified if config.hello.multi_database=false')RP(
  )BR(

  )0 P(If comput)HY(ing)YH( the default value is expen)HY(sive)YH( or requires elab)HY(o)HY(rate)YH( logic,
  then the handling of a config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH( can be broken down into two
  steps along these lines:)EP(

  ) 12 66 PR(config [string] config.libhello.greeting

if! $defined\201config.libhello.greeting\202
{
  greeting = ... # Calculate default value.

  if \201$greeting == [null]\202
    fail "unable to calculate default greeting, specify manually \200
with config.libhello.greeting"

  config config.libhello.greeting ?= $greeting
})RP(

  )0 P(Other than assign)HY(ing)YH( the default value via the )SM(config)ES(
  direc)HY(tive)YH(, config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( should not be modi)HY(fied)YH( by the project's
  )SM(build)HY(files)YH()ES(. Instead, if further process)HY(ing)YH( of the config)HY(u)HY(ra)HY(tion)YH(
  value is neces)HY(sary)YH(, we should assign the config)HY(u)HY(ra)HY(tion)YH( value to a differ)HY(ent)YH(,
  non-)SM(config.*)ES(, vari)HY(able)YH( and modify that. The two situ)HY(a)HY(tions)YH(
  where this is commonly required are post-process)HY(ing)YH( of config)HY(u)HY(ra)HY(tion)YH( values
  to be more suit)HY(able)YH( for use in )SM(build)HY(files)YH()ES( as well as further
  customiza)HY(tion)YH( of config)HY(u)HY(ra)HY(tion)YH( values. Let's see exam)HY(ples)YH( of both.)EP(

  )0 P(To illus)HY(trate)YH( the first situ)HY(a)HY(tion)YH(, let's say we need to trans)HY(late)YH( the
  database iden)HY(ti)HY(fiers)YH( spec)HY(i)HY(fied)YH( by the user:)EP(

  ) 26 50 PR(config [string] config.libhello.database ?= [null]

switch $config.libhello.database
{
  case [null]
    database = [null]

  case 'sqlite'
    database = 'SQLITE'

  case 'pgsql'
    database = 'PGSQL'

  case 'mysql'
  case 'mariadb'
    database = 'MYSQL'

  default
    fail "..."
  }
}

using cxx

if \201$database != [null]\202
  cxx.poptions += "-DLIBHELLO_WITH_$database")RP(

  )0 P(For the second situ)HY(a)HY(tion)YH(, the typical pattern looks like this:)EP(

  ) 5 45 PR(config [strings] config.libhello.options

options  = # Overridable options go here.
options += $config.libhello.options
options += # Non-overridable options go here.)RP(

  )0 P(That is, assum)HY(ing)YH( that the subse)HY(quently)YH( spec)HY(i)HY(fied)YH( options \201for example,
  command line options\202 over)HY(ride)YH( any previ)HY(ously)YH( spec)HY(i)HY(fied)YH(, we first set
  default )SM(build)HY(file)YH()ES( options that are allowed to be over)HY(rid)HY(den)YH( by
  options from the config)HY(u)HY(ra)HY(tion)YH( value, then append such options, if any, and
  finish off by append)HY(ing)YH( )SM(build)HY(file)YH()ES( options that should always be
  in effect.)EP(

  )0 P(As a concrete example of this approach, let's say we want to make the
  compiler warning level of our project config)HY(urable)YH( \201likely a bad idea; also
  ignores compiler differ)HY(ences)YH(\202:)EP(

  ) 9 41 PR(config [strings] config.libhello.woptions

woptions  = -Wall -Wextra
woptions += $config.libhello.woptions
woptions += -Werror

using cxx

cxx.coptions += $woptions)RP(

  )0 P(With this arrange)HY(ment)YH(, the users of our project can customize the warning
  level but cannot disable the treat)HY(ment)YH( of warn)HY(ings)YH( as errors. For
  example:)EP(

  ) 2 44 PR($ b -v config.libhello.woptions=-Wno-extra
g++ ... -Wall -Wextra -Wno-extra -Werror ...)RP(

  )0 P(If you do not plan to package your project, then the above rules are the
  only constraints you have. However, if your project is also a package, then
  other projects that use it as a depen)HY(dency)YH( may have pref)HY(er)HY(ences)YH( and
  require)HY(ments)YH( regard)HY(ing)YH( its config)HY(u)HY(ra)HY(tion)YH(. And it becomes the job of the
  package manager \201)SM(bpkg)ES(\202 to nego)HY(ti)HY(ate)YH( a suit)HY(able)YH( config)HY(u)HY(ra)HY(tion)YH(
  between all the depen)HY(dents)YH( of your project \201see )0 2 A(Depen)HY(dency)YH(
  Config)HY(u)HY(ra)HY(tion)YH( Nego)HY(ti)HY(a)HY(tion)YH()EA( for details\202. This can be a diffi)HY(cult)YH( problem
  to solve opti)HY(mally)YH( in a reason)HY(able)YH( time and to help the package manager come
  up with the best config)HY(u)HY(ra)HY(tion)YH( quickly you should follow the below
  addi)HY(tional)YH( rules and recom)HY(men)HY(da)HY(tions)YH( for config)HY(u)HY(ra)HY(tion)YH( of pack)HY(ages)YH( \201but
  which are also gener)HY(ally)YH( good ideas\202:)EP(

  )4 OL(  )-1 LI(Prefer )SM(bool)ES( config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH(. For example, if your
  project supports a fixed number of back)HY(ends)YH(, then provide a
  )SM(bool)ES( vari)HY(able)YH( to enable each rather than a single vari)HY(able)YH( that
  lists all the back)HY(ends)YH( to be enabled.

  )-1 LI(Avoid project config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH( depen)HY(den)HY(cies)YH(, that is, where the
  default value of one vari)HY(able)YH( depends on the value of another. But if you do
  need such a depen)HY(dency)YH(, make sure it is expressed using the orig)HY(i)HY(nal)YH(
  )SM(config.<project>.*)ES( vari)HY(ables)YH( rather than any
  inter)HY(me)HY(di)HY(ate)YH(/computed values. For example:

  ) 4 50 PR(# Enable Y only if X is enabled.
#
config [bool] config.hello.x ?= false
config [bool] config.hello.y ?= $config.libhello.x)RP(

  )-1 LI(Do not make project config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( condi)HY(tional)YH(. In other words,
  the set of config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( and their types should be a static
  prop)HY(erty)YH( of the project. If you do need to make a certain config)HY(u)HY(ra)HY(tion)YH(
  vari)HY(able)YH( "unavail)HY(able)YH(" or "disabled" if certain condi)HY(tions)YH( are met \201for
  example, on a certain plat)HY(form)YH( or based on the value of another
  config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH(\202, then express this with a default value and/or a
  check. For example:

  ) 13 64 PR(windows = \201$cxx.target.class == 'windows'\202

# Y should only be enabled if X is enabled and we are not on
# Windows.
#
config [bool] config.hello.x ?= false
config [bool] config.hello.y ?= \201$config.hello.x && !$windows\202

if $config.libhello.y
{
  assert $config.hello.x "Y can only be enabled if X is enabled"
  assert \201!$windows\202     "Y cannot be enabled on Windows"
})RP(
  )LO(

  )0 P(Addi)HY(tion)HY(ally)YH(, if you wish to factor some )SM(config)ES( direc)HY(tives)YH(
  into a sepa)HY(rate)YH( file \201for example, if you have a large number of them or you
  would like to share them with subpro)HY(jects)YH(\202 and source it from your
  )SM(build/root.build)ES(, then it is recom)HY(mended)YH( that you place this
  file into the )SM(build/config/)ES( subdi)HY(rec)HY(tory)YH(, where the package
  manager expects to find such files \201see )0 2 A(Package
  Build System Skele)HY(ton)YH()EA( for back)HY(ground)YH(\202. For example:)EP(

  ) 6 42 PR(# root.build
#

...

source $src_root/build/config/common.build)RP(

  )BR(
  )0 P(If you would prefer to keep such a file in a differ)HY(ent)YH( loca)HY(tion)YH( \201for
  example, because it contains things other than )SM(config)ES(
  direc)HY(tives)YH(\202, then you will need to manu)HY(ally)YH( list it in your package's
  )SM(mani)HY(fest)YH()ES( file, see the )0 2 A()SM(build-file)ES()EA(
  value for details.)EP(
  )BR(

  )0 P(Another effect of the )SM(config)ES( direc)HY(tive)YH( is to print the
  config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH( in the project's config)HY(u)HY(ra)HY(tion)YH( report. This
  func)HY(tion)HY(al)HY(ity)YH( is discussed in the follow)HY(ing)YH( section. While we have already
  seen some exam)HY(ples)YH( of how to prop)HY(a)HY(gate)YH( the config)HY(u)HY(ra)HY(tion)YH( values to our
  source code, )0 25 1 A(Config)HY(u)HY(ra)HY(tion)YH( Prop)HY(a)HY(ga)HY(tion)YH()25 0 TN TL()Ec /AF f D(
  discusses this topic in more detail.)EP(

  )0 2 22 H(2.2)WB 233 Sn()WB 24 Sn( Config)HY(u)HY(ra)HY(tion)YH( Report)EH(

  )0 P(One of the effects of the )SM(config)ES( direc)HY(tive)YH( is to mark a
  defined config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH( for report)HY(ing)YH(. The project config)HY(u)HY(ra)HY(tion)YH(
  report is printed auto)HY(mat)HY(i)HY(cally)YH( at a suffi)HY(ciently)YH( high verbosity level along
  with the build system module config)HY(u)HY(ra)HY(tion)YH(. For example \201some of the
  )SM(cxx)ES( module config)HY(u)HY(ra)HY(tion)YH( is omitted for brevity\202:)EP(

  ) 9 35 PR($ b config.libhello.greeting=Hey -v
cxx libhello@/tmp/libhello/
  cxx        g++@/usr/bin/g++
  id         gcc
  version    9.1.0
  ...
config libhello@/tmp/libhello/
  fancy      false
  greeting   Hey)RP(

  )BR(
  )0 P(The config)HY(u)HY(ra)HY(tion)YH( report is printed imme)HY(di)HY(ately)YH( after loading the
  project's )SM(build/root.build)ES( file. It is always printed at
  verbosity level )SM(3)ES( \201)SM(-V)ES(\202 or higher. It is also
  printed at verbosity level )SM(2)ES( \201)SM(-v)ES(\202 if any of the
  reported config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( have a )I(new)ES( value. A value is
  consid)HY(ered)YH( new if it was set to default or was over)HY(rid)HY(den)YH( on the command
  line.)EP(
  )BR(

  )0 P(The project config)HY(u)HY(ra)HY(tion)YH( report header \201the first line\202 starts with the
  special )SM(config)ES( module name \201the )SM(config)ES( module
  itself does not have a report\202 followed by the project name and its
  )SM(out_root)ES( path. After the header come config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH(
  with the )SM(config[.**].<project>)ES( prefix removed. The
  config)HY(u)HY(ra)HY(tion)YH( report for each vari)HY(able)YH( can be customized using a number of
  )SM(config.report*)ES( attributes as discussed next.)EP(

  )0 P(The )SM(config.report)ES( attribute controls whether the vari)HY(able)YH( is
  included into the report and, if so, the format to print its value in. For
  example, this is how we can exclude a vari)HY(able)YH( from the report:)EP(

  ) 1 68 PR(config [bool, config.report=false] config.libhello.selftest ?= false)RP(

  )0 P(While we would normally want to report all our config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( ,
  if some of them are inter)HY(nal)YH( and not meant to be used by the users of our
  project, it prob)HY(a)HY(bly)YH( makes sense to exclude them.)EP(

  )0 P(The only currently supported alter)HY(na)HY(tive)YH( print)HY(ing)YH( format is
  )SM(multi)HY(line)YH()ES( which prints a list value one element per line. Other print)HY(ing)YH( formats may be supported in the future.
  For example:)EP(

  ) 1 71 PR(config [dir_paths, config.report=multiline] config.libhello.search_dirs)RP(

  ) 5 54 PR($ b config.libhello.search_dirs="/etc/default /etc" -v
config libhello@/tmp/libhello/
  search_dirs
    /etc/default/
    /etc/)RP(

  )0 P(The )SM(config.report)ES( attribute can also be used to include a
  non-)SM(config.*)ES( vari)HY(able)YH( into a report. This is primar)HY(ily)YH( useful
  for config)HY(u)HY(ra)HY(tion)YH( values that are always discov)HY(ered)YH( auto)HY(mat)HY(i)HY(cally)YH( but that
  are still useful to report for trou)HY(bleshoot)HY(ing)YH(. Here is a real)HY(is)HY(tic)YH(
  example:)EP(

  ) 17 73 PR(using cxx

# Determine the GCC plugin directory.
#
if \201$cxx.id == 'gcc'\202
{
  plugin_dir = [dir_path] $process.run\201$cxx.path -print-file-name=plugin\202

  # If plugin support is disabled, then -print-file-name will print
  # the name we have passed \201the real plugin directory will always
  # be absolute\202.
  #
  if \201"$plugin_dir" == plugin\202
    fail "$recall\201$cxx.path\202 does not support plugins"

  config [config.report] plugin_dir
})RP(

  )BR(
  )0 P(This is the only situ)HY(a)HY(tion)YH( where a vari)HY(able)YH( that does not match the
  )SM(config[.**].<project>.**)ES( pattern is allowed in the
  )SM(config)ES( direc)HY(tive)YH(. Note also that a value of such a vari)HY(able)YH( is
  never consid)HY(ered)YH( new.)EP(
  )BR(

  )0 P(Note that this mech)HY(a)HY(nism)YH( should not be used to report config)HY(u)HY(ra)HY(tion)YH(
  values that require post-process)HY(ing)YH( because of the loss of the new value
  status \201unless you are report)HY(ing)YH( both the orig)HY(i)HY(nal)YH( and post-processed
  values\202. Instead, use the )SM(config.report.vari)HY(able)YH()ES( attribute to
  specify an alter)HY(na)HY(tive)YH( vari)HY(able)YH( for the report. For example:)EP(

  ) 6 51 PR(config [strings, config.report.variable=woptions] \200
  config.libhello.woptions

woptions  = -Wall -Wextra
woptions += $config.libhello.woptions
woptions += -Werror)RP(

  ) 3 45 PR($ b config.libhello.woptions=-Wno-extra -v
config libhello@/tmp/libhello/
  woptions   -Wall -Wextra -Wno-extra -Werror)RP(

  )0 P(The )SM(config.report.module)ES( attribute can be used to over)HY(ride)YH(
  the report)HY(ing)YH( module name, that is, )SM(config)ES( in the
  )SM(config\240libhello@/tmp/libhello/)ES( line above. It is primar)HY(ily)YH(
  useful in imported )SM(build)HY(files)YH()ES( that wish to report
  non-)SM(config.*)ES( vari)HY(ables)YH( under their own name. For example:)EP(

  ) 9 67 PR(config [string] config.rtos.board

# Load the board description and report key information such as the
# capability revoker.
#
...
revoker = ...

config [config.report.module=rtos] revoker)RP(

  ) 4 44 PR($ b config.rtos.board=ibex-safe-simulator -v
rtos hello@/tmp/hello/
  board      ibex-safe-simulator
  revoker    hardware)RP(

  )0 2 23 H(2.3)WB 234 Sn()WB 25 Sn( Config)HY(u)HY(ra)HY(tion)YH( Prop)HY(a)HY(ga)HY(tion)YH()EH(

  )0 P(Using config)HY(u)HY(ra)HY(tion)YH( values in our )SM(build)HY(files)YH()ES( is
  straight)HY(for)HY(ward)YH(: they are like any other )SM(build)HY(file)YH()ES( vari)HY(ables)YH(
  and we can access them directly. For example, this is how we could provide
  optional func)HY(tion)HY(al)HY(ity)YH( in our library by condi)HY(tion)HY(ally)YH( includ)HY(ing)YH( certain
  source files: See )0 17 1 A(Condi)HY(tions)YH(
  \201)SM(if-else)ES(\202)17 0 TN TL()Ec /AF f D( for why we should not use )SM(if)ES( to
  imple)HY(ment)YH( this.)EP(

  ) 3 43 PR(# build/root.build

config [strings] config.libhello.io ?= true)RP(

  ) 4 65 PR(# libhello/buildfile

lib{hello}: {hxx ixx txx cxx}{** -version -hello-io} hxx{version}
lib{hello}: {hxx cxx}{hello-io}: include = $config.libhello.io)RP(

  )0 P(On the other hand, it is often required to prop)HY(a)HY(gate)YH( the config)HY(u)HY(ra)HY(tion)YH(
  infor)HY(ma)HY(tion)YH( to our source code. In fact, we have already seen one way to do
  it: we can pass this infor)HY(ma)HY(tion)YH( via C/C++ prepro)HY(ces)HY(sor)YH( macros defined on
  the compiler's command line. For example:)EP(

  ) 4 51 PR(# build/root.build

config [bool]   config.libhello.fancy    ?= false
config [string] config.libhello.greeting ?= 'Hello')RP(

  ) 6 67 PR(# libhello/buildfile

if $config.libhello.fancy
  cxx.poptions += -DLIBHELLO_FANCY

cxx.poptions += "-DLIBHELLO_GREETING=\200"$config.libhello.greeting\200"")RP(

  ) 10 50 PR(// libhello/hello.cxx

void say_hello \201ostream& o, const string& n\202
{
#ifdef LIBHELLO_FANCY
  // TODO: something fancy.
#else
  o << LIBHELLO_GREETING ", " << n << '!' << endl;
#endif
})RP(

  )0 P(We can even use the same approach to export certain config)HY(u)HY(ra)HY(tion)YH(
  infor)HY(ma)HY(tion)YH( to our library's users \201see )0 13 1 A(Library
  Expor)HY(ta)HY(tion)YH( and Version)HY(ing)YH()13 0 TN TL()Ec /AF f D( for details\202:)EP(

  ) 6 53 PR(# libhello/buildfile

# Export options.
#
if $config.libhello.fancy
  lib{hello}: cxx.export.poptions += -DLIBHELLO_FANCY)RP(

  )0 P(This mech)HY(a)HY(nism)YH( is simple and works well across compil)HY(ers)YH( so there is no
  reason not to use it when the number of config)HY(u)HY(ra)HY(tion)YH( values passed and
  their size are small. However, it can quickly get unwieldy as these numbers
  grow. For such cases, it may make sense to save this infor)HY(ma)HY(tion)YH( into a
  sepa)HY(rate)YH( auto-gener)HY(ated)YH( source file with the help of the )0 208 1 A()SM(in)ES()208 0 TN TL()Ec /AF f D( module, similar to how we do it for
  the version header.)EP(

  )0 P(The often-used approach is to gener)HY(ate)YH( a header file and include it into
  source files that need access to the config)HY(u)HY(ra)HY(tion)YH( infor)HY(ma)HY(tion)YH(.
  Histor)HY(i)HY(cally)YH(, this was a C header full of macros called
  )SM(config.h)ES(. However, for C++ projects, there is no reason not to
  make it a C++ header and, if desired, to use modern C++ features instead of
  macros. Which is what we will do here.)EP(

  )0 P(As an example of this approach, let's convert the above command
  line-based imple)HY(men)HY(ta)HY(tion)YH( to use the config)HY(u)HY(ra)HY(tion)YH( header. We will continue
  using macros as a start \201or in case this is a C project\202 and try more modern
  tech)HY(niques)YH( later. The )SM(build/root.build)ES( file is unchanged except
  for loading the )SM(in)ES( module:)EP(

  ) 6 51 PR(# build/root.build

config [bool]   config.libhello.fancy    ?= false
config [string] config.libhello.greeting ?= 'Hello'

using in)RP(

  )0 P(The )SM(libhello/config.hxx.in)ES( file is new:)EP(

  ) 6 54 PR(// libhello/config.hxx.in

#pragma once

#define LIBHELLO_FANCY    $config.libhello.fancy$
#define LIBHELLO_GREETING "$config.libhello.greeting$")RP(

  )0 P(As you can see, we can refer)HY(ence)YH( our config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( directly in
  the )SM(config.hxx.in)ES( substi)HY(tu)HY(tions)YH( \201see the )0 208 1 A()SM(in)ES()208 0 TN TL()Ec /AF f D( module docu)HY(men)HY(ta)HY(tion)YH( for details on
  how this works\202.)EP(

  )BR(
  )0 P(With this setup, the way to export config)HY(u)HY(ra)HY(tion)YH( infor)HY(ma)HY(tion)YH( to our
  library's users is to make the config)HY(u)HY(ra)HY(tion)YH( header public and install it,
  similar to how we do it for the version header.)EP(
  )BR(

  )0 P(The rest is changed as follows:)EP(

  ) 8 70 PR(# libhello/buildfile

lib{hello}: {hxx ixx txx cxx}{** -version -config} hxx{version config}

hxx{config}: in{config}
{
  install = false
})RP(

  ) 12 50 PR(// libhello/hello.cxx

#include <libhello/config.hxx>

void say_hello \201ostream& o, const string& n\202
{
#if LIBHELLO_FANCY
  // TODO: something fancy.
#else
  o << LIBHELLO_GREETING ", " << n << '!' << endl;
#endif
})RP(

  )BR(
  )0 P(Notice that we had to replace )SM(#ifdef\240LIBHELLO_FANCY)ES(
  with )SM(#if\240LIBHELLO_FANCY)ES(. If you want to continue using
  )SM(#ifdef)ES(, then you will need to make the neces)HY(sary)YH( arrange)HY(ments)YH(
  your)HY(self)YH( \201the )SM(in)ES( module is a generic prepro)HY(ces)HY(sor)YH( and does not
  provide any special treat)HY(ment)YH( for )SM(#define)ES(\202. For example:)EP(

  ) 4 46 PR(#define LIBHELLO_FANCY $config.libhello.fancy$
#if !LIBHELLO_FANCY
#  undef LIBHELLO_FANCY
#endif)RP(
  )BR(

  )0 P(Now that the macro-based version is working, let's see how we can take
  advan)HY(tage)YH( of modern C++ features to hope)HY(fully)YH( improve on some of their
  draw)HY(backs)YH(. As a first step, we can replace the )SM(LIBHELLO_FANCY)ES(
  macro with a compile-time constant and use )SM(if\240cons)HY(t)HY(expr)YH()ES(
  instead of )SM(#ifdef)ES( in our imple)HY(men)HY(ta)HY(tion)YH(:)EP(

  ) 6 56 PR(// libhello/config.hxx.in

namespace hello
{
  inline constexpr bool fancy = $config.libhello.fancy$;
})RP(

  ) 13 52 PR(// libhello/hello.cxx

#include <libhello/config.hxx>

void say_hello \201ostream& o, const string& n\202
{
  if constexpr \201fancy\202
  {
    // TODO: something fancy.
  }
  else
    o << LIBHELLO_GREETING ", " << n << '!' << endl;
})RP(

  )BR(
  )0 P(Note that with )SM(if\240cons)HY(t)HY(expr)YH()ES( the branch not taken must
  still be valid, parsable code. This is both one of the main bene)HY(fits)YH( of
  using it instead of )SM(#if)ES( \201the code we are not using is still
  guar)HY(an)HY(teed)YH( to be syntac)HY(ti)HY(cally)YH( correct\202 as well as its main draw)HY(back)YH( \201it
  cannot be used, for example, for plat)HY(form)YH(-specific code without extra
  efforts, such as provid)HY(ing)YH( shims for missing decla)HY(ra)HY(tions)YH(, etc\202.)EP(
  )BR(

  )0 P(Next, we can do the same for )SM(LIBHELLO_GREET)HY(ING)YH()ES(:)EP(

  ) 6 66 PR(// libhello/config.hxx.in

namespace hello
{
  inline constexpr char greeting[] = "$config.libhello.greeting$";
})RP(

  ) 13 46 PR(// libhello/hello.cxx

#include <libhello/config.hxx>

void say_hello \201ostream& o, const string& n\202
{
  if constexpr \201fancy\202
  {
    // TODO: something fancy.
  }
  else
    o << greeting << ", " << n << '!' << endl;
})RP(

  )BR(
  )0 P(Note that for )SM(greet)HY(ing)YH()ES( we can achieve the same result
  without using inline vari)HY(ables)YH( or )SM(cons)HY(t)HY(expr)YH()ES( and which would be
  usable in older C++ and even C. All we have to do is add the
  )SM(config.cxx.in)ES( source file next to our header with the
  defi)HY(ni)HY(tion)YH( of the )SM(greet)HY(ing)YH()ES( vari)HY(able)YH(. For example:)EP(

  ) 6 31 PR(// libhello/config.hxx.in

namespace hello
{
  extern const char greeting[];
})RP(

  ) 8 55 PR(// libhello/config.cxx.in

#include <libhello/config.hxx>

namespace hello
{
  const char greeting[] = "$config.libhello.greeting$";
})RP(

  ) 10 59 PR(# libhello/buildfile

lib{hello}: {hxx ixx txx cxx}{** -config} {hxx cxx}{config}

hxx{config}: in{config}
{
  install = false
}

cxx{config}: in{config})RP(

  )0 P(As this illus)HY(trates)YH(, the )SM(in)ES( module can produce as many
  auto-gener)HY(ated)YH( source files as we need. For example, we could use this to
  split the config)HY(u)HY(ra)HY(tion)YH( header into two, one public and installed while the
  other private.)EP(
  )BR(

  )0 1 24 H(3)WB 235 Sn()WB 26 Sn( Targets and Target Types)EH(

  )0 P(This chapter is a work in progress and is
  incom)HY(plete)YH(.)EP(

  )0 2 25 H(3.1)WB 236 Sn()WB 27 Sn( Target Types)EH(

  )0 P(A target type is part of a target's iden)HY(tity)YH(. The core idea behind the
  concept of target types is to abstract away from file exten)HY(sions)YH( which can
  vary from project to project \201for example, C++ source files exten)HY(sions)YH(\202 or
  from plat)HY(form)YH( to plat)HY(form)YH( \201for example, executable file exten)HY(sions)YH(\202. It also
  allows us to have non-file-based targets.)EP(

  )0 P(Target types form a )I(base-derived)ES( inher)HY(i)HY(tance)YH( tree. The root of
  this tree is the abstract )SM(target{})ES( type. The
  )SM(build2)ES( core defines a number of stan)HY(dard)YH( target types, such as
  )SM(file{})ES(, )SM(doc{})ES(, and )SM(exe{})ES(. Build
  system modules can define addi)HY(tional)YH( target types that are based on the
  stan)HY(dard)YH( ones \201or on types defined by other modules\202. For example, the
  )SM(c)ES( module that provides the C compi)HY(la)HY(tion)YH( support defines the
  )SM(h{})ES( and )SM(c{})ES( target types. Finally,
  )SM(build)HY(files)YH()ES( can derive project-local target types using the
  )SM(define)ES( direc)HY(tive)YH(.)EP(

  )BR(
  )0 P(If a target type repre)HY(sents)YH( a file type with a well-estab)HY(lished)YH(
  exten)HY(sion)YH(, then by conven)HY(tion)YH( such an exten)HY(sion)YH( is used as the target type
  name. For example, the C language header and source files use the
  )SM(.h)ES( and )SM(.c)ES( exten)HY(sions)YH( and the target types are
  called )SM(h{})ES( and )SM(c{})ES(.)EP(

  )0 P(Speak)HY(ing)YH( of conven)HY(tions)YH(, as you may have noticed, when mention)HY(ing)YH( a
  target type we custom)HY(ar)HY(ily)YH( add )SM({})ES( after its name. We found that
  this helps with compre)HY(hen)HY(sion)YH( since target type names are often short \201you
  can also search for )SM(<type>{)ES( to narrow it down to target
  types\202. In a way this is a similar approach to adding )SM(\201\202)ES( after
  a func)HY(tion)YH( name except here we use )SM({})ES(, which mimics target type
  usage in target names, for example )SM(c{hello})ES( for
  )SM(hello.c)ES(.)EP(
  )BR(

  )0 P(The follow)HY(ing)YH( listing shows the hier)HY(ar)HY(chy)YH( of the stan)HY(dard)YH( target types
  defined by the )SM(build2)ES( core \201the abstract target types are
  marked with )SM(*)ES(\202 while the follow)HY(ing)YH( sections describe each
  stan)HY(dard)YH( target type in detail. For target types defined by a module refer
  to the respec)HY(tive)YH( module docu)HY(men)HY(ta)HY(tion)YH(.)EP(

  ) 13 47 PR(                   .-----target*------------.
                   |                 |      |
              mtime_target*---.    alias  fsdir
                   |          |      |
              path_target*  group   dir
                   |
        .---------file----.
        |          |      |
  .----doc-----.  exe  buildfile
  |     |      |
legal  man  manifest
        |
       man<N>)RP(

  )0 P(While target types replace \201poten)HY(tially)YH( vari)HY(able)YH(\202 exten)HY(sions)YH(, there still
  needs to be a mech)HY(a)HY(nism)YH( for spec)HY(i)HY(fy)HY(ing)YH( them since in most cases targets have
  to be mapped to files. There are several ways this can be achieved.)EP(

  )0 P(If a target type repre)HY(sents)YH( a file type with a well-estab)HY(lished)YH(
  exten)HY(sion)YH(, then such an exten)HY(sion)YH( is normally used by default and we don't
  need to take any extra steps. For example the )SM(h{})ES( and
  )SM(c{})ES( target types for C header and source files default to the
  )SM(.h)ES( and )SM(.c)ES( exten)HY(sions)YH(, respec)HY(tively)YH(, and if our
  project follows this conven)HY(tion)YH(, then we can simply write:)EP(

  ) 1 35 PR(exe{utility}: c{utility} h{utility})RP(

  )0 P(And )SM(c{utility})ES( will be mapped to )SM(utility.c)ES( and
  )SM(h{utility})ES( \235 to )SM(utility.h)ES(.)EP(

  )0 P(There are two vari)HY(ants)YH( of this default exten)HY(sion)YH( case: fixed exten)HY(sion)YH(
  and customiz)HY(able)YH( exten)HY(sion)YH(. A target type may choose to fix the default
  exten)HY(sion)YH( if it's a bad idea to deviate from the default exten)HY(sion)YH(. A good
  example of such a target is )SM(man1{})ES(, which fixes the default
  exten)HY(sion)YH( to be )SM(.1)ES(. More commonly, however, a target will have
  a default exten)HY(sion)YH( but will allow customiz)HY(ing)YH( it with the
  )SM(exten)HY(sion)YH()ES( vari)HY(able)YH(.)EP(

  )0 P(A good example where exten)HY(sion)YH( customiza)HY(tion)YH( is often required are the
  )SM(hxx{})ES( and )SM(cxx{})ES( target types for C++ header and
  source files, which default to the )SM(.hxx)ES( and )SM(.cxx)ES(
  exten)HY(sions)YH(, respec)HY(tively)YH(. If our project uses other exten)HY(sions)YH(, for example,
  )SM(.hpp)ES( and )SM(.cpp)ES(, then we can adjust the defaults
  \201typi)HY(cally)YH( done in )SM(root.build)ES(, after loading the
  )SM(cxx)ES( module\202:)EP(

  ) 2 23 PR(hxx{*}: extension = hpp
cxx{*}: extension = cpp)RP(

  )0 P(Then we can write:)EP(

  ) 1 39 PR(exe{utility}: cxx{utility} hxx{utility})RP(

  )0 P(And )SM(cxx{utility})ES( will be mapped to )SM(utility.cpp)ES(
  and )SM(hxx{utility})ES( \235 to )SM(utility.hpp)ES(.)EP(

  )0 P(What about )SM(exe{utility})ES(, where does its exten)HY(sion)YH( come from?
  This is an example of a target type with an exten)HY(sion)YH( that varies from
  plat)HY(form)YH( to plat)HY(form)YH(.  In such cases the exten)HY(sion)YH( is expected to be
  assigned by the rule that matches the target. In the above example, the link
  rule from the )SM(cxx)ES( module that matches updat)HY(ing)YH(
  )SM(exe{utility})ES( will assign a suit)HY(able)YH( exten)HY(sion)YH( based on the
  target plat)HY(form)YH( of the C++ compiler that it was instructed to use.)EP(

  )0 P(Finally, it is always possi)HY(ble)YH( to specify the file exten)HY(sion)YH( explic)HY(itly)YH(
  as part of the target name. For example:)EP(

  ) 1 45 PR(exe{utility}: cxx{utility.cc} hxx{utility.hh})RP(

  )0 P(This is normally only needed if the default exten)HY(sion)YH( is not appro)HY(pri)HY(ate)YH(
  or if the target type does not have a default exten)HY(sion)YH(, as is the case, for
  example, for the )0 33 1 A()SM(file{})ES()33 0 TN TL()Ec /AF f D( and
  )0 34 1 A()SM(doc{})ES()34 0 TN TL()Ec /AF f D( target types. This
  mech)HY(a)HY(nism)YH( can also be used to over)HY(ride)YH( the auto)HY(mat)HY(i)HY(cally)YH( derived exten)HY(sion)YH(.
  For example:)EP(

  ) 1 66 PR(exe{\201$cxx.target.class == 'windows' ? utility.com : utility\202}: ...)RP(

  )BR(
  )0 P(If you need to specify a name that does not have an exten)HY(sion)YH(, then end
  it with a single dot. For example, for a header )SM(utility)ES( you
  would write )SM(hxx{utility.})ES(. If you need to specify a name with
  an actual trail)HY(ing)YH( dot, then escape it with a double dot, for example,
  )SM(hxx{utility..})ES(.)EP(

  )0 P(More gener)HY(ally)YH(, anywhere in a name, a double dot can be used to specify a
  dot that should not be consid)HY(ered)YH( the exten)HY(sion)YH( sepa)HY(ra)HY(tor)YH( while a triple dot
  \235 which should. For example, in )SM(obja{foo.a.o})ES( the
  exten)HY(sion)YH( is )SM(.o)ES( and if instead we wanted )SM(.a.o)ES( to
  be consid)HY(ered)YH( the exten)HY(sion)YH(, then we could rewrite it either as
  )SM(obja{foo.a..o})ES( or as )SM(obja{foo...a.o})ES(.)EP(
  )BR(

  )0 P(To derive a new target type in a )SM(build)HY(file)YH()ES( we use the
  )SM(define)ES( direc)HY(tive)YH(. Such target types are project-local, meaning
  they cannot be exported to other projects. Typi)HY(cally)YH( this is used to provide
  a more mean)HY(ing)HY(ful)YH( name to a set of files and also avoid having to specify
  their exten)HY(sions)YH( explic)HY(itly)YH(. Compare:)EP(

  ) 1 47 PR(./: doc{README.md PACKAGE-README.md INSTALL.md})RP(

  )0 P(To:)EP(

  ) 4 37 PR(define md: doc
doc{*}: extension = md

./: md{README PACKAGE-README INSTALL})RP(

  )0 3 26 H(3.1.1)WB 237 Sn()WB 28 Sn( )SM(target{})ES()EH(

  )0 P(The )SM(target{})ES( target type is a root of the target type
  hier)HY(ar)HY(chy)YH(. It is abstract and is not commonly used directly, except perhaps
  in patterns \201target type/pattern-specific vari)HY(able)YH(, pattern rules\202.)EP(

  )0 3 27 H(3.1.2)WB 238 Sn()WB 29 Sn( )SM(alias{})ES( and
  )SM(dir{})ES()EH(

  )0 P(The )SM(alias{})ES( target type is used for non-file-based targets
  that serve as aliases for their prereq)HY(ui)HY(site)YH(.)EP(

  )BR(
  )0 P(Alias targets in )SM(build2)ES( are roughly equiv)HY(a)HY(lent)YH( to phony
  targets in )SM(make)ES(.)EP(
  )BR(

  )0 P(For example:)EP(

  ) 1 36 PR(alias{tests}: exe{test1 test2 test3})RP(

  ) 1 22 PR($ b test: alias{tests})RP(

  )0 P(An )SM(alias{})ES( target can also serve as an "action" if supplied
  with an ad hoc recipe \201or matched by an ad hoc pattern rule\202. For
  example:)EP(

  ) 5 24 PR(alias{strip}: exe{hello}
{{
  diag strip $<
  strip $path\201$<\202
}})RP(

  )0 P(The )SM(dir{})ES( target type is a special kind of alias that
  repre)HY(sents)YH( a direc)HY(tory)YH(. Build)HY(ing)YH( it means build)HY(ing)YH( every)HY(thing)YH( inside the
  direc)HY(tory)YH(. See )0 5 1 A(Project Struc)HY(ture)YH()5 0 TN TL()Ec /AF f D( for
  back)HY(ground)YH(.)EP(

  )0 P(A target without a type that ends with a direc)HY(tory)YH( sepa)HY(ra)HY(tor)YH(
  \201)SM(/)ES(\202 is auto)HY(mat)HY(i)HY(cally)YH( treated as )SM(dir{})ES(. For
  example, the follow)HY(ing)YH( two lines are equiv)HY(a)HY(lent)YH(:)EP(

  ) 2 25 PR(./: exe{test1 test2}
dir{./}: exe{test1 test2})RP(

  )0 P(Omit)HY(ting)YH( the target type in such situ)HY(a)HY(tions)YH( is custom)HY(ary)YH(.)EP(

  )0 3 28 H(3.1.3)WB 239 Sn()WB 30 Sn( )SM(fsdir{})ES()EH(

  )0 P(The )SM(fsdir{})ES( target type repre)HY(sents)YH( a filesys)HY(tem)YH( direc)HY(tory)YH(.
  Unlike )SM(dir{})ES( above, it is not an alias and listing an
  )SM(fsdir{})ES( direc)HY(tory)YH( as a prereq)HY(ui)HY(site)YH( of a target will cause that
  direc)HY(tory)YH( to be created on )SM(update)ES( and removed on
  )SM(clean)ES(.)EP(

  )0 P(While we usually don't need to list explicit )SM(fsdir{})ES(
  prereq)HY(ui)HY(sites)YH( for our targets, one situ)HY(a)HY(tion)YH( where this is neces)HY(sary)YH( is when
  the target resides in a subdi)HY(rec)HY(tory)YH( that does not corre)HY(spond)YH( to an exist)HY(ing)YH(
  source direc)HY(tory)YH(. A typical example of this situ)HY(a)HY(tion)YH( is placing object
  files into subdi)HY(rec)HY(to)HY(ries)YH(. Compare:)EP(

  ) 2 32 PR(obj{foo}: c{foo}
sub/obj{bar}: c{bar} fsdir{sub/})RP(

  )0 3 29 H(3.1.4)WB 240 Sn()WB 31 Sn( )SM(mtime_target{})ES( and
  )SM(path_target{})ES()EH(

  )0 P(The )SM(mtime_target{})ES( target type repre)HY(sents)YH( a target that uses
  modi)HY(fi)HY(ca)HY(tion)YH( times to deter)HY(mine)YH( if it is out of date. The
  )SM(path_target{})ES( target type repre)HY(sents)YH( a target that has a
  corre)HY(spond)HY(ing)YH( filesys)HY(tem)YH( entry. It is derived from
  )SM(mtime_target{})ES( and uses the modi)HY(fi)HY(ca)HY(tion)YH( time of that
  filesys)HY(tem)YH( entry to deter)HY(mine)YH( if the target is out of date.)EP(

  )0 P(Both of these target types are abstract and are not commonly used
  directly, except perhaps in patterns \201target type/pattern-specific vari)HY(able)YH(,
  pattern rules\202.)EP(

  )0 3 30 H(3.1.5)WB 241 Sn()WB 32 Sn( )SM(group{})ES()EH(

  )0 P(The )SM(group{})ES( target type repre)HY(sents)YH( a user-defined explicit
  target group, that is, a target that has multi)HY(ple)YH( member targets that are
  all built together with a single recipe.)EP(

  )0 P(Normally this target type is not used to declare targets or prereq)HY(ui)HY(sites)YH(
  but rather as a base of a derived group. If desired, such a derived group
  can be marked with an attribute as "see-through", meaning that when the
  group is listed as a prereq)HY(ui)HY(site)YH( of a target, the match)HY(ing)YH( rule "sees" its
  members, rather than the group itself. For example:)EP(

  ) 1 38 PR(define [see_through] thrift_cxx: group)RP(

  )0 3 31 H(3.1.6)WB 242 Sn()WB 33 Sn( )SM(file{})ES()EH(

  )0 P(The )SM(file{})ES( target type repre)HY(sents)YH( a generic file. This
  target type is used as a base for most of the file-based targets and can
  also be used to declare targets and prereq)HY(ui)HY(sites)YH( when there are no more
  specific target types.)EP(

  )0 P(A target or prereq)HY(ui)HY(site)YH( without a target type is auto)HY(mat)HY(i)HY(cally)YH( treated
  as )SM(file{})ES(. However, omit)HY(ting)YH( a target type in such situ)HY(a)HY(tions)YH(
  is not custom)HY(ary)YH(.)EP(

  )0 P(The )SM(file{})ES( target type has no default exten)HY(sion)YH( and one
  cannot be assigned with the )SM(exten)HY(sion)YH()ES( vari)HY(able)YH(. As a result, if
  a )SM(file{})ES( target has an exten)HY(sion)YH(, then it must be spec)HY(i)HY(fied)YH(
  explic)HY(itly)YH( as part of the target name. For example:)EP(

  ) 1 22 PR(./: file{example.conf})RP(

  )0 3 32 H(3.1.7)WB 243 Sn()WB 34 Sn( )SM(doc{})ES(, )SM(legal{})ES(,
  and )SM(man{})ES()EH(

  )0 P(The )SM(doc{})ES( target type repre)HY(sents)YH( a generic docu)HY(men)HY(ta)HY(tion)YH(
  file. It has seman)HY(tics)YH( similar to )SM(file{})ES( \201from which it
  derives\202: it can be used as a base or declare targets/prereq)HY(ui)HY(sites)YH( and
  there is no default exten)HY(sion)YH(.  One notable differ)HY(ence)YH(, however, is that
  )SM(doc{})ES( targets are by default installed into the
  )SM(doc/)ES( instal)HY(la)HY(tion)YH( loca)HY(tion)YH( \201see )0 164 1 A()SM(install)ES( Module)164 0 TN TL()Ec /AF f D(\202. For example:)EP(

  ) 1 32 PR(./: doc{README.md ChangeLog.txt})RP(

  )0 P(The )SM(legal{})ES( target type is derived from )SM(doc{})ES(
  and repre)HY(sents)YH( a legal docu)HY(men)HY(ta)HY(tion)YH( file, such as a license, copy)HY(right)YH(
  notice, author)HY(ship)YH( infor)HY(ma)HY(tion)YH(, etc. The main purpose of having a sepa)HY(rate)YH(
  target type like this is to help with installing licens)HY(ing)YH(-related files
  into a differ)HY(ent)YH( loca)HY(tion)YH(. To this effect, )SM(legal{})ES( targets are
  installed into the )SM(legal/)ES( instal)HY(la)HY(tion)YH( loca)HY(tion)YH(, which by
  default is the same as )SM(doc/)ES( but can be customized. For
  example:)EP(

  ) 1 39 PR(./: legal{COPYRIGHT LICENSE AUTHORS.md})RP(

  )0 P(The )SM(man{})ES( target type is derived from )SM(doc{})ES( and
  repre)HY(sents)YH( a manual page. This target type requires an explicit exten)HY(sion)YH(
  spec)HY(i)HY(fi)HY(ca)HY(tion)YH( and is installed into the )SM(man/)ES( instal)HY(la)HY(tion)YH(
  loca)HY(tion)YH()EP(

  )BR(
  )0 P(If you are using the )SM(man{})ES( target type directly \201instead of
  one of )SM(man<N>{})ES( described below\202, for example, to install a
  local)HY(ized)YH( version of a man page, then you will likely need to adjust the
  instal)HY(la)HY(tion)YH( loca)HY(tion)YH( on the per target basis.)EP(
  )BR(

  )0 P(The )SM(man<N>{})ES( target types \201where )SM(<N>)ES( is
  an integer between 1 and 9\202 are derived from )SM(man{})ES( and
  repre)HY(sent)YH( manual pages in the respec)HY(tive)YH( sections. These target types have
  fixed default exten)HY(sions)YH( )SM(.<N>)ES( \201but an explicit exten)HY(sion)YH( can
  still be spec)HY(i)HY(fied)YH(, for example )SM(man1{foo.1p})ES(\202 and are installed
  into the )SM(man<N>/)ES( instal)HY(la)HY(tion)YH( loca)HY(tions)YH(. For example:)EP(

  ) 1 13 PR(./: man1{foo})RP(

  )0 3 33 H(3.1.8)WB 244 Sn()WB 35 Sn( )SM(exe{})ES()EH(

  )0 P(The )SM(exe{})ES( target type repre)HY(sents)YH( an executable file.
  Executa)HY(bles)YH( in )SM(build2)ES( appear in two distinct but some)HY(times)YH(
  over)HY(lap)HY(ping)YH( contexts: We can build an executable target, for example from C
  source files. Or we can list an executable target as a prereq)HY(ui)HY(site)YH( in order
  to execute it as part of a recipe. And some)HY(times)YH( this can be the same
  executable target. For example, one project may build an executable target
  that is a source code gener)HY(a)HY(tor)YH( and another project may import this
  executable target and use it in its recipes in order to gener)HY(ate)YH( some source
  code.)EP(

  )0 P(To support this seman)HY(tics)YH( the )SM(exe{})ES( target type has a
  pecu)HY(liar)YH( default exten)HY(sion)YH( logic. Specif)HY(i)HY(cally)YH(, if the )SM(exe{})ES(
  target is "output", then the exten)HY(sion)YH( is expected to be assigned by the
  match)HY(ing)YH( rule accord)HY(ing)YH( to the target plat)HY(form)YH( for which this executable is
  built. But if it does not, then we fall back to no exten)HY(sion)YH( \201for example, a
  script\202. If, however, the )SM(exe{})ES( target is "input" \201that is,
  it's listed as a prereq)HY(ui)HY(site)YH( and there is no corre)HY(spond)HY(ing)YH( "output"
  target\202, then the exten)HY(sion)YH( of the host plat)HY(form)YH( is used as the default.)EP(

  )0 P(In all these cases the exten)HY(sion)YH( can also be spec)HY(i)HY(fied)YH( explic)HY(itly)YH(. This,
  for example, would be neces)HY(sary)YH( if the executable were a batch file:)EP(

  ) 5 30 PR(h{generate}: exe{generate.bat}
{{
   diag $< -> $>
   $< -o $path\201$>\202
}})RP(

  )0 P(Here, without the explicit exten)HY(sion)YH(, the )SM(.exe)ES( exten)HY(sion)YH(
  would have been used by default.)EP(

  )0 1 34 H(4)WB 245 Sn()WB 36 Sn( Vari)HY(ables)YH()EH(

  )0 P(This chapter is a work in progress and is
  incom)HY(plete)YH(.)EP(

  )0 P(The follow)HY(ing)YH( vari)HY(able)YH(/value types can currently be used in
  )SM(build)HY(files)YH()ES(:)EP(

  ) 31 14 PR(bool

int64
int64s

uint64
uint64s

string
strings
string_set
string_map

path
paths
dir_path
dir_paths

json
json_array
json_object
json_set
json_map

name
names
name_pair

cmdline
project_name
target_triplet)WR()RP(

  )0 P(Note that while expan)HY(sions)YH( in the target and prereq)HY(ui)HY(site)YH(-specific
  assign)HY(ments)YH( happen in the corre)HY(spond)HY(ing)YH( target and prereq)HY(ui)HY(site)YH( contexts,
  respec)HY(tively)YH(, for type/pattern-specific assign)HY(ments)YH( they happen in the scope
  context. Plus, a type/pattern-specific prepend/append is applied at the time
  of expan)HY(sion)YH( for the actual target. For example:)EP(

  ) 24 38 PR(x = s

file{foo}:              # target
{
  x += t    # s t
  y = $x y  # s t y
}

file{foo}: file{bar}    # prerequisite
{
  x += p    # x t p
  y = $x y  # x t p y
}

file{b*}:               # type/pattern
{
  x += w   # <append w>
  y = $x w # <assign s w>
}

x = S

info $\201file{bar}: x\202 # S w
info $\201file{bar}: y\202 # s w)RP(

  )0 1 35 H(5)WB 246 Sn()WB 37 Sn( Func)HY(tions)YH()EH(

  )0 P(This chapter is a work in progress and is
  incom)HY(plete)YH(.)EP(

  )0 P(Func)HY(tions)YH( in )SM(build2)ES( are orga)HY(nized)YH( into fami)HY(lies)YH(, such as the
  )SM($string.*\201\202)ES( family for manip)HY(u)HY(lat)HY(ing)YH( strings or
  )SM($regex.*\201\202)ES( for working with regular expres)HY(sions)YH(. Most func)HY(tions)YH(
  are pure and those that are not, such as )SM($builtin.getenv\201\202)ES(, are
  explic)HY(itly)YH( docu)HY(mented)YH( as such.)EP(

  )0 P(Some func)HY(tions)YH(, such as from the )SM($regex.*\201\202)ES( family, can only
  be called fully qual)HY(i)HY(fied)YH( with their family name. For example:)EP(

  ) 2 35 PR(if $regex.match\201$name, '\201.+\202-\201.+\202'\202
  ...)RP(

  )0 P(While other func)HY(tions)YH( can be called without explicit qual)HY(i)HY(fi)HY(ca)HY(tion)YH(. For
  example:)EP(

  ) 1 22 PR(path = $getenv\201'PATH'\202)RP(

  )0 P(There are also func)HY(tions)YH( that can be called unqual)HY(i)HY(fied)YH( only for certain
  types of argu)HY(ments)YH( \201this fact will be reflected in their synop)HY(sis)YH( and/or
  docu)HY(men)HY(ta)HY(tion)YH(\202. Note, however, that every func)HY(tion)YH( can always be called
  qual)HY(i)HY(fied)YH(.)EP(

  )0 2 36 H(5.1)WB 247 Sn()WB 38 Sn( Builtin Func)HY(tions)YH()EH(

  )0 P(The )SM($builtin.*\201\202)ES( func)HY(tion)YH( family contains funda)HY(men)HY(tal)YH(
  )SM(build2)ES( func)HY(tions)YH(.)EP(

  )0 3 37 H(5.1.1)WB 248 Sn()WB 39 Sn(
  )SM($builtin.defined\201\202)ES()EH(

  ) 1 20 PR($defined\201<variable>\202)RP(

  )0 P(Return true if the spec)HY(i)HY(fied)YH( vari)HY(able)YH( is defined in the calling scope or
  any outer scopes.)EP(

  )0 P(Note that this func)HY(tion)YH( is not pure.)EP(

  )0 3 38 H(5.1.2)WB 249 Sn()WB 40 Sn(
  )SM($builtin.visi)HY(bil)HY(ity)YH(\201\202)ES()EH(

  ) 1 23 PR($visibility\201<variable>\202)RP(

  )0 P(Return vari)HY(able)YH( visi)HY(bil)HY(ity)YH( if it is known and )SM(null)ES(
  other)HY(wise)YH(.)EP(

  )0 P(Possi)HY(ble)YH( visi)HY(bil)HY(ity)YH( value are:)EP(

  ) 5 50 PR(global  -- all outer scopes
project -- this project \201no outer projects\202
scope   -- this scope \201no outer scopes\202
target  -- target and target type/pattern-specific
prereq  -- prerequisite-specific)RP(

  )0 P(Note that this func)HY(tion)YH( is not pure.)EP(

  )0 3 39 H(5.1.3)WB 250 Sn()WB 41 Sn( )SM($builtin.type\201\202)ES()EH(

  ) 1 14 PR($type\201<value>\202)RP(

  )0 P(Return the type name of the value or empty string if untyped.)EP(

  )0 3 40 H(5.1.4)WB 251 Sn()WB 42 Sn( )SM($builtin.null\201\202)ES()EH(

  ) 1 14 PR($null\201<value>\202)RP(

  )0 P(Return true if the value is )SM(null)ES(.)EP(

  )0 3 41 H(5.1.5)WB 252 Sn()WB 43 Sn( )SM($builtin.empty\201\202)ES()EH(

  ) 1 15 PR($empty\201<value>\202)RP(

  )0 P(Return true if the value is empty.)EP(

  )0 3 42 H(5.1.6)WB 253 Sn()WB 44 Sn( )SM($builtin.first\201\202)ES(,
  )SM($builtin.second\201\202)ES()EH(

  ) 2 30 PR($first\201<value>[, <not_pair>]\202
$second\201<value>[, <not_pair>]\202)RP(

  )0 P(Return the first or the second half of a pair, respec)HY(tively)YH(. If a value
  is not a pair, then return )SM(null)ES( unless the
  )SM()I(not_pair)ES()ES( argu)HY(ment)YH( is )SM(true)ES(, in which case
  return the non-pair value.)EP(

  )0 P(If multi)HY(ple)YH( pairs are spec)HY(i)HY(fied)YH(, then return the list of first/second
  halfs. If an element is not a pair, then omit it from the result)HY(ing)YH( list
  unless the )SM()I(not_pair)ES()ES( argu)HY(ment)YH( is )SM(true)ES(, in
  which case add the non-pair element to the list.)EP(

  )0 3 43 H(5.1.7)WB 254 Sn()WB 45 Sn( )SM($builtin.quote\201\202)ES()EH(

  ) 1 27 PR($quote\201<value>[, <escape>]\202)RP(

  )0 P(Quote the value return)HY(ing)YH( its string repre)HY(sen)HY(ta)HY(tion)YH(. If
  )SM()I(escape)ES()ES( is )SM(true)ES(, then also escape \201with a
  back)HY(slash)YH(\202 the quote char)HY(ac)HY(ters)YH( being added \201this is useful if the result
  will be re-parsed, for example as a script command line\202.)EP(

  )0 3 44 H(5.1.8)WB 255 Sn()WB 46 Sn( )SM($builtin.getenv\201\202)ES()EH(

  ) 1 15 PR($getenv\201<name>\202)RP(

  )0 P(Get the value of the envi)HY(ron)HY(ment)YH( vari)HY(able)YH(. Return )SM(null)ES( if
  the envi)HY(ron)HY(ment)YH( vari)HY(able)YH( is not set.)EP(

  )0 P(Note that if the build result can be affected by the vari)HY(able)YH( being
  queried, then it should be reported with the )SM(config.envi)HY(ron)HY(ment)YH()ES(
  direc)HY(tive)YH(.)EP(

  )0 P(Note that this func)HY(tion)YH( is not pure.)EP(

  )0 2 45 H(5.2)WB 256 Sn()WB 47 Sn( String Func)HY(tions)YH()EH(

  )0 3 46 H(5.2.1)WB 257 Sn()WB 48 Sn(
  )SM($string.icas)HY(ecmp)YH(\201\202)ES()EH(

  ) 2 38 PR($string.icasecmp\201<untyped>, <untyped>\202
$icasecmp\201<string>, <string>\202)RP(

  )0 P(Compare ASCII strings ignor)HY(ing)YH( case and return)HY(ing)YH( the boolean value.)EP(

  )0 3 47 H(5.2.2)WB 258 Sn()WB 49 Sn(
  )SM($string.contains\201\202)ES()EH(

  ) 2 49 PR($string.contains\201<untyped>, <untyped>[, <flags>]\202
$contains\201<string>, <string>[, <flags>]\202)RP(

  )0 P(Check if the string \201first argu)HY(ment)YH(\202 contains the given substring \201second
  argu)HY(ment)YH(\202. The substring must not be empty.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 3 51 PR(icase  - compare ignoring case

once   - check if the substring occurs exactly once)RP(

  )0 P(See also )SM($string.starts_with\201\202)ES(,
  )SM($string.ends_with\201\202)ES(, )SM($regex.search\201\202)ES(.)EP(

  )0 3 48 H(5.2.3)WB 259 Sn()WB 50 Sn(
  )SM($string.starts_with\201\202)ES()EH(

  ) 2 52 PR($string.starts_with\201<untyped>, <untyped>[, <flags>]\202
$starts_with\201<string>, <string>[, <flags>]\202)RP(

  )0 P(Check if the string \201first argu)HY(ment)YH(\202 begins with the given prefix \201second
  argu)HY(ment)YH(\202. The prefix must not be empty.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 1 30 PR(icase  - compare ignoring case)RP(

  )0 P(See also )SM($string.contains\201\202)ES(.)EP(

  )0 3 49 H(5.2.4)WB 260 Sn()WB 51 Sn(
  )SM($string.ends_with\201\202)ES()EH(

  ) 2 50 PR($string.ends_with\201<untyped>, <untyped>[, <flags>]\202
$ends_with\201<string>, <string>[, <flags>]\202)RP(

  )0 P(Check if the string \201first argu)HY(ment)YH(\202 ends with the given suffix \201second
  argu)HY(ment)YH(\202. The suffix must not be empty.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 1 30 PR(icase  - compare ignoring case)RP(

  )0 P(See also )SM($string.contains\201\202)ES(.)EP(

  )0 3 50 H(5.2.5)WB 261 Sn()WB 52 Sn( )SM($string.replace\201\202)ES()EH(

  ) 2 52 PR($string.replace\201<untyped>, <from>, <to> [, <flags>]\202
$replace\201<string>, <from>, <to> [, <flags>]\202)RP(

  )0 P(Replace occurences of substring )SM()I(from)ES()ES( with
  )SM()I(to)ES()ES( in a string. The )SM()I(from)ES()ES( substring
  must not be empty.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 5 42 PR(icase       - compare ignoring case

first_only  - only replace the first match

last_only   - only replace the last match)RP(

  )0 P(If both )SM(first_only)ES( and )SM(last_only)ES( flags are
  spec)HY(i)HY(fied)YH(, then )SM()I(from)ES()ES( is replaced only if it occurs in
  the string once.)EP(

  )0 P(See also )SM($regex.replace\201\202)ES(.)EP(

  )0 3 51 H(5.2.6)WB 262 Sn()WB 53 Sn( )SM($string.trim\201\202)ES()EH(

  ) 2 23 PR($string.trim\201<untyped>\202
$trim\201<string>\202)RP(

  )0 P(Trim leading and trail)HY(ing)YH( whites)HY(paces)YH( in a string.)EP(

  )0 3 52 H(5.2.7)WB 263 Sn()WB 54 Sn( )SM($string.lcase\201\202)ES(,
  )SM($string.ucase\201\202)ES()EH(

  ) 4 24 PR($string.lcase\201<untyped>\202
$string.ucase\201<untyped>\202
$lcase\201<string>\202
$ucase\201<string>\202)RP(

  )0 P(Convert ASCII string into lower/upper case.)EP(

  )0 3 53 H(5.2.8)WB 264 Sn()WB 55 Sn( )SM($string.size\201\202)ES()EH(

  ) 4 19 PR($size\201<strings>\202
$size\201<string-set>\202
$size\201<string-map>\202
$size\201<string>\202)RP(

  )0 P(First three forms: return the number of elements in the sequence.)EP(

  )0 P(Fourth form: return the number of char)HY(ac)HY(ters)YH( \201bytes\202 in the string.)EP(

  )0 3 54 H(5.2.9)WB 265 Sn()WB 56 Sn( )SM($string.sort\201\202)ES()EH(

  ) 1 28 PR($sort\201<strings> [, <flags>]\202)RP(

  )0 P(Sort strings in ascend)HY(ing)YH( order.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 3 53 PR(icase - sort ignoring case

dedup - in addition to sorting also remove duplicates)RP(

  )0 3 55 H(5.2.10)WB 266 Sn()WB 57 Sn( )SM($string.find\201\202)ES()EH(

  ) 1 37 PR($find\201<strings>, <string>[, <flags>]\202)RP(

  )0 P(Return true if the string sequence contains the spec)HY(i)HY(fied)YH( string.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 1 29 PR(icase - compare ignoring case)RP(

  )0 P(See also )SM($regex.find_match\201\202)ES( and
  )SM($regex.find_search\201\202)ES(.)EP(

  )0 3 56 H(5.2.11)WB 267 Sn()WB 58 Sn(
  )SM($string.find_index\201\202)ES()EH(

  ) 1 43 PR($find_index\201<strings>, <string>[, <flags>]\202)RP(

  )0 P(Return the index of the first element in the string sequence that is
  equal to the spec)HY(i)HY(fied)YH( string or )SM($size\201strings\202)ES( if none is
  found.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 1 29 PR(icase - compare ignoring case)RP(

  )0 3 57 H(5.2.12)WB 268 Sn()WB 59 Sn( )SM($string.keys\201\202)ES()EH(

  ) 1 19 PR($keys\201<string-map>\202)RP(

  )0 P(Return the list of keys in a string map.)EP(

  )0 P(Note that the result is sorted in ascend)HY(ing)YH( order.)EP(

  )0 2 58 H(5.3)WB 269 Sn()WB 60 Sn( Integer Func)HY(tions)YH()EH(

  )0 3 59 H(5.3.1)WB 270 Sn()WB 61 Sn( )SM($integer.string\201\202)ES()EH(

  ) 2 38 PR($string\201<int64>\202
$string\201<uint64>[, <base>[, <width>]]\202)RP(

  )0 P(Convert an integer to a string. For unsigned inte)HY(gers)YH( we can specify the
  desired base and width. For example:)EP(

  ) 5 65 PR(x = [uint64] 0x0000ffff

c.poptions += "-DOFFSET=$x"                 # -DOFFSET=65535
c.poptions += "-DOFFSET=$string\201$x, 16\202"    # -DOFFSET=0xffff
c.poptions += "-DOFFSET=$string\201$x, 16, 8\202" # -DOFFSET=0x0000ffff)RP(

  )0 3 60 H(5.3.2)WB 271 Sn()WB 62 Sn(
  )SM($integer.integer_sequence\201\202)ES()EH(

  ) 1 43 PR($integer_sequence\201<begin>, <end>[, <step>]\202)RP(

  )0 P(Return the list of uint64 inte)HY(gers)YH( start)HY(ing)YH( from
  )SM()I(begin)ES()ES( \201includ)HY(ing)YH(\202 to )SM()I(end)ES()ES( \201exclud)HY(ing)YH(\202
  with the spec)HY(i)HY(fied)YH( )SM()I(step)ES()ES( or )SM(1)ES( if
  unspec)HY(i)HY(fied)YH(. If )SM()I(begin)ES()ES( is greater than
  )SM()I(end)ES()ES(, empty list is returned.)EP(

  )0 3 61 H(5.3.3)WB 272 Sn()WB 63 Sn( )SM($integer.size\201\202)ES()EH(

  ) 1 13 PR($size\201<ints>\202)RP(

  )0 P(Return the number of elements in the sequence.)EP(

  )0 3 62 H(5.3.4)WB 273 Sn()WB 64 Sn( )SM($integer.sort\201\202)ES()EH(

  ) 1 25 PR($sort\201<ints> [, <flags>]\202)RP(

  )0 P(Sort inte)HY(gers)YH( in ascend)HY(ing)YH( order.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 1 53 PR(dedup - in addition to sorting also remove duplicates)RP(

  )0 3 63 H(5.3.5)WB 274 Sn()WB 65 Sn( )SM($integer.find\201\202)ES()EH(

  ) 1 20 PR($find\201<ints>, <int>\202)RP(

  )0 P(Return true if the integer sequence contains the spec)HY(i)HY(fied)YH( integer.)EP(

  )0 3 64 H(5.3.6)WB 275 Sn()WB 66 Sn(
  )SM($integer.find_index\201\202)ES()EH(

  ) 1 26 PR($find_index\201<ints>, <int>\202)RP(

  )0 P(Return the index of the first element in the integer sequence that is
  equal to the spec)HY(i)HY(fied)YH( integer or )SM($size\201ints\202)ES( if none is
  found.)EP(

  )0 2 65 H(5.4)WB 276 Sn()WB 67 Sn( Bool Func)HY(tions)YH()EH(

  )0 3 66 H(5.4.1)WB 277 Sn()WB 68 Sn( )SM($bool.string\201\202)ES()EH(

  ) 1 15 PR($string\201<bool>\202)RP(

  )0 P(Convert a boolean value to a string literal )SM(true)ES( or
  )SM(false)ES(.)EP(

  )0 2 67 H(5.5)WB 278 Sn()WB 69 Sn( Path Func)HY(tions)YH()EH(

  )0 P(The )SM($path.*\201\202)ES( func)HY(tion)YH( family contains func)HY(tion)YH( that
  manip)HY(u)HY(lat)HY(ing)YH( filesys)HY(tem)YH( paths.)EP(

  )0 3 68 H(5.5.1)WB 279 Sn()WB 70 Sn( )SM($path.string\201\202)ES()EH(

  ) 1 16 PR($string\201<paths>\202)RP(

  )0 P(Return the tradi)HY(tional)YH( string repre)HY(sen)HY(ta)HY(tion)YH( of a path \201or a list of
  string repre)HY(sen)HY(ta)HY(tions)YH( for a list of paths\202. In partic)HY(u)HY(lar)YH(, for direc)HY(tory)YH(
  paths, the tradi)HY(tional)YH( repre)HY(sen)HY(ta)HY(tion)YH( does not include the trail)HY(ing)YH(
  direc)HY(tory)YH( sepa)HY(ra)HY(tor)YH( \201except for the POSIX root direc)HY(tory)YH(\202. See
  )SM($repre)HY(sen)HY(ta)HY(tion)YH(\201\202)ES( below for the precise string
  repre)HY(sen)HY(ta)HY(tion)YH(.)EP(

  )0 3 69 H(5.5.2)WB 280 Sn()WB 71 Sn(
  )SM($path.posix_string\201\202)ES()EH(

  ) 2 29 PR($posix_string\201<paths>\202
$path.posix_string\201<untyped>\202)RP(

  )0 P(Return the tradi)HY(tional)YH( string repre)HY(sen)HY(ta)HY(tion)YH( of a path \201or a list of
  string repre)HY(sen)HY(ta)HY(tions)YH( for a list of paths\202 using the POSIX direc)HY(tory)YH(
  sepa)HY(ra)HY(tors)YH( \201forward slashes\202.)EP(

  )0 3 70 H(5.5.3)WB 281 Sn()WB 72 Sn(
  )SM($path.repre)HY(sen)HY(ta)HY(tion)YH(\201\202)ES()EH(

  ) 1 24 PR($representation\201<paths>\202)RP(

  )0 P(Return the precise string repre)HY(sen)HY(ta)HY(tion)YH( of a path \201or a list of string
  repre)HY(sen)HY(ta)HY(tions)YH( for a list of paths\202. In partic)HY(u)HY(lar)YH(, for direc)HY(tory)YH( paths,
  the precise repre)HY(sen)HY(ta)HY(tion)YH( includes the trail)HY(ing)YH( direc)HY(tory)YH( sepa)HY(ra)HY(tor)YH(. See
  )SM($string\201\202)ES( above for the tradi)HY(tional)YH( string repre)HY(sen)HY(ta)HY(tion)YH(.)EP(

  )0 3 71 H(5.5.4)WB 282 Sn()WB 73 Sn(
  )SM($path.posix_repre)HY(sen)HY(ta)HY(tion)YH(\201\202)ES()EH(

  ) 2 37 PR($posix_representation\201<paths>\202
$path.posix_representation\201<untyped>\202)RP(

  )0 P(Return the precise string repre)HY(sen)HY(ta)HY(tion)YH( of a path \201or a list of string
  repre)HY(sen)HY(ta)HY(tions)YH( for a list of paths\202 using the POSIX direc)HY(tory)YH( sepa)HY(ra)HY(tors)YH(
  \201forward slashes\202.)EP(

  )0 3 72 H(5.5.5)WB 283 Sn()WB 74 Sn( )SM($path.abso)HY(lute)YH(\201\202)ES()EH(

  ) 2 25 PR($absolute\201<path>\202
$path.absolute\201<untyped>\202)RP(

  )0 P(Return true if the path is abso)HY(lute)YH( and false other)HY(wise)YH(.)EP(

  )0 3 73 H(5.5.6)WB 284 Sn()WB 75 Sn( )SM($path.simple\201\202)ES()EH(

  ) 2 23 PR($simple\201<path>\202
$path.simple\201<untyped>\202)RP(

  )0 P(Return true if the path is simple, that is, has no dire)HY(crory)YH( compo)HY(nent)YH(,
  and false other)HY(wise)YH(.)EP(

  )0 P(Note that on POSIX )SM(/foo)ES( is not a simple path \201it is
  )SM(foo)ES( in the root direc)HY(tory)YH(\202 while )SM(/)ES( is \201it is the
  root direc)HY(tory)YH(\202.)EP(

  )0 3 74 H(5.5.7)WB 285 Sn()WB 76 Sn( )SM($path.sub_path\201\202)ES()EH(

  ) 2 36 PR($sub_path\201<path>, <path>\202
$path.sub_path\201<untyped>, <untyped>\202)RP(

  )0 P(Return true if the path spec)HY(i)HY(fied)YH( as the first argu)HY(ment)YH( is a sub-path of
  the one spec)HY(i)HY(fied)YH( as the second argu)HY(ment)YH( \201in other words, the second
  argu)HY(ment)YH( is a prefix of the first\202 and false other)HY(wise)YH(. Both paths are
  expected to be normal)HY(ized)YH(. Note that this func)HY(tion)YH( returns true if the paths
  are equal. Empty path is consid)HY(ered)YH( a prefix of any path.)EP(

  )0 3 75 H(5.5.8)WB 286 Sn()WB 77 Sn(
  )SM($path.super_path\201\202)ES()EH(

  ) 2 38 PR($super_path\201<path>, <path>\202
$path.super_path\201<untyped>, <untyped>\202)RP(

  )0 P(Return true if the path spec)HY(i)HY(fied)YH( as the first argu)HY(ment)YH( is a super-path
  of the one spec)HY(i)HY(fied)YH( as the second argu)HY(ment)YH( \201in other words, the second
  argu)HY(ment)YH( is a suffix of the first\202 and false other)HY(wise)YH(. Both paths are
  expected to be normal)HY(ized)YH(. Note that this func)HY(tion)YH( returns true if the paths
  are equal. Empty path is consid)HY(ered)YH( a suffix of any path.)EP(

  )0 3 76 H(5.5.9)WB 287 Sn()WB 78 Sn( )SM($path.direc)HY(tory)YH(\201\202)ES()EH(

  ) 2 26 PR($directory\201<paths>\202
$path.directory\201<untyped>\202)RP(

  )0 P(Return the direc)HY(tory)YH( part of a path \201or a list of direc)HY(tory)YH( parts for a
  list of paths\202 or an empty path if there is no direc)HY(tory)YH(. A direc)HY(tory)YH( of a
  root direc)HY(tory)YH( is an empty path.)EP(

  )0 3 77 H(5.5.10)WB 288 Sn()WB 79 Sn(
  )SM($path.root_direc)HY(tory)YH(\201\202)ES()EH(

  ) 2 31 PR($root_directory\201<paths>\202
$path.root_directory\201<untyped>\202)RP(

  )0 P(Return the root direc)HY(tory)YH( of a path \201or a list of root direc)HY(to)HY(ries)YH( for a
  list of paths\202 or an empty path if the spec)HY(i)HY(fied)YH( path is not abso)HY(lute)YH(.)EP(

  )0 3 78 H(5.5.11)WB 289 Sn()WB 80 Sn( )SM($path.leaf\201\202)ES()EH(

  ) 4 33 PR($leaf\201<paths>\202
$path.leaf\201<untyped>\202
$leaf\201<paths>, <dir-path>\202
$path.leaf\201<untyped>, <dir-path>\202)RP(

  )0 P(First form \201one argu)HY(ment)YH(\202: return the last compo)HY(nent)YH( of a path \201or a list
  of last compo)HY(nents)YH( for a list of paths\202.)EP(

  )0 P(Second form \201two argu)HY(ments)YH(\202: return a path without the spec)HY(i)HY(fied)YH(
  direc)HY(tory)YH( part \201or a list of paths without the direc)HY(tory)YH( part for a list of
  paths\202. Return an empty path if the paths are the same. Issue diag)HY(nos)HY(tics)YH(
  and fail if the direc)HY(tory)YH( is not a prefix of the path. Note: expects both
  paths to be normal)HY(ized)YH(.)EP(

  )0 3 79 H(5.5.12)WB 290 Sn()WB 81 Sn( )SM($path.rela)HY(tive)YH(\201\202)ES()EH(

  ) 2 37 PR($relative\201<paths>, <dir-path>\202
$path.relative\201<untyped>, <dir-path>\202)RP(

  )0 P(Return the path rela)HY(tive)YH( to the spec)HY(i)HY(fied)YH( direc)HY(tory)YH( that is equiv)HY(a)HY(lent)YH( to
  the spec)HY(i)HY(fied)YH( path \201or a list of rela)HY(tive)YH( paths for a list of spec)HY(i)HY(fied)YH(
  paths\202. Issue diag)HY(nos)HY(tics)YH( and fail if a rela)HY(tive)YH( path cannot be derived \201for
  example, paths are on differ)HY(ent)YH( drives on Windows\202.)EP(

  )0 P(Note: to check if a path if rela)HY(tive)YH(, use
  )SM($path.abso)HY(lute)YH(\201\202)ES(.)EP(

  )0 3 80 H(5.5.13)WB 291 Sn()WB 82 Sn( )SM($path.base\201\202)ES()EH(

  ) 2 21 PR($base\201<paths>\202
$path.base\201<untyped>\202)RP(

  )0 P(Return the base part \201without the exten)HY(sion)YH(\202 of a path \201or a list of base
  parts for a list of paths\202.)EP(

  )0 3 81 H(5.5.14)WB 292 Sn()WB 83 Sn( )SM($path.exten)HY(sion)YH(\201\202)ES()EH(

  ) 2 26 PR($extension\201<path>\202
$path.extension\201<untyped>\202)RP(

  )0 P(Return the exten)HY(sion)YH( part \201without the dot\202 of a path or empty string if
  there is no exten)HY(sion)YH(.)EP(

  )0 3 82 H(5.5.15)WB 293 Sn()WB 84 Sn( )SM($path.complete\201\202)ES()EH(

  ) 2 25 PR($complete\201<paths>\202
$path.complete\201<untyped>\202)RP(

  )0 P(Complete the path \201or list of paths\202 by prepend)HY(ing)YH( the current working
  direc)HY(tory)YH( unless the path is already abso)HY(lute)YH(.)EP(

  )0 3 83 H(5.5.16)WB 294 Sn()WB 85 Sn(
  )SM($path.canon)HY(i)HY(cal)HY(ize)YH(\201\202)ES()EH(

  ) 2 29 PR($canonicalize\201<paths>\202
$path.canonicalize\201<untyped>\202)RP(

  )0 P(Canon)HY(i)HY(cal)HY(ize)YH( the path \201or list of paths\202 by convert)HY(ing)YH( all the direc)HY(tory)YH(
  sepa)HY(ra)HY(tors)YH( to the canon)HY(i)HY(cal)YH( form for the host plat)HY(form)YH(. Note that multi)HY(ple)YH(
  direc)HY(tory)YH( sepa)HY(ra)HY(tors)YH( are not collapsed.)EP(

  )0 3 84 H(5.5.17)WB 295 Sn()WB 86 Sn( )SM($path.normal)HY(ize)YH(\201\202)ES(,
  )SM($path.try_normal)HY(ize)YH(\201\202)ES()EH(

  ) 4 30 PR($normalize\201<paths>\202
$path.normalize\201<untyped>\202
$try_normalize\201<path>\202
$path.try_normalize\201<untyped>\202)RP(

  )0 P(Normal)HY(ize)YH( the path \201or list of paths\202 by collaps)HY(ing)YH( the )SM(.)ES(
  and )SM(..)ES( compo)HY(nents)YH( if possi)HY(ble)YH(, collaps)HY(ing)YH( multi)HY(ple)YH( direc)HY(tory)YH(
  sepa)HY(ra)HY(tors)YH(, and convert)HY(ing)YH( all the direc)HY(tory)YH( sepa)HY(ra)HY(tors)YH( to the canon)HY(i)HY(cal)YH(
  form for the host plat)HY(form)YH(.)EP(

  )0 P(If the result)HY(ing)YH( path would be invalid, the )SM($normal)HY(ize)YH(\201\202)ES(
  version issues diag)HY(nos)HY(tics)YH( and fails while the )SM($try_normal)HY(ize)YH(\201\202)ES(
  version returns )SM(null)ES(. Note that )SM($try_normal)HY(ize)YH(\201\202)ES(
  only accepts a single path.)EP(

  )0 3 85 H(5.5.18)WB 296 Sn()WB 87 Sn( )SM($path.actu)HY(al)HY(ize)YH(\201\202)ES(,
  )SM($path.try_actu)HY(al)HY(ize)YH(\201\202)ES()EH(

  ) 4 30 PR($actualize\201<paths>\202
$path.actualize\201<untyped>\202
$try_actualize\201<path>\202
$path.try_actualize\201<untyped>\202)RP(

  )0 P(Actu)HY(al)HY(ize)YH( the path \201or list of paths\202 by first normal)HY(iz)HY(ing)YH( it and then
  for host plat)HY(forms)YH( with case-insen)HY(si)HY(tive)YH( filesys)HY(tems)YH( obtain)HY(ing)YH( the actual
  spelling of the path.)EP(

  )0 P(Only an abso)HY(lute)YH( path can be actu)HY(al)HY(ized)YH(. If a path compo)HY(nent)YH( does not
  exist, then its \201and all subse)HY(quent)YH(\202 spelling is unchanged. Note that this
  is a poten)HY(tially)YH( expen)HY(sive)YH( oper)HY(a)HY(tion)YH(.)EP(

  )0 P(If the result)HY(ing)YH( path would be invalid or in case of filesys)HY(tem)YH( errors
  \201other than non-exis)HY(tent)YH( compo)HY(nent)YH(\202, the )SM($actu)HY(al)HY(ize)YH(\201\202)ES( version
  issues diag)HY(nos)HY(tics)YH( and fails while the )SM($try_actu)HY(al)HY(ize)YH(\201\202)ES( version
  returns )SM(null)ES(. Note that )SM($try_actu)HY(al)HY(ize)YH(\201\202)ES( only
  accepts a single path.)EP(

  )0 P(Note that this func)HY(tion)YH( is not pure.)EP(

  )0 3 86 H(5.5.19)WB 297 Sn()WB 88 Sn( )SM($path.size\201\202)ES()EH(

  ) 2 14 PR($size\201<paths>\202
$size\201<path>\202)RP(

  )0 P(First form: return the number of elements in the paths sequence.)EP(

  )0 P(Second form: return the number of char)HY(ac)HY(ters)YH( \201bytes\202 in the path. Note
  that for )SM(dir_path)ES( the result does not include the trail)HY(ing)YH(
  direc)HY(tory)YH( sepa)HY(ra)HY(tor)YH( \201except for the POSIX root direc)HY(tory)YH(\202.)EP(

  )0 3 87 H(5.5.20)WB 298 Sn()WB 89 Sn( )SM($path.sort\201\202)ES()EH(

  ) 1 25 PR($sort\201<paths>[, <flags>]\202)RP(

  )0 P(Sort paths in ascend)HY(ing)YH( order. Note that on host plat)HY(forms)YH( with a
  case-insen)HY(si)HY(tive)YH( filesys)HY(tem)YH( the order is case-insen)HY(si)HY(tive)YH(.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 1 53 PR(dedup - in addition to sorting also remove duplicates)RP(

  )0 3 88 H(5.5.21)WB 299 Sn()WB 90 Sn( )SM($path.find\201\202)ES()EH(

  ) 1 22 PR($find\201<paths>, <path>\202)RP(

  )0 P(Return true if the paths sequence contains the spec)HY(i)HY(fied)YH( path. Note that
  on host plat)HY(forms)YH( with a case-insen)HY(si)HY(tive)YH( filesys)HY(tem)YH( the compar)HY(i)HY(son)YH( is
  case-insen)HY(si)HY(tive)YH(.)EP(

  )0 3 89 H(5.5.22)WB 300 Sn()WB 91 Sn(
  )SM($path.find_index\201\202)ES()EH(

  ) 1 28 PR($find_index\201<paths>, <path>\202)RP(

  )0 P(Return the index of the first element in the paths sequence that is equal
  to the spec)HY(i)HY(fied)YH( path or )SM($size\201paths\202)ES( if none is found. Note
  that on host plat)HY(forms)YH( with a case-insen)HY(si)HY(tive)YH( filesys)HY(tem)YH( the compar)HY(i)HY(son)YH( is
  case-insen)HY(si)HY(tive)YH(.)EP(

  )0 3 90 H(5.5.23)WB 301 Sn()WB 92 Sn( )SM($path.match\201\202)ES()EH(

  ) 1 46 PR($path.match\201<entry>, <pattern>[, <start-dir>]\202)RP(

  )0 P(Match a filesys)HY(tem)YH( entry name against a name pattern \201both are strings\202,
  or a filesys)HY(tem)YH( entry path against a path pattern. For the latter case the
  start direc)HY(tory)YH( may also be required \201see below\202. The pattern is a
  shell-like wild)HY(card)YH( pattern. The seman)HY(tics)YH( of the
  )SM()I(pattern)ES()ES( and )SM()I(entry)ES()ES( argu)HY(ments)YH( is
  deter)HY(mined)YH( accord)HY(ing)YH( to the follow)HY(ing)YH( rules:)EP(

  )0 P(1. The argu)HY(ments)YH( must be of the string or path types, or be untyped.)EP(

  )0 P(2. If one of the argu)HY(ments)YH( is typed, then the other one must be of the
  same type or be untyped. In the later case, an untyped argu)HY(ment)YH( is converted
  to the type of the other argu)HY(ment)YH(.)EP(

  )0 P(3. If both argu)HY(ments)YH( are untyped and the start direc)HY(tory)YH( is spec)HY(i)HY(fied)YH(,
  then the argu)HY(ments)YH( are converted to the path type.)EP(

  )0 P(4. If both argu)HY(ments)YH( are untyped and the start direc)HY(tory)YH( is not
  spec)HY(i)HY(fied)YH(, then, if one of the argu)HY(ments)YH( is syntac)HY(ti)HY(cally)YH( a path \201the value
  contains a direc)HY(tory)YH( sepa)HY(ra)HY(tor)YH(\202, then they are converted to the path type,
  other)HY(wise)YH( -- to the string type \201match as names\202.)EP(

  )0 P(If pattern and entry paths are both either abso)HY(lute)YH( or rela)HY(tive)YH( and not
  empty, and the first pattern compo)HY(nent)YH( is not a self-match)HY(ing)YH( wild)HY(card)YH(
  \201doesn't contain )SM(***)ES(\202, then the start direc)HY(tory)YH( is not
  required, and is ignored if spec)HY(i)HY(fied)YH(. Other)HY(wise)YH(, the start direc)HY(tory)YH( must
  be spec)HY(i)HY(fied)YH( and be an abso)HY(lute)YH( path.)EP(

  )0 2 91 H(5.6)WB 302 Sn()WB 93 Sn( Name Func)HY(tions)YH()EH(

  )0 P(The )SM($name.*\201\202)ES( func)HY(tion)YH( family contains func)HY(tion)YH( that operate
  on target and prereq)HY(ui)HY(site)YH( names. See also the )0 105 1 A()SM($target.*\201\202)ES( func)HY(tion)YH( family)105 0 TN TL()Ec /AF f D( for
  func)HY(tions)YH( that operate on actual targets.)EP(

  )0 3 92 H(5.6.1)WB 303 Sn()WB 94 Sn( )SM($name.name\201\202)ES()EH(

  ) 1 14 PR($name\201<names>\202)RP(

  )0 P(Return the name of a target \201or a list of names for a list of
  targets\202.)EP(

  )0 3 93 H(5.6.2)WB 304 Sn()WB 95 Sn( )SM($name.exten)HY(sion)YH(\201\202)ES()EH(

  ) 1 18 PR($extension\201<name>\202)RP(

  )0 P(Return the exten)HY(sion)YH( of a target.)EP(

  )0 P(Note that this func)HY(tion)YH( returns )SM(null)ES( if the exten)HY(sion)YH( is
  unspec)HY(i)HY(fied)YH( \201default\202 and empty string if it's spec)HY(i)HY(fied)YH( as no
  exten)HY(sion)YH(.)EP(

  )0 3 94 H(5.6.3)WB 305 Sn()WB 96 Sn( )SM($name.direc)HY(tory)YH(\201\202)ES()EH(

  ) 1 19 PR($directory\201<names>\202)RP(

  )0 P(Return the direc)HY(tory)YH( of a target \201or a list of direc)HY(to)HY(ries)YH( for a list of
  targets\202.)EP(

  )0 3 95 H(5.6.4)WB 306 Sn()WB 97 Sn(
  )SM($name.target_type\201\202)ES()EH(

  ) 1 21 PR($target_type\201<names>\202)RP(

  )0 P(Return the target type name of a target \201or a list of target type names
  for a list of targets\202.)EP(

  )0 3 96 H(5.6.5)WB 307 Sn()WB 98 Sn( )SM($name.project\201\202)ES()EH(

  ) 1 16 PR($project\201<name>\202)RP(

  )0 P(Return the project of a target or )SM(null)ES( if not
  project-qual)HY(i)HY(fied)YH(.)EP(

  )0 3 97 H(5.6.6)WB 308 Sn()WB 99 Sn( )SM($name.is_a\201\202)ES()EH(

  ) 1 28 PR($is_a\201<name>, <target-type>\202)RP(

  )0 P(Return true if the )SM()I(name)ES()ES('s target type is-a
  )SM()I(target-type)ES()ES(. Note that this is a dynamic type check that
  takes into account target type inher)HY(i)HY(tance)YH(.)EP(

  )0 3 98 H(5.6.7)WB 309 Sn()WB 100 Sn( )SM($name.filter\201\202)ES(,
  )SM($name.filter_out\201\202)ES()EH(

  ) 2 36 PR($filter\201<names>, <target-types>\202
$filter_out\201<names>, <target-types>\202)RP(

  )0 P(Return names with target types which are-a \201)SM(filter)ES(\202 or not
  are-a \201)SM(filter_out)ES(\202 one of )SM()I(target-types)ES()ES(. See
  )SM($is_a\201\202)ES( for back)HY(ground)YH(.)EP(

  )0 3 99 H(5.6.8)WB 310 Sn()WB 101 Sn( )SM($name.size\201\202)ES()EH(

  ) 1 14 PR($size\201<names>\202)RP(

  )0 P(Return the number of elements in the sequence.)EP(

  )0 3 100 H(5.6.9)WB 311 Sn()WB 102 Sn( )SM($name.sort\201\202)ES()EH(

  ) 1 25 PR($sort\201<names>[, <flags>]\202)RP(

  )0 P(Sort names in ascend)HY(ing)YH( order.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 1 53 PR(dedup - in addition to sorting also remove duplicates)RP(

  )0 3 101 H(5.6.10)WB 312 Sn()WB 103 Sn( )SM($name.find\201\202)ES()EH(

  ) 1 22 PR($find\201<names>, <name>\202)RP(

  )0 P(Return true if the name sequence contains the spec)HY(i)HY(fied)YH( name.)EP(

  )0 3 102 H(5.6.11)WB 313 Sn()WB 104 Sn(
  )SM($name.find_index\201\202)ES()EH(

  ) 1 28 PR($find_index\201<names>, <name>\202)RP(

  )0 P(Return the index of the first element in the name sequence that is equal
  to the spec)HY(i)HY(fied)YH( name or )SM($size\201names\202)ES( if none is found.)EP(

  )0 2 103 H(5.7)WB 314 Sn()WB 105 Sn( Target Func)HY(tions)YH()EH(

  )0 P(The )SM($target.*\201\202)ES( func)HY(tion)YH( family contains func)HY(tion)YH( that
  operate on targets. See also the )0 93 1 A()SM($name.*\201\202)ES( func)HY(tion)YH( family)93 0 TN TL()Ec /AF f D( for
  func)HY(tions)YH( that operate on target \201and prereq)HY(ui)HY(site)YH(\202 names.)EP(

  )0 3 104 H(5.7.1)WB 315 Sn()WB 106 Sn( )SM($target.path\201\202)ES()EH(

  ) 1 14 PR($path\201<names>\202)RP(

  )0 P(Return the path of a target \201or a list of paths for a list of targets\202.
  The path must be assigned, which normally happens during match. As a result,
  this func)HY(tion)YH( is normally called form a recipe.)EP(

  )0 P(Note that while this func)HY(tion)YH( is tech)HY(ni)HY(cally)YH( not pure, we don't mark it
  as such since it can only be called \201normally form a recipe\202 after the
  target has been matched, meaning that this target is a prereq)HY(ui)HY(site)YH( and
  there)HY(fore)YH( this impu)HY(rity)YH( has been accounted for.)EP(

  )0 3 105 H(5.7.2)WB 316 Sn()WB 107 Sn(
  )SM($target.process_path\201\202)ES()EH(

  ) 1 21 PR($process_path\201<name>\202)RP(

  )0 P(Return the process path of an executable target.)EP(

  )0 P(Note that while this func)HY(tion)YH( is not tech)HY(ni)HY(cally)YH( pure, we don't mark it
  as such for the same reasons as for )SM($path\201\202)ES( above.)EP(

  )0 2 106 H(5.8)WB 317 Sn()WB 108 Sn( Regex Func)HY(tions)YH()EH(

  )0 P(The )SM($regex.*\201\202)ES( func)HY(tion)YH( family contains func)HY(tion)YH( that
  provide compre)HY(hen)HY(sive)YH( regular expres)HY(sion)YH( match)HY(ing)YH( and substi)HY(tu)HY(tion)YH(
  facil)HY(i)HY(ties)YH(. The supported regular expres)HY(sion)YH( flavor is ECMAScript \201more
  specif)HY(i)HY(cally)YH(, ECMA-262-based C++11 regular expres)HY(sions)YH(\202.)EP(

  )0 P(In the )SM($regex.*\201\202)ES( func)HY(tions)YH( the substi)HY(tu)HY(tion)YH( escape
  sequences in the format string \201the )SM()I(fmt)ES()ES( argu)HY(ment)YH(\202 are
  extended with a subset of the Perl escape sequences: )SM(\200n)ES(,
  )SM(\200u)ES(, )SM(\200l)ES(, )SM(\200U)ES(, )SM(\200L)ES(,
  )SM(\200E)ES(, )SM(\2001)ES( ... )SM(\2009)ES(, and )SM(\200\200)ES(.
  Note that the stan)HY(dard)YH( ECMAScript escape sequences \201)SM($1)ES(,
  )SM($2)ES(, )SM($&)ES(, etc\202 are still supported.)EP(

  )0 P(Note that func)HY(tions)YH( from the )SM($regex.*\201\202)ES( family can only be
  called fully qual)HY(i)HY(fied)YH( with their family name. For example:)EP(

  ) 2 35 PR(if $regex.match\201$name, '\201.+\202-\201.+\202'\202
  ...)RP(

  )0 3 107 H(5.8.1)WB 318 Sn()WB 109 Sn( )SM($regex.match\201\202)ES()EH(

  ) 1 38 PR($regex.match\201<val>, <pat> [, <flags>]\202)RP(

  )0 P(Match a value of an arbi)HY(trary)YH( type against the regular expres)HY(sion)YH(.
  Convert the value to string prior to match)HY(ing)YH(. Return the boolean value
  unless )SM(return_subs)ES( flag is spec)HY(i)HY(fied)YH( \201see below\202, in which case
  return names \201or )SM(null)ES( if no match\202.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 5 63 PR(icase       - match ignoring case

return_subs - return names \201rather than boolean\202, that contain
              sub-strings that match the marked sub-expressions
              and null if no match)RP(

  )0 3 108 H(5.8.2)WB 319 Sn()WB 110 Sn(
  )SM($regex.find_match\201\202)ES()EH(

  ) 1 44 PR($regex.find_match\201<vals>, <pat> [, <flags>]\202)RP(

  )0 P(Match list elements against the regular expres)HY(sion)YH( and return true if the
  match is found. Convert the elements to strings prior to match)HY(ing)YH(.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 1 27 PR(icase - match ignoring case)RP(

  )0 3 109 H(5.8.3)WB 320 Sn()WB 111 Sn(
  )SM($regex.filter_match\201\202)ES(,
  )SM($regex.filter_out_match\201\202)ES()EH(

  ) 2 50 PR($regex.filter_match\201<vals>, <pat> [, <flags>]\202
$regex.filter_out_match\201<vals>, <pat> [, <flags>]\202)RP(

  )0 P(Return elements of a list that match \201)SM(filter)ES(\202 or do not
  match \201)SM(filter_out)ES(\202 the regular expres)HY(sion)YH(. Convert the elements
  to strings prior to match)HY(ing)YH(.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 1 27 PR(icase - match ignoring case)RP(

  )0 3 110 H(5.8.4)WB 321 Sn()WB 112 Sn( )SM($regex.search\201\202)ES()EH(

  ) 1 39 PR($regex.search\201<val>, <pat> [, <flags>]\202)RP(

  )0 P(Deter)HY(mine)YH( if there is a match between the regular expres)HY(sion)YH( and some
  part of a value of an arbi)HY(trary)YH( type. Convert the value to string prior to
  search)HY(ing)YH(. Return the boolean value unless )SM(return_match)ES( or
  )SM(return_subs)ES( flag is spec)HY(i)HY(fied)YH( \201see below\202 in which case return
  names \201)SM(null)ES( if no match\202.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 9 67 PR(icase        - match ignoring case

return_match - return names \201rather than boolean\202, that contain a
               sub-string that matches the whole regular expression
               and null if no match

return_subs  - return names \201rather than boolean\202, that contain
               sub-strings that match the marked sub-expressions
               and null if no match)RP(

  )0 P(If both )SM(return_match)ES( and )SM(return_subs)ES( flags are
  spec)HY(i)HY(fied)YH( then the sub-string that matches the whole regular expres)HY(sion)YH(
  comes first.)EP(

  )0 P(See also )SM($string.contains\201\202)ES(,
  )SM($string.starts_with\201\202)ES(, )SM($string.ends_with\201\202)ES(.)EP(

  )0 3 111 H(5.8.5)WB 322 Sn()WB 113 Sn(
  )SM($regex.find_search\201\202)ES()EH(

  ) 1 45 PR($regex.find_search\201<vals>, <pat> [, <flags>]\202)RP(

  )0 P(Deter)HY(mine)YH( if there is a match between the regular expres)HY(sion)YH( and some
  part of any of the list elements. Convert the elements to strings prior to
  match)HY(ing)YH(.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 1 27 PR(icase - match ignoring case)RP(

  )0 3 112 H(5.8.6)WB 323 Sn()WB 114 Sn(
  )SM($regex.filter_search\201\202)ES(,
  )SM($regex.filter_out_search\201\202)ES()EH(

  ) 2 51 PR($regex.filter_search\201<vals>, <pat> [, <flags>]\202
$regex.filter_out_search\201<vals>, <pat> [, <flags>]\202)RP(

  )0 P(Return elements of a list for which there is a match
  \201)SM(filter)ES(\202 or no match \201)SM(filter_out)ES(\202 between the
  regular expres)HY(sion)YH( and some part of the element. Convert the elements to
  strings prior to match)HY(ing)YH(.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 1 27 PR(icase - match ignoring case)RP(

  )0 3 113 H(5.8.7)WB 324 Sn()WB 115 Sn( )SM($regex.replace\201\202)ES()EH(

  ) 1 47 PR($regex.replace\201<val>, <pat>, <fmt> [, <flags>]\202)RP(

  )0 P(Replace matched parts in a value of an arbi)HY(trary)YH( type, using the format
  string. Convert the value to string prior to match)HY(ing)YH(. The result value is
  always untyped, regard)HY(less)YH( of the argu)HY(ment)YH( type.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 6 62 PR(icase             - match ignoring case

format_first_only - only replace the first match

format_no_copy    - do not copy unmatched value parts into the
                    result)RP(

  )0 P(If both )SM(format_first_only)ES( and )SM(format_no_copy)ES(
  flags are spec)HY(i)HY(fied)YH( then the result will only contain the replace)HY(ment)YH( of the
  first match.)EP(

  )0 P(See also )SM($string.replace\201\202)ES(.)EP(

  )0 3 114 H(5.8.8)WB 325 Sn()WB 116 Sn(
  )SM($regex.replace_lines\201\202)ES()EH(

  ) 1 53 PR($regex.replace_lines\201<val>, <pat>, <fmt> [, <flags>]\202)RP(

  )0 P(Convert the value to string, parse it into lines and for each line apply
  the )SM($regex.replace\201\202)ES( func)HY(tion)YH( with the spec)HY(i)HY(fied)YH( pattern,
  format, and flags. If the format argu)HY(ment)YH( is )SM(null)ES(, omit the
  "all-)SM(null)ES(" replace)HY(ments)YH( for the matched lines from the result.
  Return unmatched lines and line replace)HY(ments)YH( as a )SM(name)ES( list
  unless )SM(return_lines)ES( flag is spec)HY(i)HY(fied)YH( \201see below\202, in which
  case return a single multi-line simple )SM(name)ES( value.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported in addi)HY(tion)YH( to the
  )SM($regex.replace\201\202)ES( func)HY(tion)YH('s flags:)EP(

  ) 3 67 PR(return_lines - return the simple name \201rather than a name list\202
               containing the unmatched lines and line replacements
               separated with newlines.)RP(

  )0 P(Note that if )SM(format_no_copy)ES( is spec)HY(i)HY(fied)YH(, unmatched lines
  are not copied either.)EP(

  )0 3 115 H(5.8.9)WB 326 Sn()WB 117 Sn( )SM($regex.split\201\202)ES()EH(

  ) 1 45 PR($regex.split\201<val>, <pat>, <fmt> [, <flags>]\202)RP(

  )0 P(Split a value of an arbi)HY(trary)YH( type into a list of unmatched value parts
  and replace)HY(ments)YH( of the matched parts, omit)HY(ting)YH( empty ones \201unless the
  )SM(format_copy_empty)ES( flag is spec)HY(i)HY(fied)YH(\202. Convert the value to
  string prior to match)HY(ing)YH(.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 6 62 PR(icase             - match ignoring case

format_no_copy    - do not copy unmatched value parts into the
                    result

format_copy_empty - copy empty elements into the result)RP(

  )0 3 116 H(5.8.10)WB 327 Sn()WB 118 Sn( )SM($regex.merge\201\202)ES()EH(

  ) 1 58 PR($regex.merge\201<vals>, <pat>, <fmt> [, <delim> [, <flags>]]\202)RP(

  )0 P(Replace matched parts in a list of elements using the regex format
  string. Convert the elements to strings prior to match)HY(ing)YH(. The result value
  is untyped and contains concate)HY(na)HY(tion)YH( of trans)HY(formed)YH( non-empty elements
  \201unless the )SM(format_copy_empty)ES( flag is spec)HY(i)HY(fied)YH(\202 option)HY(ally)YH(
  sepa)HY(rated)YH( with a delim)HY(iter)YH(.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 8 62 PR(icase             - match ignoring case

format_first_only - only replace the first match

format_no_copy    - do not copy unmatched value parts into the
                    result

format_copy_empty - copy empty elements into the result)RP(

  )0 P(If both )SM(format_first_only)ES( and )SM(format_no_copy)ES(
  flags are spec)HY(i)HY(fied)YH( then the result will be a concate)HY(na)HY(tion)YH( of only the
  first match replace)HY(ments)YH(.)EP(

  )0 3 117 H(5.8.11)WB 328 Sn()WB 119 Sn( )SM($regex.apply\201\202)ES()EH(

  ) 1 46 PR($regex.apply\201<vals>, <pat>, <fmt> [, <flags>]\202)RP(

  )0 P(Replace matched parts of each element in a list using the regex format
  string. Convert the elements to strings prior to match)HY(ing)YH(. Return a list of
  trans)HY(formed)YH( elements, omit)HY(ting)YH( the empty ones \201unless the
  )SM(format_copy_empty)ES( flag is spec)HY(i)HY(fied)YH(\202.)EP(

  )0 P(The follow)HY(ing)YH( flags are supported:)EP(

  ) 8 62 PR(icase             - match ignoring case

format_first_only - only replace the first match

format_no_copy    - do not copy unmatched value parts into the
                    result

format_copy_empty - copy empty elements into the result)RP(

  )0 P(If both )SM(format_first_only)ES( and )SM(format_no_copy)ES(
  flags are spec)HY(i)HY(fied)YH( then the result elements will only contain the
  replace)HY(ment)YH( of the first match.)EP(

  )0 2 118 H(5.9)WB 329 Sn()WB 120 Sn( JSON Func)HY(tions)YH()EH(

  )0 P(The )SM($json.*\201\202)ES( func)HY(tion)YH( family contains func)HY(tion)YH( that operate
  on the JSON types: )SM(json)ES(, )SM(json_array)ES(, and
  )SM(json_object)ES(. For example:)EP(

  ) 9 48 PR(j = [json] one@1 two@abc three@\201[json] x@1 y@-1\202

for m: $j
{
  n = $member_name\201$m\202
  v = $member_value\201$m\202

  info $n $value_type\201$v\202 $v
})RP(

  )0 3 119 H(5.9.1)WB 330 Sn()WB 121 Sn(
  )SM($json.value_type\201\202)ES()EH(

  ) 1 44 PR($value_type\201<json>[, <distinguish_numbers>]\202)RP(

  )0 P(Return the type of a JSON value: )SM(null)ES(, )SM(boolean)ES(,
  )SM(number)ES(, )SM(string)ES(, )SM(array)ES(, or
  )SM(object)ES(. If the )SM()I(distin)HY(guish)YH(_numbers)ES()ES( argu)HY(ment)YH(
  is )SM(true)ES(, then instead of )SM(number)ES( return
  )SM(signed number)ES(, )SM(unsigned number)ES(, or
  )SM(hexadec)HY(i)HY(mal)YH( number)ES(.)EP(

  )0 3 120 H(5.9.2)WB 331 Sn()WB 122 Sn(
  )SM($json.value_size\201\202)ES()EH(

  ) 1 19 PR($value_size\201<json>\202)RP(

  )0 P(Return the size of a JSON value.)EP(

  )0 P(The size of a )SM(null)ES( value is )SM(0)ES(. The sizes of
  simple values \201)SM(boolean)ES(, )SM(number)ES(, and
  )SM(string)ES(\202 is )SM(1)ES(. The size of )SM(array)ES( and
  )SM(object)ES( values is the number of elements and members,
  respec)HY(tively)YH(.)EP(

  )0 P(Note that the size of a )SM(string)ES( JSON value is not the length
  of the string. To get the length call )SM($string.size\201\202)ES( instead by
  casting the JSON value to the )SM(string)ES( value type.)EP(

  )0 3 121 H(5.9.3)WB 332 Sn()WB 123 Sn(
  )SM($json.member_name\201\202)ES()EH(

  ) 1 27 PR($member_name\201<json-member>\202)RP(

  )0 P(Return the name of a JSON object member.)EP(

  )0 3 122 H(5.9.4)WB 333 Sn()WB 124 Sn(
  )SM($json.member_value\201\202)ES()EH(

  ) 1 28 PR($member_value\201<json-member>\202)RP(

  )0 P(Return the value of a JSON object member.)EP(

  )0 3 123 H(5.9.5)WB 334 Sn()WB 125 Sn(
  )SM($json.object_names\201\202)ES()EH(

  ) 1 28 PR($object_names\201<json-object>\202)RP(

  )0 P(Return the list of names in the JSON object. If the JSON
  )SM(null)ES( is passed instead, assume it is a missing object and
  return an empty list.)EP(

  )0 3 124 H(5.9.6)WB 335 Sn()WB 126 Sn(
  )SM($json.array_size\201\202)ES()EH(

  ) 1 25 PR($array_size\201<json-array>\202)RP(

  )0 P(Return the number of elements in the JSON array. If the JSON
  )SM(null)ES( value is passed instead, assume it is a missing array and
  return )SM(0)ES(.)EP(

  )0 3 125 H(5.9.7)WB 336 Sn()WB 127 Sn(
  )SM($json.array_find\201\202)ES()EH(

  ) 1 33 PR($array_find\201<json-array>, <json>\202)RP(

  )0 P(Return true if the JSON array contains the spec)HY(i)HY(fied)YH( JSON value. If the
  JSON )SM(null)ES( value is passed instead, assume it is a missing array
  and return )SM(false)ES(.)EP(

  )0 3 126 H(5.9.8)WB 337 Sn()WB 128 Sn(
  )SM($json.array_find_index\201\202)ES()EH(

  ) 1 39 PR($array_find_index\201<json-array>, <json>\202)RP(

  )0 P(Return the index of the first element in the JSON array that is equal to
  the spec)HY(i)HY(fied)YH( JSON value or
  )SM($array_size\201)SM()I(json-array)ES()ES(\202)ES( if none is found.
  If the JSON )SM(null)ES( value is passed instead, assume it is a
  missing array and return )SM(0)ES(.)EP(

  )0 3 127 H(5.9.9)WB 338 Sn()WB 129 Sn( )SM($json.load\201\202)ES()EH(

  ) 1 18 PR($json.load\201<path>\202)RP(

  )0 P(Parse the contents of the spec)HY(i)HY(fied)YH( file as JSON input text and return
  the result as a value of the )SM(json)ES( type.)EP(

  )0 P(See also )SM($json.parse\201\202)ES(.)EP(

  )0 P(Note that this func)HY(tion)YH( is not pure.)EP(

  )0 3 128 H(5.9.10)WB 339 Sn()WB 130 Sn( )SM($json.parse\201\202)ES()EH(

  ) 1 19 PR($json.parse\201<text>\202)RP(

  )0 P(Parse the spec)HY(i)HY(fied)YH( JSON input text and return the result as a value of
  the )SM(json)ES( type.)EP(

  )0 P(See also )SM($json.load\201\202)ES( and
  )SM($json.seri)HY(al)HY(ize)YH(\201\202)ES(.)EP(

  )0 3 129 H(5.9.11)WB 340 Sn()WB 131 Sn( )SM($json.seri)HY(al)HY(ize)YH(\201\202)ES()EH(

  ) 1 35 PR($serialize\201<json>[, <indentation>]\202)RP(

  )0 P(Seri)HY(al)HY(ize)YH( the spec)HY(i)HY(fied)YH( JSON value and return the result)HY(ing)YH( JSON output
  text.)EP(

  )0 P(The optional )SM()I(inden)HY(ta)HY(tion)YH()ES()ES( argu)HY(ment)YH( spec)HY(i)HY(fies)YH( the
  number of inden)HY(ta)HY(tion)YH( spaces that should be used for pretty-print)HY(ing)YH(. If
  )SM(0)ES( is passed, then no pretty-print)HY(ing)YH( is performed. The default
  is )SM(2)ES( spaces.)EP(

  )0 P(See also )SM($json.parse\201\202)ES(.)EP(

  )0 3 130 H(5.9.12)WB 341 Sn()WB 132 Sn( )SM($json.size\201\202)ES()EH(

  ) 2 17 PR($size\201<json-set>\202
$size\201<json-map>\202)RP(

  )0 P(Return the number of elements in the sequence.)EP(

  )0 3 131 H(5.9.13)WB 342 Sn()WB 133 Sn( )SM($json.keys\201\202)ES()EH(

  ) 1 17 PR($keys\201<json-map>\202)RP(

  )0 P(Return the list of keys in a json map as a json array.)EP(

  )0 P(Note that the result is sorted in ascend)HY(ing)YH( order.)EP(

  )0 2 132 H(5.10)WB 343 Sn()WB 134 Sn( Process Func)HY(tions)YH()EH(

  )0 3 133 H(5.10.1)WB 344 Sn()WB 135 Sn( )SM($process.run\201\202)ES()EH(

  ) 1 32 PR($process.run\201<prog>[ <args>...]\202)RP(

  )0 P(Run builtin or exter)HY(nal)YH( program and return trimmed )SM(stdout)ES(
  output.)EP(

  )0 P(Note that if the result of execut)HY(ing)YH( the program can be affected by
  envi)HY(ron)HY(ment)YH( vari)HY(ables)YH( and this result can in turn affect the build result,
  then such vari)HY(ables)YH( should be reported with the
  )SM(config.envi)HY(ron)HY(ment)YH()ES( direc)HY(tive)YH(.)EP(

  )0 P(Note that this func)HY(tion)YH( is not pure and can only be called during the
  load phase.)EP(

  )0 3 134 H(5.10.2)WB 345 Sn()WB 136 Sn(
  )SM($process.run_regex\201\202)ES()EH(

  ) 1 54 PR($process.run_regex\201<prog>[ <args>...], <pat>[, <fmt>]\202)RP(

  )0 P(Run builtin or exter)HY(nal)YH( program and return )SM(stdout)ES( output
  lines matched and option)HY(ally)YH( processed with a regular expres)HY(sion)YH(.)EP(

  )0 P(Each line of stdout \201includ)HY(ing)YH( the custom)HY(ary)YH( trail)HY(ing)YH( blank\202 is matched
  \201as a whole\202 against )SM()I(pat)ES()ES( and, if success)HY(ful)YH(, returned,
  option)HY(ally)YH( processed with )SM()I(fmt)ES()ES(, as an element of a list.
  See the )SM($regex.*\201\202)ES( func)HY(tion)YH( family for details on regular
  expres)HY(sions)YH( and format strings.)EP(

  )0 P(Note that if the result of execut)HY(ing)YH( the program can be affected by
  envi)HY(ron)HY(ment)YH( vari)HY(ables)YH( and this result can in turn affect the build result,
  then such vari)HY(ables)YH( should be reported with the
  )SM(config.envi)HY(ron)HY(ment)YH()ES( direc)HY(tive)YH(.)EP(

  )0 P(Note that this func)HY(tion)YH( is not pure and can only be called during the
  load phase.)EP(

  )0 2 135 H(5.11)WB 346 Sn()WB 137 Sn( Filesys)HY(tem)YH( Func)HY(tions)YH()EH(

  )0 3 136 H(5.11.1)WB 347 Sn()WB 138 Sn(
  )SM($filesys)HY(tem)YH(.file_exists\201\202)ES()EH(

  ) 1 20 PR($file_exists\201<path>\202)RP(

  )0 P(Return true if a filesys)HY(tem)YH( entry at the spec)HY(i)HY(fied)YH( path exists and is a
  regular file \201or is a symlink to a regular file\202 and false other)HY(wise)YH(.)EP(

  )0 P(Note that this func)HY(tion)YH( is not pure.)EP(

  )0 3 137 H(5.11.2)WB 348 Sn()WB 139 Sn(
  )SM($filesys)HY(tem)YH(.direc)HY(tory)YH(_exists\201\202)ES()EH(

  ) 1 25 PR($directory_exists\201<path>\202)RP(

  )0 P(Return true if a filesys)HY(tem)YH( entry at the spec)HY(i)HY(fied)YH( path exists and is a
  direc)HY(tory)YH( \201or is a symlink to a direc)HY(tory)YH(\202 and false other)HY(wise)YH(.)EP(

  )0 P(Note that this func)HY(tion)YH( is not pure.)EP(

  )0 3 138 H(5.11.3)WB 349 Sn()WB 140 Sn(
  )SM($filesys)HY(tem)YH(.path_search\201\202)ES()EH(

  ) 1 38 PR($path_search\201<pattern>[, <start-dir>]\202)RP(

  )0 P(Return filesys)HY(tem)YH( paths that match the shell-like wild)HY(card)YH( pattern. If
  the pattern is an abso)HY(lute)YH( path, then the start direc)HY(tory)YH( is ignored \201if
  present\202. Other)HY(wise)YH(, the start direc)HY(tory)YH( must be spec)HY(i)HY(fied)YH( and be
  abso)HY(lute)YH(.)EP(

  )0 P(Note that this func)HY(tion)YH( is not pure.)EP(

  )0 2 139 H(5.12)WB 350 Sn()WB 141 Sn( Project Name Func)HY(tions)YH()EH(

  )0 P(The )SM($project_name.*\201\202)ES( func)HY(tion)YH( family contains func)HY(tion)YH( that
  operate on the )SM(project_name)ES( type.)EP(

  )0 3 140 H(5.12.1)WB 351 Sn()WB 142 Sn(
  )SM($project_name.string\201\202)ES()EH(

  ) 1 23 PR($string\201<project-name>\202)RP(

  )0 P(Return the string repre)HY(sen)HY(ta)HY(tion)YH( of a project name. See also the
  )SM($vari)HY(able)YH(\201\202)ES( func)HY(tion)YH( below.)EP(

  )0 3 141 H(5.12.2)WB 352 Sn()WB 143 Sn(
  )SM($project_name.base\201\202)ES()EH(

  ) 1 36 PR($base\201<project-name>[, <extension>]\202)RP(

  )0 P(Return the base part \201without the exten)HY(sion)YH(\202 of a project name.)EP(

  )0 P(If )SM()I(exten)HY(sion)YH()ES()ES( is spec)HY(i)HY(fied)YH(, then only remove that
  exten)HY(sion)YH(. Note that )SM()I(exten)HY(sion)YH()ES()ES( should not include the
  dot and the compar)HY(i)HY(son)YH( is always case-insen)HY(si)HY(tive)YH(.)EP(

  )0 3 142 H(5.12.3)WB 353 Sn()WB 144 Sn(
  )SM($project_name.exten)HY(sion)YH(\201\202)ES()EH(

  ) 1 26 PR($extension\201<project-name>\202)RP(

  )0 P(Return the exten)HY(sion)YH( part \201without the dot\202 of a project name or empty
  string if there is no exten)HY(sion)YH(.)EP(

  )0 3 143 H(5.12.4)WB 354 Sn()WB 145 Sn(
  )SM($project_name.vari)HY(able)YH(\201\202)ES()EH(

  ) 1 25 PR($variable\201<project-name>\202)RP(

  )0 P(Return the string repre)HY(sen)HY(ta)HY(tion)YH( of a project name that is sani)HY(tized)YH( to
  be usable as a vari)HY(able)YH( name. Specif)HY(i)HY(cally)YH(, )SM(.)ES(, )SM(-)ES(,
  and )SM(+)ES( are replaced with )SM(_)ES(.)EP(

  )0 2 144 H(5.13)WB 355 Sn()WB 146 Sn( Process Path Func)HY(tions)YH()EH(

  )0 P(The )SM($process_path.*\201\202)ES( func)HY(tion)YH( family contains func)HY(tion)YH( that
  operate on the )SM(process_path)ES( type and its extended
  )SM(process_path_ex)ES( variant. These types describe a path to an
  executable that, if neces)HY(sary)YH(, has been found in )SM(PATH)ES(,
  completed with an exten)HY(sion)YH(, etc. The )SM(process_path_ex)ES( variant
  includes addi)HY(tional)YH( meta)HY(data)YH(, such as the stable process name for
  diag)HY(nos)HY(tics)YH( and the executable check)HY(sum)YH( for change track)HY(ing)YH(.)EP(

  )0 3 145 H(5.13.1)WB 356 Sn()WB 147 Sn(
  )SM($process_path.recall\201\202)ES()EH(

  ) 1 23 PR($recall\201<process-path>\202)RP(

  )0 P(Return the recall path of an executable, that is, a path that is not
  neces)HY(sar)HY(ily)YH( abso)HY(lute)YH( but which never)HY(the)HY(less)YH( can be used to re-run the
  executable in the current envi)HY(ron)HY(ment)YH(. This path, for example, could be used
  in diag)HY(nos)HY(tics)YH( when print)HY(ing)YH( the failing command line.)EP(

  )0 3 146 H(5.13.2)WB 357 Sn()WB 148 Sn(
  )SM($process_path.effect\201\202)ES()EH(

  ) 1 23 PR($effect\201<process-path>\202)RP(

  )0 P(Return the effec)HY(tive)YH( path of an executable, that is, the abso)HY(lute)YH( path to
  the executable that will also include any omitted exten)HY(sions)YH(, etc.)EP(

  )0 3 147 H(5.13.3)WB 358 Sn()WB 149 Sn(
  )SM($process_path.name\201\202)ES()EH(

  ) 1 24 PR($name\201<process-path-ex>\202)RP(

  )0 P(Return the stable process name for diag)HY(nos)HY(tics)YH(.)EP(

  )0 3 148 H(5.13.4)WB 359 Sn()WB 150 Sn(
  )SM($process_path.check)HY(sum)YH(\201\202)ES()EH(

  ) 1 28 PR($checksum\201<process-path-ex>\202)RP(

  )0 P(Return the executable check)HY(sum)YH( for change track)HY(ing)YH(.)EP(

  )0 3 149 H(5.13.5)WB 360 Sn()WB 151 Sn(
  )SM($process_path.env_check)HY(sum)YH(\201\202)ES()EH(

  ) 1 32 PR($env_checksum\201<process-path-ex>\202)RP(

  )0 P(Return the envi)HY(ron)HY(ment)YH( check)HY(sum)YH( for change track)HY(ing)YH(.)EP(

  )0 2 150 H(5.14)WB 361 Sn()WB 152 Sn( Target Triplet Func)HY(tions)YH()EH(

  )0 P(The )SM($target_triplet.*\201\202)ES( func)HY(tion)YH( family contains func)HY(tion)YH(
  that operate on the )SM(target_triplet)ES( type that repre)HY(sents)YH( the
  ubiq)HY(ui)HY(tous)YH( )SM()I(cpu)ES(-)I(vendor)ES(-)I(os)ES()ES( target plat)HY(form)YH(
  triplet.)EP(

  )0 3 151 H(5.14.1)WB 362 Sn()WB 153 Sn(
  )SM($target_triplet.string\201\202)ES()EH(

  ) 1 25 PR($string\201<target-triplet>\202)RP(

  )0 P(Return the canon)HY(i)HY(cal)YH( \201that is, without the )SM(unknown)ES( vendor
  compo)HY(nent)YH(\202 target triplet string.)EP(

  )0 3 152 H(5.14.2)WB 363 Sn()WB 154 Sn(
  )SM($target_triplet.repre)HY(sen)HY(ta)HY(tion)YH(\201\202)ES()EH(

  ) 1 33 PR($representation\201<target-triplet>\202)RP(

  )0 P(Return the complete target triplet string that always contains the vendor
  compo)HY(nent)YH(.)EP(

  )0 1 153 H(6)WB 364 Sn()WB 155 Sn( Direc)HY(tives)YH()EH(

  )0 P(This chapter is a work in progress and is
  incom)HY(plete)YH(.)EP(

  )0 2 154 H(6.1)WB 365 Sn()WB 156 Sn( )SM(define)ES()EH(

  ) 1 24 PR(define <derived>: <base>)RP(

  )0 P(Define a new target type )SM(<derived>)ES( by inher)HY(it)HY(ing)YH( from
  exist)HY(ing)YH( target type )SM(<base>)ES(. See )0 27 1 A(Target Types)27 0 TN TL()Ec /AF f D( for details.)EP(

  )0 2 155 H(6.2)WB 366 Sn()WB 157 Sn( )SM(include)ES()EH(

  ) 2 19 PR(include <file>
include <directory>)RP(

  )0 P(Load the spec)HY(i)HY(fied)YH( file \201the first form\202 or )SM(build)HY(file)YH()ES( in the
  spec)HY(i)HY(fied)YH( direc)HY(tory)YH( \201the second form\202. In both cases the file is loaded in
  the scope corre)HY(spond)HY(ing)YH( to its direc)HY(tory)YH(. Subse)HY(quent)YH( inclu)HY(sions)YH( of the same
  file are auto)HY(mat)HY(i)HY(cally)YH( ignored. See also )0 158 1 A()SM(source)ES()158 0 TN TL()Ec /AF f D(.)EP(

  )0 2 156 H(6.3)WB 367 Sn()WB 158 Sn( )SM(source)ES()EH(

  ) 1 13 PR(source <file>)RP(

  )0 P(Load the spec)HY(i)HY(fied)YH( file in the current scope as if its contents were
  copied and pasted in place of the )SM(source)ES( direc)HY(tive)YH(. Note that
  subse)HY(quent)YH( sourc)HY(ing)YH( of the same file in the same scope are not auto)HY(mat)HY(i)HY(cally)YH(
  ignored.  See also )0 157 1 A()SM(include)ES()157 0 TN TL()Ec /AF f D(.)EP(

  )0 1 157 H(7)WB 368 Sn()WB 159 Sn( Attributes)EH(

  )0 P(This chapter is a work in progress and is
  incom)HY(plete)YH(.)EP(

  )0 P(The only currently recog)HY(nized)YH( target attribute is )SM(rule_hint)ES(
  which spec)HY(i)HY(fies)YH( the rule hint. Rule hints can be used to resolve ambi)HY(gu)HY(ity)YH(
  when multi)HY(ple)YH( rules match the same target as well as to over)HY(ride)YH( an
  unam)HY(bigu)HY(ous)YH( match. For example, the follow)HY(ing)YH( rule hint makes sure our
  executable is linked with the C++ compiler even though it only has C
  sources:)EP(

  ) 1 36 PR([rule_hint=cxx] exe{hello}: c{hello})RP(

  )0 1 158 H(8)WB 369 Sn()WB 160 Sn( Name Patterns)EH(

  )0 P(For conve)HY(nience)YH(, in certain contexts, names can be gener)HY(ated)YH( with
  shell-like wild)HY(card)YH( patterns. A name is a )I(name pattern)ES( if its value
  contains one or more unquoted wild)HY(card)YH( char)HY(ac)HY(ters)YH( or char)HY(ac)HY(ter)YH( sequences.
  For example:)EP(

  ) 3 59 PR(./: */                     # All \201immediate\202 subdirectories
exe{hello}: {hxx cxx}{**}  # All C++ header/source files.
pattern = '*.txt'          # Literal '*.txt'.)RP(

  )0 P(Pattern-based name gener)HY(a)HY(tion)YH( is not performed in certain contexts.
  Specif)HY(i)HY(cally)YH(, it is not performed in target names where it is inter)HY(preted)YH( as
  a pattern for target type/pattern-specific vari)HY(able)YH( assign)HY(ments)YH(. For
  example.)EP(

  ) 3 56 PR(s = *.txt             # Variable assignment \201performed\202.
./: cxx{*}            # Prerequisite names \201performed\202.
cxx{*}: dist = false  # Target pattern \201not performed\202.)RP(

  )0 P(In contexts where it is performed, it can be inhib)HY(ited)YH( with quoting, for
  example:)EP(

  ) 2 18 PR(pat = 'foo*bar'
./: cxx{'foo*bar'})RP(

  )0 P(The follow)HY(ing)YH( wild)HY(cards)YH( are recog)HY(nized)YH(:)EP(

  ) 3 55 PR(*     - match any number of characters \201including zero\202
?     - match any single character
[...] - match a character with a bracket expression)RP(

  )BR(
  )0 P(Currently only literal char)HY(ac)HY(ter)YH( and range bracket expres)HY(sions)YH( are
  supported. Specif)HY(i)HY(cally)YH(, no char)HY(ac)HY(ter)YH( or equiv)HY(a)HY(lence)YH( classes, etc., are
  supported nor the special char)HY(ac)HY(ters)YH( back)HY(slash)YH(-escap)HY(ing)YH(. See the "Pattern
  Match)HY(ing)YH( Nota)HY(tion)YH(" section in the POSIX "Shell Command Language"
  spec)HY(i)HY(fi)HY(ca)HY(tion)YH( for details.)EP(
  )BR(

  )0 P(Note that some wild)HY(card)YH( char)HY(ac)HY(ters)YH( may have special meaning in certain
  contexts. For instance, )SM([)ES( at the begin)HY(ning)YH( of a value will be
  inter)HY(preted)YH( as the start of the attribute list while )SM(?)ES( and
  )SM([)ES( in the eval context are part of the ternary oper)HY(a)HY(tor)YH( and
  value subscript, respec)HY(tively)YH(. In such cases the char)HY(ac)HY(ter)YH( will need to be
  escaped in order to be treated as a wild)HY(card)YH(, for example:)EP(

  ) 3 20 PR(x = \200[1-9]-foo.txt
y = \201foo.\200?xx\202
z = \201$foo\200[123].txt\202)RP(

  )0 P(If a pattern ends with a direc)HY(tory)YH( sepa)HY(ra)HY(tor)YH(, then it only matches
  direc)HY(to)HY(ries)YH(. Other)HY(wise)YH(, it only matches files. Matches that start with a dot
  \201)SM(.)ES(\202 are auto)HY(mat)HY(i)HY(cally)YH( ignored unless the pattern itself also
  starts with this char)HY(ac)HY(ter)YH(.)EP(

  )0 P(In addi)HY(tion)YH( to the above wild)HY(cards)YH(, )SM(**)ES( and )SM(***)ES(
  are recog)HY(nized)YH( as wild)HY(card)YH( sequences. If a pattern contains )SM(**)ES(,
  then it is matched just like )SM(*)ES( but in all the subdi)HY(rec)HY(to)HY(ries)YH(,
  recur)HY(sively)YH(, but exclud)HY(ing)YH( direc)HY(to)HY(ries)YH( that contain the
  )SM(.buildig)HY(nore)YH()ES( file. The )SM(***)ES( wild)HY(card)YH( behaves like
  )SM(**)ES( but also matches the start direc)HY(tory)YH( itself. For
  example:)EP(

  ) 1 56 PR(exe{hello}: cxx{**}  # All C++ source files recursively.)RP(

  )0 P(A group-enclosed \201)SM({})ES(\202 pattern value may be followed by
  inclu)HY(sion)YH(/exclu)HY(sion)YH( patterns/matches. A subse)HY(quent)YH( value is treated as an
  inclu)HY(sion)YH( or exclu)HY(sion)YH( if it starts with a literal, unquoted plus
  \201)SM(+)ES(\202 or minus \201)SM(-)ES(\202 sign, respec)HY(tively)YH(. In this case
  the remain)HY(ing)YH( group values, if any, must all be inclu)HY(sions)YH( or exclu)HY(sions)YH(. If
  the second value doesn't start with a plus or minus, then all the group
  values are consid)HY(ered)YH( inde)HY(pen)HY(dent)YH( with leading pluses and minuses not having
  any special meaning. For regu)HY(lar)HY(ity)YH( as well as to allow patterns without
  wild)HY(cards)YH(, the first pattern can also start with the plus sign. For
  example:)EP(

  ) 7 68 PR(exe{hello}: cxx{f* -foo}            # Exclude foo if exists.
exe{hello}: cxx{f* +bar}            # Include bar if exists.
exe{hello}: cxx{f* -fo?}            # Exclude foo and fox if exist.
exe{hello}: cxx{f* +b* -foo -bar}   # Exclude foo and bar if exist.
exe{hello}: cxx{+f* +b* -foo -bar}  # Same as above.
exe{hello}: cxx{+foo}               # Pattern without wildcards.
exe{hello}: cxx{f* b* -z*}          # Names matching three patterns.)RP(

  )0 P(Inclu)HY(sions)YH( and exclu)HY(sions)YH( are applied in the order spec)HY(i)HY(fied)YH( and only to
  the result produced up to that point. The order of names in the result is
  unspec)HY(i)HY(fied)YH(. However, it is guar)HY(an)HY(teed)YH( not to contain dupli)HY(cates)YH(. The first
  pattern and the follow)HY(ing)YH( inclu)HY(sions)YH(/exclu)HY(sions)YH( must be consis)HY(tent)YH( with
  regards to the type of filesys)HY(tem)YH( entry they match. That is, they should all
  match either files or direc)HY(to)HY(ries)YH(. For example:)EP(

  ) 3 66 PR(exe{hello}: cxx{f* -foo +*oo}  # Exclusion has no effect.
exe{hello}: cxx{f* +*oo}       # Ok, no duplicates.
./: {*/ -build}                # Error: exclusion not a directory.)RP(

  )0 P(As a more real)HY(is)HY(tic)YH( example, let's say we want to exclude source files
  that reside in the )SM(test/)ES( direc)HY(to)HY(ries)YH( \201and their subdi)HY(rec)HY(to)HY(ries)YH(\202
  anywhere in the tree. This can be achieved with the follow)HY(ing)YH( pattern:)EP(

  ) 1 32 PR(exe{hello}: cxx{** -***/test/**})RP(

  )0 P(Simi)HY(larly)YH(, if we wanted to exclude all source files that have the
  )SM(-test)ES( suffix:)EP(

  ) 1 28 PR(exe{hello}: cxx{** -**-test})RP(

  )0 P(In contrast, the follow)HY(ing)YH( pattern only excludes such files from the top
  direc)HY(tory)YH(:)EP(

  ) 1 27 PR(exe{hello}: cxx{** -*-test})RP(

  )0 P(If many inclu)HY(sions)YH( or exclu)HY(sions)YH( need to be spec)HY(i)HY(fied)YH(, then an
  inclu)HY(sion)YH(/exclu)HY(sion)YH( group can be used. For example:)EP(

  ) 2 36 PR(exe{hello}: cxx{f* -{foo bar}}
exe{hello}: cxx{+{f* b*} -{foo bar}})RP(

  )0 P(This is partic)HY(u)HY(larly)YH( useful if you would like to list the names to
  include or exclude in a vari)HY(able)YH(. For example, this is how we can exclude
  certain files from compi)HY(la)HY(tion)YH( but still include them as ordi)HY(nary)YH( file
  prereq)HY(ui)HY(sites)YH( \201so that they are still included into the source
  distri)HY(bu)HY(tion)YH(\202:)EP(

  ) 2 44 PR(exc = foo.cxx bar.cxx
exe{hello}: cxx{+{f* b*} -{$exc}} file{$exc})RP(

  )0 P(If we want to specify our pattern in a vari)HY(able)YH(, then we have to use the
  explicit inclu)HY(sion)YH( syntax, for example:)EP(

  ) 10 39 PR(pat = 'f*'
exe{hello}: cxx{+$pat} # Pattern match.
exe{hello}: cxx{$pat}  # Literal 'f*'.

pat = '+f*'
exe{hello}: cxx{$pat}  # Literal '+f*'.

inc = 'f*'  'b*'
exc = 'f*o' 'b*r'
exe{hello}: cxx{+{$inc} -{$exc}})RP(

  )0 P(One common situ)HY(a)HY(tion)YH( that calls for exclu)HY(sions)YH( is auto-gener)HY(ated)YH( source
  code. Let's say we have auto-gener)HY(ated)YH( command line parser in
  )SM(options.hxx)ES( and )SM(options.cxx)ES(. Because of the in/out
  of source builds, our name pattern may or may not find these files. Note,
  however, that we cannot just include them as non-pattern prereq)HY(ui)HY(sites)YH(. We
  also have to exclude them from the pattern match since other)HY(wise)YH( we may end
  up with dupli)HY(cate)YH( prereq)HY(ui)HY(sites)YH(. As a result, this is how we have to handle
  this case provided we want to continue using patterns to find other,
  non-gener)HY(ated)YH( source files:)EP(

  ) 1 52 PR(exe{hello}: {hxx cxx}{* -options} {hxx cxx}{options})RP(

  )0 P(If all our auto-gener)HY(ated)YH( source files have a common prefix or suffix,
  then we can exclude them whole)HY(sale)YH( with a pattern. For example, if all our
  gener)HY(ated)YH( files end with the `-options` suffix:)EP(

  ) 1 72 PR(exe{hello}: {hxx cxx}{** -**-options} {hxx cxx}{foo-options bar-options})RP(

  )0 P(If the name pattern includes an abso)HY(lute)YH( direc)HY(tory)YH(, then the pattern
  match is performed in that direc)HY(tory)YH( and the gener)HY(ated)YH( names include
  abso)HY(lute)YH( direc)HY(to)HY(ries)YH( as well. Other)HY(wise)YH(, the pattern match is performed in
  the )I(pattern base)ES( direc)HY(tory)YH(. In build)HY(files)YH( this is
  )SM(src_base)ES( while on the command line \235 the current working
  direc)HY(tory)YH(. In this case the gener)HY(ated)YH( names are rela)HY(tive)YH( to the base
  direc)HY(tory)YH(. For example, assum)HY(ing)YH( we have the )SM(foo.cxx)ES( and
  )SM(b/bar.cxx)ES( source files:)EP(

  ) 2 72 PR(exe{hello}: $src_base/cxx{**}  # $src_base/cxx{foo} $src_base/b/cxx{bar}
exe{hello}:           cxx{**}  #           cxx{foo}           b/cxx{bar})RP(

  )0 P(Pattern match)HY(ing)YH( as well as inclu)HY(sion)YH(/exclu)HY(sion)YH( logic is target
  type-specific. If the name pattern does not contain a type, then the
  )SM(dir{})ES( type is assumed if the pattern ends with a direc)HY(tory)YH(
  sepa)HY(ra)HY(tor)YH( and )SM(file{})ES( other)HY(wise)YH(.)EP(

  )0 P(For the )SM(dir{})ES( target type the trail)HY(ing)YH( direc)HY(tory)YH( sepa)HY(ra)HY(tor)YH(
  is added to the pattern and all the inclu)HY(sion)YH(/exclu)HY(sion)YH( patterns/matches
  that do not already end with one. Then the filesys)HY(tem)YH( search is performed
  for match)HY(ing)YH( direc)HY(to)HY(ries)YH(. For example:)EP(

  ) 1 51 PR(./: dir{* -build}  # Search for */, exclude build/.)RP(

  )0 P(For the )SM(file{})ES( and )SM(file{})ES(-based target types
  the default exten)HY(sion)YH( \201if any\202 is added to the pattern and all the
  inclu)HY(sion)YH(/exclu)HY(sion)YH( patterns/matches that do not already contain an
  exten)HY(sion)YH(. Then the filesys)HY(tem)YH( search is performed for match)HY(ing)YH( files.)EP(

  )0 P(For example, the )SM(cxx{})ES( target type obtains the default
  exten)HY(sion)YH( from the )SM(exten)HY(sion)YH()ES( vari)HY(able)YH( \201see )0 27 1 A(Target Types)27 0 TN TL()Ec /AF f D( for back)HY(ground)YH(\202. Assum)HY(ing)YH( we have the
  follow)HY(ing)YH( line in our )SM(root.build)ES(:)EP(

  ) 1 23 PR(cxx{*}: extension = cxx)RP(

  )0 P(And the follow)HY(ing)YH( in our )SM(build)HY(file)YH()ES(:)EP(

  ) 1 34 PR(exe{hello}: {cxx}{* -foo -bar.cxx})RP(

  )0 P(The pattern match will first search for all the files match)HY(ing)YH( the
  )SM(*.cxx)ES( pattern in )SM(src_base)ES( and then exclude
  )SM(foo.cxx)ES( and )SM(bar.cxx)ES( from the result. Note also
  that target type-specific deco)HY(ra)HY(tions)YH( are removed from the result. So in the
  above example if the pattern match produces )SM(baz.cxx)ES(, then the
  prereq)HY(ui)HY(site)YH( name is )SM(cxx{baz})ES(, not
  )SM(cxx{baz.cxx})ES(.)EP(

  )0 P(If the name gener)HY(a)HY(tion)YH( cannot be performed because the base direc)HY(tory)YH( is
  unknown, target type is unknown, or the target type is not direc)HY(tory)YH( or
  file-based, then the name pattern is returned as is \201that is, as an ordi)HY(nary)YH(
  name\202. Project-qual)HY(i)HY(fied)YH( names are never consid)HY(ered)YH( to be patterns.)EP(

  )0 1 159 H(9)WB 370 Sn()WB 161 Sn( )SM(config)ES( Module)EH(

  )0 P(This chapter is a work in progress and is
  incom)HY(plete)YH(.)EP(

  )0 2 160 H(9.1)WB 371 Sn()WB 162 Sn( Hermetic Build Config)HY(u)HY(ra)HY(tions)YH()EH(

  )0 P(Hermetic build config)HY(u)HY(ra)HY(tions)YH( save envi)HY(ron)HY(ment)YH( vari)HY(ables)YH( that affect the
  project along with other project config)HY(u)HY(ra)HY(tion)YH( in the
  )SM(build/config.build)ES( file. These saved envi)HY(ron)HY(ment)YH( vari)HY(ables)YH( are
  then used instead of the current envi)HY(ron)HY(ment)YH( when perform)HY(ing)YH( oper)HY(a)HY(tions)YH( on
  the project, thus making sure the project "sees" exactly the same
  envi)HY(ron)HY(ment)YH( as during config)HY(u)HY(ra)HY(tion)YH(.)EP(

  )BR(
  )0 P(While currently hermetic config)HY(u)HY(ra)HY(tions)YH( only deal with the envi)HY(ron)HY(ment)YH(,
  in the future this func)HY(tion)HY(al)HY(ity)YH( may be extended to also support disal)HY(low)HY(ing)YH(
  changes to exter)HY(nal)YH( resources \201compil)HY(ers)YH(, system headers and libraries,
  etc\202.)EP(
  )BR(

  )0 P(To create a hermetic config)HY(u)HY(ra)HY(tion)YH( we use the
  )SM(config.config.hermetic)ES( config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH(. For example:)EP(

  ) 1 41 PR($ b configure config.config.hermetic=true)RP(

  )BR(
  )0 P(Hermetic config)HY(u)HY(ra)HY(tions)YH( are not the default because they are not without
  draw)HY(backs)YH(. Firstly, a hermetic config)HY(u)HY(ra)HY(tion)YH( may break if the saved
  envi)HY(ron)HY(ment)YH( becomes incom)HY(pat)HY(i)HY(ble)YH( with the rest of the system. For example,
  you may re-install an exter)HY(nal)YH( program \201say, a compiler\202 into a differ)HY(ent)YH(
  loca)HY(tion)YH( and update your )SM(PATH)ES( to match the new setup. However,
  a hermetic config)HY(u)HY(ra)HY(tion)YH( will "see" the first change but not the second.)EP(

  )0 P(Another issue is the commands printed during a hermetic build: they are
  executed in the saved envi)HY(ron)HY(ment)YH( which may not match the envi)HY(ron)HY(ment)YH( in
  which the build system was invoked. As a result, we cannot easily re-execute
  such commands, which is often handy during build trou)HY(bleshoot)HY(ing)YH(.)EP(

  )0 P(It is also impor)HY(tant)YH( to keep in mind that a non-hermetic build
  config)HY(u)HY(ra)HY(tion)YH( does not break or produce incor)HY(rect)YH( results if the envi)HY(ron)HY(ment)YH(
  changes. Instead, changes to the envi)HY(ron)HY(ment)YH( are detected and affected
  targets are auto)HY(mat)HY(i)HY(cally)YH( rebuilt.)EP(

  )0 P(The two use-cases where hermetic config)HY(u)HY(ra)HY(tions)YH( are espe)HY(cially)YH( useful are
  when we need to save an envi)HY(ron)HY(ment)YH( which is not gener)HY(ally)YH( avail)HY(able)YH( \201for
  example, an envi)HY(ron)HY(ment)YH( of a Visual Studio devel)HY(op)HY(ment)YH( command prompt\202 or
  when our build results need to exactly match the specific config)HY(u)HY(ra)HY(tion)YH( \201for
  example, because parts of the overall result have already been built and
  installed, as is the case with build system modules\202.)EP(
  )BR(

  )0 P(If we now examine )SM(config.build)ES(, we will see some)HY(thing)YH( along
  these lines:)EP(

  ) 4 61 PR($ cat build/config.build

config.config.hermetic = true
config.config.environment = CPATH CPLUS_INCLUDE_PATH PATH=...)RP(

  )BR(
  )0 P(Hermetic config)HY(u)HY(ra)HY(tion)YH( support is built on top of the low-level
  )SM(config.config.envi)HY(ron)HY(ment)YH()ES( config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH( which allows
  us to specify custom envi)HY(ron)HY(ment)YH( vari)HY(ables)YH( and their values. Specif)HY(i)HY(cally)YH(,
  it contains a list of envi)HY(ron)HY(ment)YH( vari)HY(able)YH( "sets"
  \201)SM()I(name)ES(=)I(value)ES()ES(\202 and "unsets"
  \201)SM()I(name)ES()ES(\202. For example:)EP(

  ) 2 64 PR($ b configure \200
  config.config.environment="PATH=/bin:/usr/bin LD_LIBRARY_PATH")RP(

  )0 P(Spec)HY(i)HY(fy)HY(ing)YH( )SM(config.config.hermetic=true)ES( simply instructs the
  )SM(config)ES( module to collect and save in
  )SM(config.config.envi)HY(ron)HY(ment)YH()ES( envi)HY(ron)HY(ment)YH( vari)HY(ables)YH( that affect the
  project. These include:)EP(

  )UL(  )-1 LI(built-in vari)HY(ables)YH( \201such as )SM(PATH)ES( and
  )SM(LD_LIBRARY_PATH)ES( or equiv)HY(a)HY(lent)YH(\202,

  )-1 LI(vari)HY(ables)YH( that affect exter)HY(nal)YH( programs as reported by build system
  modules \201such as )SM(CPLUS_INCLUDE_PATH)ES( reported by the
  )SM(cxx)ES( module\202 or by imported programs via meta)HY(data)YH(,

  )-1 LI(vari)HY(ables)YH( reported by the project itself with the
  )SM(config.envi)HY(ron)HY(ment)YH()ES( direc)HY(tive)YH( \201discussed below\202.
  )LU(
  )BR(

  )0 P(Recon)HY(fig)HY(ur)HY(ing)YH( a hermetic config)HY(u)HY(ra)HY(tion)YH( preserves the saved envi)HY(ron)HY(ment)YH(
  unless )I(re-herme)HY(ti)HY(za)HY(tion)YH()ES( is explic)HY(itly)YH( requested with the
  )SM(config.config.hermetic.reload)ES( config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH(. For
  example:)EP(

  ) 1 48 PR($ b configure config.config.hermetic.reload=true)RP(

  )BR(
  )0 P(Note that )SM(config.config.hermetic.reload)ES( is tran)HY(sient)YH( and is
  not stored in )SM(config.build)ES(. In other words, there is no way to
  create a hermetic config)HY(u)HY(ra)HY(tion)YH( that is re-herme)HY(tized)YH( by default during
  recon)HY(fig)HY(u)HY(ra)HY(tion)YH(.)EP(
  )BR(

  )0 P(To )I(de-herme)HY(tize)YH()ES( a hermetic build config)HY(u)HY(ra)HY(tion)YH(, recon)HY(fig)HY(ure)YH( it
  with )SM(config.config.hermetic=false)ES(.)EP(

  )BR(
  )0 P(The )SM(config.config.hermetic)ES( vari)HY(able)YH( has essen)HY(tially)YH( a
  tri-state value: )SM(true)ES( means keep herme)HY(tized)YH( \201save the
  envi)HY(ron)HY(ment)YH( in )SM(config.config.envi)HY(ron)HY(ment)YH()ES(\202, )SM(false)ES(
  means keep de-herme)HY(tized)YH( \201clear )SM(config.config.envi)HY(ron)HY(ment)YH()ES(\202 and
  )SM(null)ES( or unde)HY(fined)YH( means don't touch
  )SM(config.config.envi)HY(ron)HY(ment)YH()ES(.)EP(
  )BR(

  )0 P(We can adjust the set of envi)HY(ron)HY(ment)YH( vari)HY(ables)YH( saved in a hermetic
  config)HY(u)HY(ra)HY(tion)YH( using the )SM(config.config.hermetic.envi)HY(ron)HY(ment)YH()ES(
  config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH(. It contains a list of inclu)HY(sions)YH(
  \201)SM()I(name)ES()ES(\202 and exclu)HY(sions)YH( \201)SM()I(name)ES(@false)ES(\202
  which are applied to the final set of envi)HY(ron)HY(ment)YH( vari)HY(ables)YH( that affect the
  project. For example:)EP(

  ) 3 56 PR(LC_ALL=C b configure \200
  config.config.hermetic=true \200
  config.config.hermetic.environment="LC_ALL PATH@false")RP(

  )0 P(Typi)HY(cally)YH(, the set of envi)HY(ron)HY(ment)YH( vari)HY(ables)YH( that affect the project is
  discov)HY(ered)YH( auto)HY(mat)HY(i)HY(cally)YH(. Specif)HY(i)HY(cally)YH(, modules that we use \201such as
  )SM(cxx)ES(\202 are expected to report the envi)HY(ron)HY(ment)YH( vari)HY(ables)YH( that
  affect the programs they invoke \201such as the C++ compiler\202. Simi)HY(larly)YH(,
  programs that we import in our )SM(build)HY(files)YH()ES( \201for example to use
  in ad hoc recipes\202 are expected to report envi)HY(ron)HY(ment)YH( vari)HY(ables)YH( that affect
  them as part of their meta)HY(data)YH(.)EP(

  )0 P(However, there are situ)HY(a)HY(tions)YH( where we need to report an envi)HY(ron)HY(ment)YH(
  vari)HY(able)YH( manu)HY(ally)YH(. These include calling the )SM($getenv\201\202)ES( func)HY(tion)YH(
  from a )SM(build)HY(file)YH()ES( or invok)HY(ing)YH( a program \201either in an ad hoc
  recipe, the )SM(run)ES( direc)HY(tive)YH(, or the )SM($run*\201\202)ES( func)HY(tion)YH(
  family\202 that either does not provide the meta)HY(data)YH( or does not report the
  envi)HY(ron)HY(ment)YH( as part of it. In such cases we should report the envi)HY(ron)HY(ment)YH(
  vari)HY(able)YH( manu)HY(ally)YH( using the )SM(config.envi)HY(ron)HY(ment)YH()ES( direc)HY(tive)YH(. For
  example:)EP(

  ) 6 34 PR(config.environment USE_FOO

foo = $getenv\201USE_FOO\202

if \201$foo != [null]\202
  cxx.poptions += "-DUSE_FOO=$foo")RP(

  )0 P(Addi)HY(tion)HY(ally)YH(, if invok)HY(ing)YH( a program in an ad hoc recipe that either does
  not provide the meta)HY(data)YH( or does not report the envi)HY(ron)HY(ment)YH( as part of it,
  then we addi)HY(tion)HY(ally)YH( should track the changes to the rele)HY(vant)YH( envi)HY(ron)HY(ment)YH(
  vari)HY(ables)YH( manu)HY(ally)YH( using the )SM(depdb env)ES( builtin. For
  example:)EP(

  ) 10 68 PR(import! foo = foo%exe{foo} # Uses FOO and BAR environment variables.

config.environment FOO BAR

file{output}: file{input} $foo
{{
  diag foo $>
  depdb env FOO BAR
  $foo $path\201$<[0]\202 >$path\201$>\202
}})RP(

  )BR(
  )0 P(Normally, we would want to report vari)HY(ables)YH( that affect the build result
  rather than build byprod)HY(ucts)YH( \201for example, diag)HY(nos)HY(tics)YH(\202. This is, for
  example, the reason why locale-related envi)HY(ron)HY(ment)YH( vari)HY(ables)YH( are not saved
  by default. Also, some)HY(time)YH( envi)HY(ron)HY(ment)YH( vari)HY(ables)YH( only affect certain modes
  of a program. If such modes are not used, then there is no need to report
  the corre)HY(spond)HY(ing)YH( vari)HY(ables)YH(.)EP(
  )BR(

  )0 1 161 H(10)WB 372 Sn()WB 163 Sn( )SM(test)ES( Module)EH(

  )0 P(This chapter is a work in progress and is
  incom)HY(plete)YH(.)EP(

  )0 P(The targets to be tested as well as the tests/groups from testscripts to
  be run can be narrowed down using the )SM(config.test)ES( vari)HY(able)YH(.
  While this value is normally spec)HY(i)HY(fied)YH( as a command line over)HY(ride)YH( \201for
  example, to quickly re-run a previ)HY(ously)YH( failed test\202, it can also be
  persisted in )SM(config.build)ES( in order to create a config)HY(u)HY(ra)HY(tion)YH(
  that will only run a subset of tests by default. For example:)EP(

  ) 2 70 PR(b test config.test=foo/exe{driver} # Only test foo/exe{driver} target.
b test config.test=bar/baz         # Only run bar/baz testscript test.)RP(

  )0 P(The )SM(config.test)ES( vari)HY(able)YH( contains a list of
  )SM(@)ES(-sepa)HY(rated)YH( pairs with the left hand side being the target and
  the right hand side being the testscript id path. Either can be omitted
  \201along with )SM(@)ES(\202. If the value contains a target type or ends
  with a direc)HY(tory)YH( sepa)HY(ra)HY(tor)YH(, then it is treated as a target name. Other)HY(wise)YH(
  \235 an id path. The targets are resolved rela)HY(tive)YH( to the root scope
  where the )SM(config.test)ES( value is set. For example:)EP(

  ) 1 38 PR(b test config.test=foo/exe{driver}@bar)RP(

  )0 P(To specify multi)HY(ple)YH( id paths for the same target we can use the pair
  gener)HY(a)HY(tion)YH( syntax:)EP(

  ) 1 44 PR(b test config.test=foo/exe{driver}@{bar baz})RP(

  )0 P(If no targets are spec)HY(i)HY(fied)YH( \201only id paths\202, then all the targets are
  tested \201with the testscript tests to be run limited to the spec)HY(i)HY(fied)YH( id
  paths\202. If no id paths are spec)HY(i)HY(fied)YH( \201only targets\202, then all the testscript
  tests are run \201with the targets to be tested limited to the spec)HY(i)HY(fied)YH(
  targets\202. An id path without a target applies to all the targets being
  consid)HY(ered)YH(.)EP(

  )0 P(A direc)HY(tory)YH( target without an explicit target type \201for example,
  )SM(foo/)ES(\202 is treated specially. It enables all the tests at and
  under its direc)HY(tory)YH(. This special treat)HY(ment)YH( can be inhib)HY(ited)YH( by spec)HY(i)HY(fy)HY(ing)YH(
  the target type explic)HY(itly)YH( \201for example, )SM(dir{foo/})ES(\202.)EP(

  )0 P(The test execu)HY(tion)YH( time can be limited using the
  )SM(config.test.timeout)ES( vari)HY(able)YH(. Its value has the
  )SM(<oper)HY(a)HY(tion)YH(-timeout>/<test-timeout>)ES( form where the
  time)HY(outs)YH( are spec)HY(i)HY(fied)YH( in seconds and either of them \201but not both\202 can be
  omitted. The left hand side sets the timeout for the whole )SM(test)ES(
  oper)HY(a)HY(tion)YH( and the right hand side \235 for indi)HY(vid)HY(ual)YH( tests. The zero
  value clears the previ)HY(ously)YH( set timeout. For example:)EP(

  ) 3 70 PR(b test config.test.timeout=20   # Test operation.
b test config.test.timeout=20/5 # Test operation and individual tests.
b test config.test.timeout=/5   # Individual tests.)RP(

  )0 P(The test timeout can be spec)HY(i)HY(fied)YH( on multi)HY(ple)YH( nested root scopes. For
  example, we can specify a greater timeout for the entire build config)HY(u)HY(ra)HY(tion)YH(
  and lesser ones for indi)HY(vid)HY(ual)YH( projects. The tests must complete before the
  nearest of the enclos)HY(ing)YH( scope time)HY(outs)YH(. Failed that, the timed out tests
  are termi)HY(nated)YH( forcibly causing the entire )SM(test)ES( oper)HY(a)HY(tion)YH( to
  fail. See also the )0 2 A()SM(timeout)ES()EA(
  builtin for spec)HY(i)HY(fy)HY(ing)YH( time)HY(outs)YH( from within the tests and test groups.)EP(

  )0 P(The programs being tested can be executed via a )I(runner program)ES( by
  spec)HY(i)HY(fy)HY(ing)YH( the )SM(config.test.runner)ES( vari)HY(able)YH(. Its value has the
  )SM(<path> [<options>])ES( form. For example:)EP(

  ) 1 39 PR(b test config.test.runner="valgrind -q")RP(

  )0 P(When the runner program is spec)HY(i)HY(fied)YH(, commands of simple and Testscript
  tests are auto)HY(mat)HY(i)HY(cally)YH( adjusted so that the runner program is executed
  instead, with the test command passed to it as argu)HY(ments)YH(. For ad hoc test
  recipes, the runner program has to be handled explic)HY(itly)YH(. Specif)HY(i)HY(cally)YH(, if
  )SM(config.test.runner)ES( is spec)HY(i)HY(fied)YH(, the
  )SM(test.runner.path)ES( and )SM(test.runner.options)ES( vari)HY(ables)YH(
  contain the runner program path and options, respec)HY(tively)YH(, and are set to
  )SM(null)ES( other)HY(wise)YH(. These vari)HY(ables)YH( can be used by ad hoc recipes
  to detect the pres)HY(ence)YH( of the runner program and, if so, arrange appro)HY(pri)HY(ate)YH(
  execu)HY(tion)YH( of desired commands. For example:)EP(

  ) 11 55 PR(exe{hello}:
% test
{{
  diag test $>

  cmd = \201$test.runner.path == [null] \200
    ? $> \200
    : $test.runner.path $test.runner.options $path\201$>\202\202

  $cmd 'World' >>>?'Hello, World!'
}})RP(

  )0 1 162 H(11)WB 373 Sn()WB 164 Sn( )SM(install)ES( Module)EH(

  )0 P(This chapter is a work in progress and is
  incom)HY(plete)YH(.)EP(

  )0 P(The )SM(install)ES( module provides support for installing and
  unin)HY(stalling)YH( projects.)EP(

  )0 P(As briefly discussed in the )0 10 1 A(Installing)10 0 TN TL()Ec /AF f D( section of the Intro)HY(duc)HY(tion)YH(,
  the )SM(install)ES( module defines the follow)HY(ing)YH( stan)HY(dard)YH( instal)HY(la)HY(tion)YH(
  loca)HY(tions)YH(:)EP(

  ) 25 70 PR(name          default                                 config.install.*
                                                      \201c.i.*\202 override
----          -------                                 ----------------
root                                                  c.i.root

data_root     root/                                   c.i.data_root
exec_root     root/                                   c.i.exec_root

bin           exec_root/bin/                          c.i.bin
sbin          exec_root/sbin/                         c.i.sbin
lib           exec_root/lib/<private>/                c.i.lib
libexec       exec_root/libexec/<private>/<project>/  c.i.libexec
pkgconfig     lib/pkgconfig/                          c.i.pkgconfig

etc           data_root/etc/                          c.i.etc
include       data_root/include/<private>/            c.i.include
include_arch  include/                                c.i.include_arch
share         data_root/share/                        c.i.share
data          share/<private>/<project>/              c.i.data
buildfile     share/build2/export/<project>/          c.i.buildfile

doc           share/doc/<private>/<project>/          c.i.doc
legal         doc/                                    c.i.legal
man           share/man/                              c.i.man
man<N>        man/man<N>/                             c.i.man<N>)RP(

  )0 P(The )SM(include_arch)ES( loca)HY(tion)YH( is meant for archi)HY(tec)HY(ture)YH(-specific
  files, such as config)HY(u)HY(ra)HY(tion)YH( headers. By default it's the same as
  )SM(include)ES( but can be config)HY(ured)YH( by the user to a differ)HY(ent)YH( value
  \201for example, )SM(/usr/include/x86_64-linux-gnu/)ES(\202 for plat)HY(forms)YH(
  that support multi)HY(ple)YH( archi)HY(tec)HY(tures)YH( from the same instal)HY(la)HY(tion)YH( loca)HY(tion)YH(.
  This is how one would normally use it from a )SM(build)HY(file)YH()ES(:)EP(

  ) 5 67 PR(# The configuration header may contain target architecture-specific
# information so install it into include_arch/ instead of include/.
#
h{*}:      install = include/libhello/
h{config}: install = include_arch/libhello/)RP(

  )0 P(The )SM(build)HY(file)YH()ES( loca)HY(tion)YH( is meant for exported build)HY(files)YH( that
  can be imported by other projects. If a project contains any
  )SM(**.build)ES( build)HY(files)YH( in its )SM(build/export/)ES( direc)HY(tory)YH(
  \201or )SM(**.build2)ES( and )SM(build2/export/)ES( in the
  alter)HY(na)HY(tive)YH( naming scheme\202, then they are auto)HY(mat)HY(i)HY(cally)YH( installed into this
  loca)HY(tion)YH( \201recre)HY(at)HY(ing)YH( subdi)HY(rec)HY(to)HY(ries)YH(\202.)EP(

  )0 P(The )SM(<project>)ES(, )SM(<version>)ES(, and
  )SM(<private>)ES( substi)HY(tu)HY(tions)YH( in these
  )SM(config.install.*)ES( values are replaced with the project name,
  version, and private subdi)HY(rec)HY(tory)YH(, respec)HY(tively)YH(. If either is empty, then
  the corre)HY(spond)HY(ing)YH( direc)HY(tory)YH( compo)HY(nent)YH( is ignored.)EP(

  )0 P(The optional private instal)HY(la)HY(tion)YH( subdi)HY(rec)HY(tory)YH(
  \201)SM(<private>)ES(\202 mech)HY(a)HY(nism)YH( can be used to hide the imple)HY(men)HY(ta)HY(tion)YH(
  details of a project. This is primar)HY(ily)YH( useful when installing an executable
  that depends on a bunch of libraries into a shared loca)HY(tion)YH(, such as
  )SM(/usr/local/)ES(. By hiding the libraries in the private
  subdi)HY(rec)HY(tory)YH( we can make sure that they will not inter)HY(fere)YH( with anything
  that is already installed into such a shared loca)HY(tion)YH( by the user and that
  any further such instal)HY(la)HY(tions)YH( won't inter)HY(fere)YH( with our executable.)EP(

  )0 P(The private instal)HY(la)HY(tion)YH( subdi)HY(rec)HY(tory)YH( is spec)HY(i)HY(fied)YH( with the
  )SM(config.install.private)ES( vari)HY(able)YH(. Its value must be a rela)HY(tive)YH(
  direc)HY(tory)YH( and may include multi)HY(ple)YH( compo)HY(nents)YH(. For example:)EP(

  ) 3 37 PR($ b install                         \200
    config.install.root=/usr/local/ \200
    config.install.private=hello/)RP(

  )BR(
  )0 P(If you are relying on your system's dynamic linker defaults to
  auto)HY(mat)HY(i)HY(cally)YH( find shared libraries that are installed with your executable,
  then adding the private instal)HY(la)HY(tion)YH( subdi)HY(rec)HY(tory)YH( will most defi)HY(nitely)YH( cause
  this to stop working. The recom)HY(mended)YH( way to resolve this problem is to use
  )I(rpath)ES(, for example:)EP(

  ) 4 40 PR($ b install                       \200
  config.install.root=/usr/local/ \200
  config.install.private=hello/   \200
  config.bin.rpath=/usr/local/lib/hello/)RP(
  )BR(

  )0 2 163 H(11.1)WB 374 Sn()WB 165 Sn( Relo)HY(cat)HY(able)YH( Instal)HY(la)HY(tion)YH()EH(

  )0 P(A relo)HY(cat)HY(able)YH( instal)HY(la)HY(tion)YH( can be moved to a direc)HY(tory)YH( other than its
  orig)HY(i)HY(nal)YH( instal)HY(la)HY(tion)YH( loca)HY(tion)YH(. Note that the instal)HY(la)HY(tion)YH( should be moved
  as a whole preserv)HY(ing)YH( the direc)HY(tory)YH( struc)HY(ture)YH( under its root
  \201)SM(config.install.root)ES(\202. To request a relo)HY(cat)HY(able)YH( instal)HY(la)HY(tion)YH(,
  set the )SM(config.install.relo)HY(cat)HY(able)YH()ES( vari)HY(able)YH( to
  )SM(true)ES(. For example:)EP(

  ) 3 38 PR($ b install                          \200
    config.install.root=/tmp/install \200
    config.install.relocatable=true)RP(

  )0 P(A relo)HY(cat)HY(able)YH( instal)HY(la)HY(tion)YH( is achieved by using paths rela)HY(tive)YH( to one
  filesys)HY(tem)YH( entry within the instal)HY(la)HY(tion)YH( to locate another. Some exam)HY(ples)YH(
  include:)EP(

  )UL(  )-1 LI(Paths spec)HY(i)HY(fied)YH( in )SM(config.bin.rpath)ES( are made rela)HY(tive)YH( using
  the )SM($ORIGIN)ES( \201Linux, BSD\202 or )SM(@loader_path)ES( \201Mac OS\202
  mech)HY(a)HY(nisms)YH(.

  )-1 LI(Paths in the gener)HY(ated)YH( )SM(pkg-config)ES( files are made rela)HY(tive)YH(
  to the )SM(${pcfiledir})ES( built-in vari)HY(able)YH(.

  )-1 LI(Paths in the gener)HY(ated)YH( instal)HY(la)HY(tion)YH( mani)HY(fest)YH(
  \201)SM(config.install.mani)HY(fest)YH()ES(\202 are made rela)HY(tive)YH( to the loca)HY(tion)YH( of
  the mani)HY(fest)YH( file.
  )LU(

  )0 P(While these common aspects are handled auto)HY(mat)HY(i)HY(cally)YH(, if a projects
  relies on knowing its instal)HY(la)HY(tion)YH( loca)HY(tion)YH(, then it will most likely need
  to add manual support for relo)HY(cat)HY(able)YH( instal)HY(la)HY(tions)YH(.)EP(

  )0 P(As an example, consider an executable that supports loading plugins and
  requires the plugin instal)HY(la)HY(tion)YH( direc)HY(tory)YH( to be embed)HY(ded)YH( into the
  executable during the build. The common way to support relo)HY(cat)HY(able)YH(
  instal)HY(la)HY(tions)YH( for such cases is to embed a path rela)HY(tive)YH( to the executable
  and complete it at runtime, normally by resolv)HY(ing)YH( the executable's path and
  using its direc)HY(tory)YH( as a base.)EP(

  )0 P(If you would like to always use the rela)HY(tive)YH( path, regard)HY(less)YH( of whether
  the instal)HY(la)HY(tion)YH( is relo)HY(cat)HY(able)YH( of not, then you can obtain the library
  instal)HY(la)HY(tion)YH( direc)HY(tory)YH( rela)HY(tive)YH( to the executable instal)HY(la)HY(tion)YH( direc)HY(tory)YH(
  like this:)EP(

  ) 1 57 PR(plugin_dir = $install.resolve\201$install.lib, $install.bin\202)RP(

  )0 P(Alter)HY(na)HY(tively)YH(, if you would like to continue using abso)HY(lute)YH( paths for
  non-relo)HY(cat)HY(able)YH( instal)HY(la)HY(tions)YH(, then you can use some)HY(thing)YH( like this:)EP(

  ) 3 54 PR(plugin_dir = $install.resolve\201 \200
  $install.lib,                \200
  \201$install.relocatable ? $install.bin : [dir_path] \202\202)RP(

  )0 P(Finally, if you are unable to support relo)HY(cat)HY(able)YH( instal)HY(la)HY(tions)YH(, the
  correct way to handle this is to assert this fact in )SM(root.build)ES(
  of your project, for example:)EP(

  ) 1 71 PR(assert \201!$install.relocatable\202 'relocatable installation not supported')RP(

  )0 2 164 H(11.2)WB 375 Sn()WB 166 Sn( Instal)HY(la)HY(tion)YH( Filter)HY(ing)YH()EH(

  )0 P(While project authors deter)HY(mine)YH( what gets installed at the
  )SM(build)HY(file)YH()ES( level, the users of the project can further filter
  the instal)HY(la)HY(tion)YH( using the )SM(config.install.filter)ES( vari)HY(able)YH(.)EP(

  )0 P(The value of this vari)HY(able)YH( is a list of key-value pairs that specify the
  filesys)HY(tem)YH( entries to include or exclude from the instal)HY(la)HY(tion)YH(. For example,
  the follow)HY(ing)YH( filters will omit installing headers and static libraries
  \201notice the quoting of the wild)HY(card)YH(\202.)EP(

  ) 1 62 PR($ b install config.install.filter='include/@false "*.a"@false')RP(

  )0 P(The key in each pair is a file or direc)HY(tory)YH( path or a path wild)HY(card)YH(
  pattern. If a key is rela)HY(tive)YH( and contains a direc)HY(tory)YH( compo)HY(nent)YH( or is a
  direc)HY(tory)YH(, then it is treated rela)HY(tive)YH( to the corre)HY(spond)HY(ing)YH(
  )SM(config.install.*)ES( loca)HY(tion)YH(. Other)HY(wise)YH( \201simple path, normally a
  pattern\202, it is matched against the leaf of any path. Note that if an
  abso)HY(lute)YH( path is spec)HY(i)HY(fied)YH(, it should be without the
  )SM(config.install.chroot)ES( prefix.)EP(

  )0 P(The value in each pair is either )SM(true)ES( \201include\202 or
  )SM(false)ES( \201exclude\202. The filters are eval)HY(u)HY(ated)YH( in the order
  spec)HY(i)HY(fied)YH( and the first match that is found deter)HY(mines)YH( the outcome. If no
  match is found, the default is to include. For a direc)HY(tory)YH(, while
  )SM(false)ES( means exclude all the sub-paths inside this direc)HY(tory)YH(,
  )SM(true)ES( does not mean that all the sub-paths will be included
  whole)HY(sale)YH(. Rather, the matched compo)HY(nent)YH( of the sub-path is treated as
  included with the rest of the compo)HY(nents)YH( matched against the follow)HY(ing)YH(
  sub-filters. For example:)EP(

  ) 4 42 PR($ b install config.install.filter='
   include/x86_64-linux-gnu/@true
   include/x86_64-linux-gnu/details/@false
   include/@false')RP(

  )0 P(The )SM(true)ES( or )SM(false)ES( value may be followed by
  comma and the )SM(symlink)ES( modi)HY(fier)YH( to only apply to symlink
  filesys)HY(tem)YH( entries. For example:)EP(

  ) 1 48 PR($ b config.install.filter='"*.so"@false,symlink')RP(

  )0 P(A filter can be negated by spec)HY(i)HY(fy)HY(ing)YH( )SM(!)ES( as the first pair.
  For example:)EP(

  ) 1 64 PR($ b install config.install.filter='! include/@false "*.a"@false')RP(

  )0 P(Note that the filter)HY(ing)YH( mech)HY(a)HY(nism)YH( only affects what gets phys)HY(i)HY(cally)YH(
  copied to the instal)HY(la)HY(tion)YH( direc)HY(tory)YH( without affect)HY(ing)YH( what gets built for
  install or the view of what gets installed at the )SM(build)HY(file)YH()ES(
  level. For example, given the )SM(include/@false *.a@false)ES( filters,
  static libraries will still be built \201unless arranged not to with
  )SM(config.bin.lib)ES(\202 and the )SM(pkg-config)ES( files will
  still end up with )SM(-I)ES( options point)HY(ing)YH( to the header
  instal)HY(la)HY(tion)YH( direc)HY(tory)YH(. Note also that this mech)HY(a)HY(nism)YH( applies to both
  )SM(install)ES( and )SM(unin)HY(stall)YH()ES( oper)HY(a)HY(tions)YH(.)EP(

  )BR(
  )0 P(If you are famil)HY(iar)YH( with the Debian or Fedora pack)HY(ag)HY(ing)YH(, this mech)HY(a)HY(nism)YH(
  is some)HY(what)YH( similar to \201and can be used for a similar purpose as\202 the
  Debian's )SM(.install)ES( files and Fedora's )SM(%files)ES( spec
  file sections, which are used to split the instal)HY(la)HY(tion)YH( into multi)HY(ple)YH( binary
  pack)HY(ages)YH(.)EP(
  )BR(

  )0 P(As another example, the follow)HY(ing)YH( filters will omit all the
  devel)HY(op)HY(ment)YH(-related files \201headers, )SM(pkg-config)ES( files, static
  libraries, and shared library symlinks; assum)HY(ing)YH( the plat)HY(form)YH( uses the
  )SM(.a)ES(/)SM(.so)ES( exten)HY(sions)YH( for the libraries\202:)EP(

  ) 5 35 PR($ b install config.install.filter='
   include/@false
   pkgconfig/@false
   "lib/*.a"@false
   "lib/*.so"@false,symlink')RP(

  )0 1 165 H(12)WB 376 Sn()WB 167 Sn( )SM(version)ES( Module)EH(

  )0 P(A project can use any version format as long as it meets the package
  version require)HY(ments)YH(. The toolchain also provides addi)HY(tional)YH( func)HY(tion)HY(al)HY(ity)YH(
  for manag)HY(ing)YH( projects that conform to the )SM(build2)ES( )I(stan)HY(dard)YH(
  version)ES( format. If you are start)HY(ing)YH( a new project that uses
  )SM(build2)ES(, you are strongly encour)HY(aged)YH( to use this version)HY(ing)YH(
  scheme. It is based on much thought and, often painful, expe)HY(ri)HY(ence)YH(. If you
  decide not to follow this advice, you are essen)HY(tially)YH( on your own where
  version manage)HY(ment)YH( is concerned.)EP(

  )0 P(The stan)HY(dard)YH( )SM(build2)ES( project version conforms to )R3 2 A(Seman)HY(tic)YH( Version)HY(ing)YH()EA( and has the follow)HY(ing)YH(
  form:)EP(

  ) 1 34 PR(<major>.<minor>.<patch>[-<prerel>])RP(

  )0 P(For example:)EP(

  ) 3 9 PR(1.2.3
1.2.3-a.1
1.2.3-b.2)RP(

  )0 P(The )SM(build2)ES( package version that uses the stan)HY(dard)YH( project
  version will then have the follow)HY(ing)YH( form \201)I(epoch)ES( is the version)HY(ing)YH(
  scheme version and )I(revi)HY(sion)YH()ES( is the package revi)HY(sion)YH(\202:)EP(

  ) 1 58 PR([+<epoch>-]<major>.<minor>.<patch>[-<prerel>][+<revision>])RP(

  )0 P(For example:)EP(

  ) 3 14 PR(1.2.3
1.2.3+1
+2-1.2.3-a.1+2)RP(

  )0 P(The )I(major)ES(, )I(minor)ES(, and )I(patch)ES( should be numeric values
  between )SM(0)ES( and )SM(99999)ES( and all three cannot be zero
  at the same time. For initial devel)HY(op)HY(ment)YH( it is recom)HY(mended)YH( to use
  )SM(0)ES( for )I(major)ES(, start with version )SM(0.1.0)ES(, and
  change to )SM(1.0.0)ES( once things stabi)HY(lize)YH(.)EP(

  )0 P(In the context of C and C++ \201or other compiled languages\202, you should
  incre)HY(ment)YH( )I(patch)ES( when making binary-compat)HY(i)HY(ble)YH( changes, )I(minor)ES(
  when making source-compat)HY(i)HY(ble)YH( changes, and )I(major)ES( when making break)HY(ing)YH(
  changes. While the binary compat)HY(i)HY(bil)HY(ity)YH( must be set in stone, the source
  compat)HY(i)HY(bil)HY(ity)YH( rules can some)HY(times)YH( be bent. For example, you may decide to
  make a break)HY(ing)YH( change in a rarely used inter)HY(face)YH( as part of a minor release
  \201though this is prob)HY(a)HY(bly)YH( still a bad idea if your library is widely depended
  upon\202. Note also that in the context of C++ decid)HY(ing)YH( whether a change is
  binary-compat)HY(i)HY(ble)YH( is a non-trivial task. There are resources that list the
  rules but no auto)HY(mated)YH( tooling yet. If unsure, incre)HY(ment)YH( )I(minor)ES(.)EP(

  )0 P(If present, the )I(prerel)ES( compo)HY(nent)YH( signi)HY(fies)YH( a pre-release. Two
  types of pre-releases are supported by the stan)HY(dard)YH( version)HY(ing)YH( scheme:
  )I(final)ES( and )I(snap)HY(shot)YH()ES( \201non-pre-release versions are natu)HY(rally)YH(
  always final\202. For final pre-releases the )I(prerel)ES( compo)HY(nent)YH( has the
  follow)HY(ing)YH( form:)EP(

  ) 1 11 PR(\201a|b\202.<num>)RP(

  )0 P(For example:)EP(

  ) 2 9 PR(1.2.3-a.1
1.2.3-b.2)RP(

  )0 P(The letter ')SM(a)ES(' signi)HY(fies)YH( an alpha release and
  ')SM(b)ES(' \235 beta. The alpha/beta numbers \201)I(num)ES(\202 should be
  between 1 and 499.)EP(

  )0 P(Note that there is no support for release candi)HY(dates)YH(. Instead, it is
  recom)HY(mended)YH( that you use later-stage beta releases for this purpose \201and, if
  you wish, call them "release candi)HY(dates)YH(" in announce)HY(ments)YH(, etc\202.)EP(

  )0 P(What version should be used during devel)HY(op)HY(ment)YH(? The common approach is to
  incre)HY(ment)YH( to the next version and use that until the release. This has one
  major draw)HY(back)YH(: if we publish inter)HY(me)HY(di)HY(ate)YH( snap)HY(shots)YH( \201for example, for
  testing\202 they will all be indis)HY(tin)HY(guish)HY(able)YH( both between each other and,
  even worse, from the final release. One way to remedy this is to incre)HY(ment)YH(
  the pre-release number before each publi)HY(ca)HY(tion)YH(. However, unless auto)HY(mated)YH(,
  this will be burden)HY(some)YH( and error-prone. Also, there is a real possi)HY(bil)HY(ity)YH(
  of running out of version numbers if, for example, we do contin)HY(u)HY(ous)YH(
  inte)HY(gra)HY(tion)YH( by publish)HY(ing)YH( and testing each commit.)EP(

  )0 P(To address this, the stan)HY(dard)YH( version)HY(ing)YH( scheme supports )I(snap)HY(shot)YH(
  pre-releases)ES( with the )I(prerel)ES( compo)HY(nent)YH( having the follow)HY(ing)YH(
  extended form:)EP(

  ) 1 31 PR(\201a|b\202.<num>.<snapsn>[.<snapid>])RP(

  )0 P(For example:)EP(

  ) 1 37 PR(1.2.3-a.1.20180319215815.26efe301f4a7)RP(

  )0 P(In essence, a snap)HY(shot)YH( pre-release is after the previ)HY(ous)YH( final release
  but before the next \201)SM(a.1)ES( and, perhaps, )SM(a.2)ES( in the
  above example\202 and is uniquely iden)HY(ti)HY(fied)YH( by the snap)HY(shot)YH( sequence number
  \201)I(snapsn)ES(\202 and optional snap)HY(shot)YH( id \201)I(snapid)ES(\202.)EP(

  )0 P(The )I(num)ES( compo)HY(nent)YH( has the same seman)HY(tics)YH( as in the final
  pre-releases except that it can be )SM(0)ES(. The )I(snapsn)ES(
  compo)HY(nent)YH( should be either the special value ')SM(z)ES(' or a numeric,
  non-zero value that increases for each subse)HY(quent)YH( snap)HY(shot)YH(. It must not be
  longer than 16 decimal digits. The )I(snapid)ES( compo)HY(nent)YH(, if present,
  should be an alpha-numeric value that uniquely iden)HY(ti)HY(fies)YH( the snap)HY(shot)YH(. It
  is not required for version compar)HY(i)HY(son)YH( \201)I(snapsn)ES( should be suffi)HY(cient)YH(\202
  and is included for refer)HY(ence)YH(. It must not be longer than 16 char)HY(ac)HY(ters)YH(.)EP(

  )0 P(Where do the snap)HY(shot)YH( number and id come from? Normally from the version
  control system. For example, for )SM(git)ES(, )I(snapsn)ES( is the
  commit date in the )I(YYYYM)HY(MD)HY(Dhh)HY(mmss)YH()ES( form and UTC time)HY(zone)YH( and
  )I(snapid)ES( is a 12-char)HY(ac)HY(ter)YH( abbre)HY(vi)HY(ated)YH( commit id. As discussed below,
  the )SM(build2)ES( )SM(version)ES( module extracts and manages all
  this infor)HY(ma)HY(tion)YH( auto)HY(mat)HY(i)HY(cally)YH( \201but the use of )SM(git)ES( commit dates
  is not without limi)HY(ta)HY(tions)YH(; see below for details\202.)EP(

  )0 P(The special ')SM(z)ES(' )I(snapsn)ES( value iden)HY(ti)HY(fies)YH( the
  )I(latest)ES( or )I(uncom)HY(mit)HY(ted)YH()ES( snap)HY(shot)YH(. It is chosen to be greater
  than any other possi)HY(ble)YH( )I(snapsn)ES( value and its use is discussed further
  below.)EP(

  )0 P(As an illus)HY(tra)HY(tion)YH( of this approach, let's examine how versions change
  during the life)HY(time)YH( of a project:)EP(

  ) 13 52 PR(0.1.0-a.0.z     # development after a.0
0.1.0-a.1       # pre-release
0.1.0-a.1.z     # development after a.1
0.1.0-a.2       # pre-release
0.1.0-a.2.z     # development after a.2
0.1.0-b.1       # pre-release
0.1.0-b.1.z     # development after b.1
0.1.0           # release
0.1.1-b.0.z     # development after b.0 \201bugfix\202
0.2.0-a.0.z     # development after a.0
0.1.1           # release \201bugfix\202
1.0.0           # release \201jumped straight to 1.0.0\202
...)RP(

  )0 P(As shown in the above example, there is nothing wrong with "jumping" to a
  further version \201for example, from alpha to beta, or from beta to release,
  or even from alpha to release\202. We cannot, however, jump back)HY(wards)YH( \201for
  example, from beta back to alpha\202. As a result, a sensi)HY(ble)YH( strat)HY(egy)YH( is to
  start with )SM(a.0)ES( since it can always be upgraded \201but not
  down)HY(graded)YH(\202 at a later stage.)EP(

  )0 P(When it comes to the version control systems, the recom)HY(mended)YH( work)HY(flow)YH( is
  as follows: The change to the final version should be the last commit in the
  \201pre-\202release. It is also a good idea to tag this commit with the project
  version. A commit imme)HY(di)HY(ately)YH( after that should change the version to a
  snap)HY(shot)YH(, "opening" the repos)HY(i)HY(tory)YH( for devel)HY(op)HY(ment)YH(.)EP(

  )0 P(The project version without the snap)HY(shot)YH( part can be repre)HY(sented)YH( as a
  64-bit decimal value compa)HY(ra)HY(ble)YH( as inte)HY(gers)YH( \201for example, in prepro)HY(ces)HY(sor)YH(
  direc)HY(tives)YH(\202. The integer repre)HY(sen)HY(ta)HY(tion)YH( has the follow)HY(ing)YH( form:)EP(

  ) 7 32 PR(AAAAABBBBBCCCCCDDDE

AAAAA - major
BBBBB - minor
CCCCC - patch
DDD   - alpha / beta \201DDD + 500\202
E     - final \2010\202 / snapshot \2011\202)RP(

  )0 P(If the )I(DDDE)ES( value is not zero, then it signi)HY(fies)YH( a pre-release. In
  this case one is subtracted from the )I(AAAAABBBB)HY(BC)HY(C)HY(CCC)YH()ES( value. An alpha
  number is stored in )I(DDD)ES( as is while beta \235 incre)HY(mented)YH( by
  )SM(500)ES(. If )I(E)ES( is )SM(1)ES(, then this is a snap)HY(shot)YH(
  after )I(DDD)ES(.)EP(

  )0 P(For example:)EP(

  ) 7 32 PR(             AAAAABBBBBCCCCCDDDE
0.1.0        0000000001000000000
0.1.2        0000000001000020000
1.2.3        0000100002000030000
2.2.0-a.1    0000200001999990010
3.0.0-b.2    0000299999999995020
2.2.0-a.1.z  0000200001999990011)RP(

  )0 P(A project that uses stan)HY(dard)YH( version)HY(ing)YH( can rely on the
  )SM(build2)ES( )SM(version)ES( module to simplify and auto)HY(mate)YH(
  version manage)HY(ments)YH(. The )SM(version)ES( module has two primary
  func)HY(tions)YH(: elim)HY(i)HY(nate)YH( the need to change the version anywhere except in the
  project's mani)HY(fest)YH( file and auto)HY(mat)HY(i)HY(cally)YH( extract and prop)HY(a)HY(gate)YH( the snap)HY(shot)YH(
  infor)HY(ma)HY(tion)YH( \201sequence number and id\202.)EP(

  )0 P(The )SM(version)ES( module must be loaded in the project's
  )SM(boot)HY(strap)YH(.build)ES(. While being loaded, it reads the project's
  mani)HY(fest)YH( and extracts its version \201which must be in the stan)HY(dard)YH( form\202. The
  version is then parsed and presented as the follow)HY(ing)YH( build system vari)HY(ables)YH(
  \201which can be used in the build)HY(files)YH(\202:)EP(

  ) 27 70 PR([string] version                     # +2-1.2.3-b.4.1234567.deadbeef+3

[string] version.project             # 1.2.3-b.4.1234567.deadbeef
[uint64] version.project_number      # 0000100002000025041
[string] version.project_id          # 1.2.3-b.4.deadbeef

[bool]   version.stub                # false \201true for 0[+<revision>]\202

[uint64] version.epoch               # 2

[uint64] version.major               # 1
[uint64] version.minor               # 2
[uint64] version.patch               # 3

[bool]   version.alpha               # false
[bool]   version.beta                # true
[bool]   version.pre_release         # true
[string] version.pre_release_string  # b.4
[uint64] version.pre_release_number  # 4

[bool]   version.snapshot            # true
[uint64] version.snapshot_sn         # 1234567
[string] version.snapshot_id         # deadbeef
[string] version.snapshot_string     # 1234567.deadbeef
[bool]   version.snapshot_committed  # true

[uint64] version.revision            # 3)RP(

  )0 P(As a conve)HY(nience)YH(, the )SM(version)ES( module also extracts the
  )SM(summary)ES( and )SM(url)ES( mani)HY(fest)YH( values and sets them as
  the follow)HY(ing)YH( build system vari)HY(ables)YH( \201this addi)HY(tional)YH( infor)HY(ma)HY(tion)YH( is used,
  for example, when gener)HY(at)HY(ing)YH( the )SM(pkg-config)ES( files\202:)EP(

  ) 2 24 PR([string] project.summary
[string] project.url)RP(

  )0 P(If the version is the latest snap)HY(shot)YH( \201that is, it's in the
  )SM(.z)ES( form\202, then the )SM(version)ES( module extracts the
  snap)HY(shot)YH( infor)HY(ma)HY(tion)YH( from the version control system used by the project.
  Currently only )SM(git)ES( is supported with the follow)HY(ing)YH(
  seman)HY(tics)YH(.)EP(

  )0 P(If the project's source direc)HY(tory)YH( \201)SM(src_root)ES(\202 is clean \201that
  is, it does not have any changed or untracked files\202, then the
  )SM(HEAD)ES( commit date and id are used as the snap)HY(shot)YH( number and id,
  respec)HY(tively)YH(.)EP(

  )0 P(Other)HY(wise)YH( \201that is, the project is between commits\202, the
  )SM(HEAD)ES( commit date is incre)HY(mented)YH( by one second and is used as
  the snap)HY(shot)YH( number with no id. While we can work with such uncom)HY(mit)HY(ted)YH(
  snap)HY(shots)YH( locally, we should not distribute or publish them since they are
  indis)HY(tin)HY(guish)HY(able)YH( from each other.)EP(

  )0 P(Finally, if the project does not have )SM(HEAD)ES( \201that is, the
  project has no commits yet\202, the special )SM(19700101000000)ES( \201UNIX
  epoch\202 commit date is used.)EP(

  )0 P(The use of )SM(git)ES( commit dates for snap)HY(shot)YH( order)HY(ing)YH( has its
  limi)HY(ta)HY(tions)YH(: they have one second reso)HY(lu)HY(tion)YH( which means it is possi)HY(ble)YH( to
  create two commits with the same date \201but not the same commit id and thus
  snap)HY(shot)YH( id\202. We also need all the commit)HY(ters)YH( to have a reason)HY(ably)YH( accu)HY(rate)YH(
  clock. Note, however, that in case of a commit date clash/order)HY(ing)YH( issue, we
  still end up with distinct versions \201because of the commit id\202 \235 they
  are just not ordered correctly. As a result, we feel that the risks are
  justi)HY(fied)YH( when the only alter)HY(na)HY(tive)YH( is manual version manage)HY(ment)YH( \201which is
  always an option, never)HY(the)HY(less)YH(\202.)EP(

  )0 P(When we prepare a source distri)HY(bu)HY(tion)YH( of a snap)HY(shot)YH(, the
  )SM(version)ES( module auto)HY(mat)HY(i)HY(cally)YH( adjusts the package name to
  include the snap)HY(shot)YH( infor)HY(ma)HY(tion)YH( as well as patches the mani)HY(fest)YH( file in the
  distri)HY(bu)HY(tion)YH( with the snap)HY(shot)YH( number and id \201that is, replac)HY(ing)YH(
  )SM(.z)ES( in the version value with the actual snap)HY(shot)YH( infor)HY(ma)HY(tion)YH(\202.
  The result is a package that is specific to this commit.)EP(

  )0 P(Besides extract)HY(ing)YH( the version infor)HY(ma)HY(tion)YH( and making it avail)HY(able)YH( as
  indi)HY(vid)HY(ual)YH( compo)HY(nents)YH(, the )SM(version)ES( module also provides rules
  for installing the mani)HY(fest)YH( file as well as auto)HY(mat)HY(i)HY(cally)YH( gener)HY(at)HY(ing)YH( version
  headers \201or other similar version-based files\202.)EP(

  )0 P(By default the project's )SM(mani)HY(fest)YH()ES( file is installed as
  docu)HY(men)HY(ta)HY(tion)YH(, just like other )SM(doc{})ES( targets \201thus replac)HY(ing)YH(
  the )SM(version)ES( file custom)HY(ar)HY(ily)YH( shipped in the project root
  direc)HY(tory)YH(\202. The mani)HY(fest)YH( instal)HY(la)HY(tion)YH( rule in the )SM(version)ES(
  module in addi)HY(tion)YH( patches the installed mani)HY(fest)YH( file with the actual
  snap)HY(shot)YH( number and id, just like during the prepa)HY(ra)HY(tion)YH( of
  distri)HY(bu)HY(tions)YH(.)EP(

  )0 P(The version header rule is based on the )0 208 1 A()SM(in)ES()208 0 TN TL()Ec /AF f D( module rule and can be used to
  prepro)HY(cess)YH( a template file with version infor)HY(ma)HY(tion)YH(. While it is usually
  used to gener)HY(ate)YH( C/C++ version headers \201thus the name\202, it can really
  gener)HY(ate)YH( any kind of files.)EP(

  )0 P(The rule matches a )SM(file)ES(-based target that has the
  corre)HY(spond)HY(ing)YH( )SM(in)ES( prereq)HY(ui)HY(site)YH( and also depends on the project's
  )SM(mani)HY(fest)YH()ES( file. As an example, let's assume we want to
  auto-gener)HY(ate)YH( a header called )SM(version.hxx)ES( for our
  )SM(libhello)ES( library. To accom)HY(plish)YH( this we add the
  )SM(version.hxx.in)ES( template as well as some)HY(thing)YH( along these lines
  to our )SM(build)HY(file)YH()ES(:)EP(

  ) 3 50 PR(lib{hello}: {hxx cxx}{** -version} hxx{version}

hxx{version}: in{version} $src_root/file{manifest})RP(

  )0 P(The header rule is a line-based prepro)HY(ces)HY(sor)YH( that substi)HY(tutes)YH( frag)HY(ments)YH(
  enclosed between \201and includ)HY(ing)YH(\202 a pair of dollar signs \201)SM($)ES(\202
  with )SM($$)ES( being the escape sequence \201see the )0 208 1 A()SM(in)ES()208 0 TN TL()Ec /AF f D( module for details\202. As an example,
  let's assume our )SM(version.hxx.in)ES( contains the follow)HY(ing)YH(
  lines:)EP(

  ) 6 65 PR(#ifndef LIBHELLO_VERSION

#define LIBHELLO_VERSION     $libhello.version.project_number$ULL
#define LIBHELLO_VERSION_STR "$libhello.version.project$"

#endif)RP(

  )0 P(If our )SM(libhello)ES( is at version )SM(1.2.3)ES(, then the
  gener)HY(ated)YH( )SM(version.hxx)ES( will look like this:)EP(

  ) 6 47 PR(#ifndef LIBHELLO_VERSION

#define LIBHELLO_VERSION     100002000030000ULL
#define LIBHELLO_VERSION_STR "1.2.3"

#endif)RP(

  )0 P(The first compo)HY(nent)YH( after the opening )SM($)ES( should be either the
  name of the project itself \201like )SM(libhello)ES( above\202 or a name of
  one of its depen)HY(den)HY(cies)YH( as listed in the mani)HY(fest)YH(. If it is the project
  itself, then the rest can refer to one of the )SM(version.*)ES(
  vari)HY(ables)YH( that we discussed earlier \201in reality it can be any vari)HY(able)YH(
  visible from the project's root scope\202.)EP(

  )0 P(If the name refers to one of the depen)HY(den)HY(cies)YH( \201that is, projects listed
  with )SM(depends:)ES( in the mani)HY(fest)YH(\202, then the follow)HY(ing)YH( special
  substi)HY(tu)HY(tions)YH( are recog)HY(nized)YH(:)EP(

  ) 3 75 PR($<name>.version$                           - textual version constraint
$<name>.condition\201<VERSION>[,<SNAPSHOT>]\202$ - numeric satisfaction condition
$<name>.check\201<VERSION>[,<SNAPSHOT>]\202$     - numeric satisfaction check)RP(

  )0 P(Here )I(VERSION)ES( is the version number macro and the optional
  )I(SNAP)HY(SHOT)YH()ES( is the snap)HY(shot)YH( number macro. The snap)HY(shot)YH( is only required
  if you plan to include snap)HY(shot)YH( infor)HY(ma)HY(tion)YH( in your depen)HY(dency)YH(
  constraints.)EP(

  )0 P(As an example, let's assume our )SM(libhello)ES( depends on
  )SM(libprint)ES( which is reflected with the follow)HY(ing)YH( line in our
  mani)HY(fest)YH(:)EP(

  ) 1 26 PR(depends: libprint >= 2.3.4)RP(

  )0 P(We also assume that )SM(libprint)ES( provides its version
  infor)HY(ma)HY(tion)YH( in the )SM(libprint/version.hxx)ES( header and uses
  anal)HY(o)HY(gous)YH(-named macros. Here is how we can add a version check to our
  )SM(version.hxx.in)ES(:)EP(

  ) 10 65 PR(#ifndef LIBHELLO_VERSION

#define LIBHELLO_VERSION     $libhello.version.project_number$ULL
#define LIBHELLO_VERSION_STR "$libhello.version.project$"

#include <libprint/version.hxx>

$libprint.check\201LIBPRINT_VERSION\202$

#endif)RP(

  )0 P(After the substi)HY(tu)HY(tion)YH( our )SM(version.hxx)ES( header will look like
  this:)EP(

  ) 14 71 PR(#ifndef LIBHELLO_VERSION

#define LIBHELLO_VERSION     100002000030000ULL
#define LIBHELLO_VERSION_STR "1.2.3"

#include <libprint/version.hxx>

#ifdef LIBPRINT_VERSION
#  if !\201LIBPRINT_VERSION >= 200003000040000ULL\202
#    error incompatible libprint version, libprint >= 2.3.4 is required
#  endif
#endif

#endif)RP(

  )0 P(The )SM(version)ES( and )SM(condi)HY(tion)YH()ES( substi)HY(tu)HY(tions)YH( are the
  build)HY(ing)YH( blocks of the )SM(check)ES( substi)HY(tu)HY(tion)YH(. For example, here is
  how we can imple)HY(ment)YH( a check with a customized error message:)EP(

  ) 3 55 PR(#if !\201$libprint.condition\201LIBPRINT_VERSION\202$\202
#  error bad libprint, need libprint $libprint.version$
#endif)RP(

  )0 P(The )SM(version)ES( module also treats one depen)HY(dency)YH( in a special
  way: if you specify the required version of the build system in your
  mani)HY(fest)YH(, then the module will auto)HY(mat)HY(i)HY(cally)YH( check it for you. For example,
  if we have the follow)HY(ing)YH( line in our mani)HY(fest)YH(:)EP(

  ) 1 26 PR(depends: * build2 >= 0.5.0)RP(

  )0 P(And someone tries to build our project with )SM(build2)ES(
  )SM(0.4.0)ES(, then they will see an error like this:)EP(

  ) 3 61 PR(build/bootstrap.build:3:1: error: incompatible build2 version
  info: running 0.4.0
  info: required 0.5.0)RP(

  )0 P(What version constraints should be used when depend)HY(ing)YH( on another
  project? We start with a simple case where we depend on a release. Let's say
  )SM(libprint)ES( )SM(2.3.0)ES( added a feature that we need in our
  )SM(libhello)ES(. If )SM(libprint)ES( follows the source/binary
  compat)HY(i)HY(bil)HY(ity)YH( guide)HY(lines)YH( discussed above, then any )SM(2.X.Y)ES(
  version should work provided )SM(X >= 3)ES(. And this how we can
  specify it in the mani)HY(fest)YH(:)EP(

  ) 1 24 PR(depends: libprint ^2.3.0)RP(

  )0 P(Let's say we are now working on )SM(libhello)ES( )SM(2.0.0)ES(
  and would like to start using features from )SM(libprint)ES(
  )SM(3.0.0)ES(. However, currently, only pre-releases of
  )SM(3.0.0)ES( are avail)HY(able)YH(. If you would like to add a depen)HY(dency)YH( on a
  pre-release \201most likely from your own pre-release\202, then the recom)HY(men)HY(da)HY(tion)YH(
  is to only allow a specific version, essen)HY(tially)YH( "expir)HY(ing)YH(" the combi)HY(na)HY(tion)YH(
  as soon as newer versions become avail)HY(able)YH(. For example:)EP(

  ) 2 30 PR(version: 2.0.0-b.1
depends: libprint == 3.0.0-b.2)RP(

  )0 P(Finally, let's assume we are feeling adven)HY(tur)HY(ous)YH( and would like to test
  devel)HY(op)HY(ment)YH( snap)HY(shots)YH( of )SM(libprint)ES( \201most likely from our own
  snap)HY(shots)YH(\202. In this case the recom)HY(men)HY(da)HY(tion)YH( is to only allow a snap)HY(shot)YH(
  range for a specific pre-release with the under)HY(stand)HY(ing)YH( and a warning that
  no compat)HY(i)HY(bil)HY(ity)YH( between snap)HY(shot)YH( versions is guar)HY(an)HY(teed)YH(. For example:)EP(

  ) 2 41 PR(version: 2.0.0-b.1.z
depends: libprint [3.0.0-b.2.1 3.0.0-b.3\202)RP(

  )0 1 166 H(13)WB 377 Sn()WB 168 Sn( )SM(bin)ES( Module)EH(

  )0 P(This chapter is a work in progress and is
  incom)HY(plete)YH(.)EP(

  )0 2 167 H(13.1)WB 378 Sn()WB 169 Sn( Binary Target Types)EH(

  )0 P(The follow)HY(ing)YH( listing shows the hier)HY(ar)HY(chy)YH( of the target types defined by
  the )SM(bin)ES( module while the follow)HY(ing)YH( sections describe each
  target type in detail \201)SM(target{})ES( and )SM(file{})ES( are
  stan)HY(dard)YH( target types defined by the )SM(build2)ES( core; see )0 27 1 A(Target Types)27 0 TN TL()Ec /AF f D( for details\202.)EP(

  ) 9 43 PR(                 target----------------.
                   |                   |
                  ...                  |
                   |                   |
 .---------------file------------.    lib
 |      |      |     |     |     |    libul
 |    libue  obje  bmie  hbmie  def   obj
liba  libua  obja  bmia  hbmia        bmi
libs  libus  objs  bmis  hbmis        hbmi)RP(

  )0 3 168 H(13.1.1)WB 379 Sn()WB 170 Sn( )SM(lib{})ES(,
  )SM(liba{})ES(, )SM(libs{})ES()EH(

  )0 P(The )SM(liba{})ES( and )SM(libs{})ES( target types repre)HY(sent)YH(
  static \201archive\202 and shared libraries, respec)HY(tively)YH(.)EP(

  )0 P(The )SM(lib{})ES( target type is a group with the
  )SM(liba{})ES( and/or )SM(libs{})ES( members. A rule that
  encoun)HY(ters)YH( a )SM(lib{})ES( prereq)HY(ui)HY(site)YH( may pick a member appro)HY(pri)HY(ate)YH(
  for the target being built or it may build all the members accord)HY(ing)YH( to the
  )SM(bin.lib)ES( vari)HY(able)YH(. See )0 13 1 A(Library Expor)HY(ta)HY(tion)YH(
  and Version)HY(ing)YH()13 0 TN TL()Ec /AF f D( for back)HY(ground)YH(.)EP(

  )0 P(The )SM(lib*{})ES( file exten)HY(sions)YH( are normally auto)HY(mat)HY(i)HY(cally)YH(
  assigned by the match)HY(ing)YH( rules based on the target plat)HY(form)YH(.)EP(

  )0 3 169 H(13.1.2)WB 380 Sn()WB 171 Sn( )SM(libul{})ES(,
  )SM(libue{})ES(, )SM(libua{})ES(, )SM(libus{})ES()EH(

  )0 P(The )SM(libu*{})ES( target types repre)HY(sent)YH( utility libraries.
  Utility libraries are static libraries with object files appro)HY(pri)HY(ate)YH( for
  linking an executable \201)SM(libue{})ES(\202, static library
  \201)SM(libua{})ES(\202, or shared library \201)SM(libus{})ES(\202. Where
  possi)HY(ble)YH(, utility libraries are built in the "thin archive" mode.)EP(

  )0 P(The )SM(libul{})ES( target type is a group with the
  )SM(libua{})ES( and/or )SM(libus{})ES( members. A rule that
  encoun)HY(ters)YH( a )SM(libul{})ES( prereq)HY(ui)HY(site)YH( picks a member appro)HY(pri)HY(ate)YH(
  for the target being built.)EP(

  )0 P(The )SM(libu*{})ES( file exten)HY(sions)YH( are normally auto)HY(mat)HY(i)HY(cally)YH(
  assigned by the match)HY(ing)YH( rules based on the target plat)HY(form)YH(.)EP(

  )0 3 170 H(13.1.3)WB 381 Sn()WB 172 Sn( )SM(obj{})ES(,
  )SM(obje{})ES(, )SM(obja{})ES(, )SM(objs{})ES()EH(

  )0 P(The )SM(obj*{})ES( target types repre)HY(sent)YH( object files appro)HY(pri)HY(ate)YH(
  for linking an executable \201)SM(obje{})ES(\202, static library
  \201)SM(obja{})ES(\202, or shared library \201)SM(objs{})ES(\202.)EP(

  )BR(
  )0 P(In )SM(build2)ES( we use distinct object files for the three types
  of bina)HY(ries)YH( \201executable, static library, and shared library\202. The
  distinc)HY(tion)YH( between static and shared libraries is made to accom)HY(mo)HY(date)YH( build
  differ)HY(ences)YH( such as the need for posi)HY(tion)YH(-inde)HY(pen)HY(dent)YH( code
  \201)SM(-fPIC)ES(\202 in shared libraries. While in most cases the same
  object file can be used for executa)HY(bles)YH( and static libraries, they are kept
  sepa)HY(rate)YH( for consis)HY(tency)YH( and gener)HY(al)HY(ity)YH(.)EP(
  )BR(

  )0 P(The )SM(obj{})ES( target type is a group with the
  )SM(obje{})ES(, and/or )SM(obja{})ES(, and/or )SM(objs{})ES(
  members. A rule that encoun)HY(ters)YH( an )SM(obj{})ES( prereq)HY(ui)HY(site)YH( picks a
  member appro)HY(pri)HY(ate)YH( for the target being built.)EP(

  )0 P(The )SM(obj*{})ES( file exten)HY(sions)YH( are normally auto)HY(mat)HY(i)HY(cally)YH(
  assigned by the match)HY(ing)YH( rules based on the target plat)HY(form)YH(.)EP(

  )0 3 171 H(13.1.4)WB 382 Sn()WB 173 Sn( )SM(bmi{})ES(,
  )SM(bmie{})ES(, )SM(bmia{})ES(, )SM(bmis{})ES()EH(

  )0 P(The )SM(bmi*{})ES( target types repre)HY(sent)YH( binary module inter)HY(faces)YH(
  \201BMI\202 for C++20 named modules appro)HY(pri)HY(ate)YH( for linking an executable
  \201)SM(bmie{})ES(\202, static library \201)SM(bmia{})ES(\202, or shared
  library \201)SM(bmis{})ES(\202.)EP(

  )0 P(The )SM(bmi{})ES( target type is a group with the
  )SM(bmie{})ES(, and/or )SM(bmia{})ES(, and/or )SM(bmis{})ES(
  members. A rule that encoun)HY(ters)YH( an )SM(bmi{})ES( prereq)HY(ui)HY(site)YH( picks a
  member appro)HY(pri)HY(ate)YH( for the target being built.)EP(

  )0 P(The )SM(bmi*{})ES( file exten)HY(sions)YH( are normally auto)HY(mat)HY(i)HY(cally)YH(
  assigned by the match)HY(ing)YH( rules based on the target plat)HY(form)YH(.)EP(

  )0 3 172 H(13.1.5)WB 383 Sn()WB 174 Sn( )SM(hbmi{})ES(,
  )SM(hbmie{})ES(, )SM(hbmia{})ES(, )SM(hbmis{})ES()EH(

  )0 P(The )SM(hbmi*{})ES( target types repre)HY(sent)YH( binary module inter)HY(faces)YH(
  \201BMI\202 for C++20 header units appro)HY(pri)HY(ate)YH( for linking an executable
  \201)SM(hbmie{})ES(\202, static library \201)SM(hbmia{})ES(\202, or shared
  library \201)SM(hbmis{})ES(\202.)EP(

  )0 P(The )SM(hbmi{})ES( target type is a group with the
  )SM(hbmie{})ES(, and/or )SM(hbmia{})ES(, and/or
  )SM(hbmis{})ES( members. A rule that encoun)HY(ters)YH( an )SM(hbmi{})ES(
  prereq)HY(ui)HY(site)YH( picks a member appro)HY(pri)HY(ate)YH( for the target being built.)EP(

  )0 P(The )SM(hbmi*{})ES( file exten)HY(sions)YH( are normally auto)HY(mat)HY(i)HY(cally)YH(
  assigned by the match)HY(ing)YH( rules based on the target plat)HY(form)YH(.)EP(

  )0 3 173 H(13.1.6)WB 384 Sn()WB 175 Sn( )SM(def{})ES()EH(

  )0 P(The )SM(def{})ES( target type repre)HY(sents)YH( Windows module defi)HY(ni)HY(tion)YH(
  files and has the fixed default exten)HY(sion)YH( )SM(.def)ES(.)EP(

  )0 1 174 H(14)WB 385 Sn()WB 176 Sn( )SM(cc)ES( Module)EH(

  )0 P(This chapter is a work in progress and is
  incom)HY(plete)YH(.)EP(

  )0 P(This chapter describes the )SM(cc)ES( build system module which
  provides the common compi)HY(la)HY(tion)YH( and linking support for C-family
  languages.)EP(

  )0 2 175 H(14.1)WB 386 Sn()WB 177 Sn( C-Common Config)HY(u)HY(ra)HY(tion)YH( Vari)HY(ables)YH()EH(

  ) 33 27 PR(config.c
config.cxx
  cc.id

  cc.target
  cc.target.cpu
  cc.target.vendor
  cc.target.system
  cc.target.version
  cc.target.class

config.cc.poptions
  cc.poptions

config.cc.coptions
  cc.coptions

config.cc.loptions
  cc.loptions

config.cc.aoptions
  cc.aoptions

config.cc.libs
  cc.libs

config.cc.internal.scope
  cc.internal.scope

config.cc.reprocess
  cc.reprocess)WR(

config.cc.pkgconfig.sysroot)RP(

  )0 P(Note that the compiler mode options are "cross-hinted" between
  )SM(config.c)ES( and )SM(config.cxx)ES( meaning that if we specify
  one but not the other, mode options, if any, will be added to the absent.
  This may or may not be the desired behav)HY(ior)YH(, for example:)EP(

  ) 5 41 PR(# Ok: config.c="gcc -m32"
$ b config.cxx="g++ -m32"

# Not OK: config.c="clang -stdlib=libc++"
$ b config.cxx="clang++ -stdlib=libc++")RP(

  )0 2 176 H(14.2)WB 387 Sn()WB 178 Sn( C-Common Target Types)EH(

  )0 P(The follow)HY(ing)YH( listing shows the hier)HY(ar)HY(chy)YH( of the target types defined by
  the )SM(cc)ES( module while the follow)HY(ing)YH( sections describe each target
  type in detail \201)SM(file{})ES( is a stan)HY(dard)YH( target type defined by the
  )SM(build2)ES( core; see )0 27 1 A(Target Types)27 0 TN TL()Ec /AF f D( for
  details\202. Every )SM(cc)ES(-based module \201such as )SM(c)ES( and
  )SM(cxx)ES(\202 will have these common target types defined in addi)HY(tion)YH( to
  the language-specific ones.)EP(

  ) 6 11 PR(.--file--.
|        |
h       pc
         |
        pca
        pcs)RP(

  )BR(
  )0 P(While the )SM(h{})ES( target type repre)HY(sents)YH( a C header file, there
  is hardly a C-family compi)HY(la)HY(tion)YH( without a C header inclu)HY(sion)YH(. As a result,
  this target types is defined by all )SM(cc)ES(-based modules.)EP(
  )BR(

  )0 P(For the descrip)HY(tion)YH( of the )SM(h{})ES( target type refer to )0 191 1 A()SM(c{})ES(, )SM(h{})ES()191 0 TN TL()Ec /AF f D( in the C
  module docu)HY(men)HY(ta)HY(tion)YH(.)EP(

  )0 3 177 H(14.2.1)WB 388 Sn()WB 179 Sn( )SM(pc{})ES(, )SM(pca{})ES(,
  )SM(pcs{})ES()EH(

  )0 P(The )SM(pc*{})ES( target types repre)HY(sent)YH( )SM(pkg-config)ES(
  files. The )SM(pc{})ES( target type repre)HY(sents)YH( the common file and has
  the fixed default exten)HY(sion)YH( )SM(.pc)ES(. The )SM(pca{})ES( and
  )SM(pcs{})ES( target types repre)HY(sent)YH( the static and shared files and
  have the fixed default exten)HY(sions)YH( )SM(.static.pc)ES( and
  )SM(.shared.pc)ES(, respec)HY(tively)YH(. See )0 182 1 A(Impor)HY(ta)HY(tion)YH( of Installed Libraries)182 0 TN TL()Ec /AF f D( for
  back)HY(ground)YH(.)EP(

  )0 2 178 H(14.3)WB 389 Sn()WB 180 Sn( Compi)HY(la)HY(tion)YH( Inter)HY(nal)YH( Scope)EH(

  )BR(
  )0 P(While this section uses the )SM(cxx)ES( module and C++ compi)HY(la)HY(tion)YH(
  as an example, the same func)HY(tion)HY(al)HY(ity)YH( is avail)HY(able)YH( for C compi)HY(la)HY(tion)YH( \235
  simply replace )SM(cxx)ES( with )SM(c)ES( in the module and
  vari)HY(able)YH( names.)EP(
  )BR(

  )0 P(The )SM(cxx)ES( module has a notion of a project's inter)HY(nal)YH( scope.
  During compi)HY(la)HY(tion)YH( of a project's C/C++ trans)HY(la)HY(tion)YH( units a header search
  path \201)SM(-I)ES(\202 exported by a library that is outside of the inter)HY(nal)YH(
  scope is consid)HY(ered)YH( exter)HY(nal)YH( and, if supported by the compiler, the
  corre)HY(spond)HY(ing)YH( )SM(-I)ES( option is trans)HY(lated)YH( to an appro)HY(pri)HY(ate)YH(
  "exter)HY(nal)YH( header search path" option \201)SM(-isystem)ES( for GCC/Clang,
  )SM(/exter)HY(nal)YH(:I)ES( for MSVC 16.10 and later\202. In partic)HY(u)HY(lar)YH(, this
  suppresses compiler warn)HY(ings)YH( in such exter)HY(nal)YH( headers
  \201)SM(/exter)HY(nal)YH(:W0)ES( is auto)HY(mat)HY(i)HY(cally)YH( added unless a custom
  )SM(/exter)HY(nal)YH(:Wn)ES( is spec)HY(i)HY(fied)YH(\202.)EP(

  )BR(
  )0 P(While the aim of this func)HY(tion)HY(al)HY(ity)YH( is to control warn)HY(ings)YH( in exter)HY(nal)YH(
  libraries, the under)HY(ly)HY(ing)YH( mech)HY(a)HY(nisms)YH( currently provided by compil)HY(ers)YH( have
  limi)HY(ta)HY(tions)YH( and unde)HY(sir)HY(able)YH( side effects. In partic)HY(u)HY(lar)YH(,
  )SM(-isystem)ES( paths are searched after )SM(-I)ES( so
  trans)HY(lat)HY(ing)YH( )SM(-I)ES( to )SM(-isystem)ES( alters the search
  order. This should normally be harm)HY(less)YH( when using a devel)HY(op)HY(ment)YH( build of a
  library but may result in a change of seman)HY(tics)YH( for installed libraries.
  Also, marking the search path as system has addi)HY(tional)YH( \201to warning
  suppres)HY(sion)YH(\202 effects, see )R4 2 A(System
  Headers)EA( in the GCC docu)HY(men)HY(ta)HY(tion)YH( for details. On the MSVC side,
  )SM(/exter)HY(nal)YH(:W0)ES( currently does not suppress some warn)HY(ings)YH( \201refer
  to the MSVC docu)HY(men)HY(ta)HY(tion)YH( for details\202.)EP(

  )0 P(Another issue is warn)HY(ings)YH( in template instan)HY(ti)HY(a)HY(tions)YH(. Each such warning
  could be either due to a \201poten)HY(tial)YH(\202 issue in the template itself or due to
  the template argu)HY(ments)YH( we are instan)HY(ti)HY(at)HY(ing)YH( it with. By default, all such
  warn)HY(ings)YH( are suppressed and there is currently no way to change this with
  GCC/Clang )SM(-isystem)ES(. While MSVC provides
  )SM(/exter)HY(nal)YH(:templates-)ES(, it cannot be applied on the library by
  library basis, only glob)HY(ally)YH( for the entire compi)HY(la)HY(tion)YH(. See MSVC
  )SM(/exter)HY(nal)YH(:templates-)ES( docu)HY(men)HY(ta)HY(tion)YH( for more back)HY(ground)YH( on this
  issue.)EP(
  )BR(

  )BR(
  )0 P(In the future this func)HY(tion)HY(al)HY(ity)YH( will be extended to side-build)HY(ing)YH( BMIs
  for exter)HY(nal)YH( module inter)HY(faces)YH( and header units.)EP(
  )BR(

  )0 P(The inter)HY(nal)YH( scope can be spec)HY(i)HY(fied)YH( by the project with the
  )SM(cxx.inter)HY(nal)YH(.scope)ES( vari)HY(able)YH( and over)HY(rid)HY(den)YH( by the user with the
  )SM(config.cxx.inter)HY(nal)YH(.scope)ES( vari)HY(able)YH(. Note that
  )SM(cxx.inter)HY(nal)YH(.scope)ES( must be spec)HY(i)HY(fied)YH( before loading the
  )SM(cxx)ES( module \201)SM(cxx.config)ES(, more precisely\202 and after
  which it contains the effec)HY(tive)YH( value \201see below\202. For example:)EP(

  ) 6 28 PR(# root.build

cxx.std = latest
cxx.internal.scope = current

using cxx)RP(

  )0 P(Valid values for )SM(cxx.inter)HY(nal)YH(.scope)ES( are:)EP(

  ) 7 59 PR(current  -- current root scope \201where variable is assigned\202
base     -- target's base scope
root     -- target's root scope
bundle   -- target's bundle amalgamation
strong   -- target's strong amalgamation
weak     -- target's weak amalgamation
global   -- global scope \201everything is internal\202)RP(

  )0 P(Valid values for )SM(config.cxx.inter)HY(nal)YH(.scope)ES( are the same
  except for )SM(current)ES(.)EP(

  )0 P(Note also that there are )SM([config.]cc.inter)HY(nal)YH(.scope)ES(
  vari)HY(ables)YH( that can be used to specify the inter)HY(nal)YH( scope for all the
  )SM(cc)ES(-based modules.)EP(

  )0 P(The project's effec)HY(tive)YH( inter)HY(nal)YH( scope is chosen based on the follow)HY(ing)YH(
  prior)HY(ity)YH( list:)EP(

  )4 OL(  )-1 LI()SM(config.cxx.inter)HY(nal)YH(.scope)ES(

  )-1 LI()SM(config.cc.inter)HY(nal)YH(.scope)ES(

  )-1 LI(effec)HY(tive)YH( scope from bundle amal)HY(ga)HY(ma)HY(tion)YH(

  )-1 LI()SM(cxx.inter)HY(nal)YH(.scope)ES(

  )-1 LI()SM(cc.inter)HY(nal)YH(.scope)ES(
  )LO(

  )0 P(In partic)HY(u)HY(lar)YH(, item #3 allows an amal)HY(ga)HY(ma)HY(tion)YH( that bundles a project to
  over)HY(ride)YH( its inter)HY(nal)YH( scope.)EP(

  )BR(
  )0 P(If no )SM(*.inter)HY(nal)YH(.scope)ES( is spec)HY(i)HY(fied)YH( by the project, user, or
  bundle, then this func)HY(tion)HY(al)HY(ity)YH( is disabled and all libraries are treated as
  inter)HY(nal)YH( regard)HY(less)YH( of their loca)HY(tion)YH(.)EP(

  )0 P(While it may seem natural to have this enabled by default, the
  limi)HY(ta)HY(tions)YH( and side effects of the under)HY(ly)HY(ing)YH( mech)HY(a)HY(nisms)YH( as well as cases
  where it would be unde)HY(sir)HY(able)YH( \201such as in sepa)HY(rate)YH( )SM(*-tests)ES(
  projects, see below\202 all suggest that explicit opt-in is prob)HY(a)HY(bly)YH( the
  correct choice.)EP(
  )BR(

  )0 P(The recom)HY(mended)YH( value for a typical project is )SM(current)ES(,
  meaning that only headers inside the project will be consid)HY(ered)YH( inter)HY(nal)YH(.
  The )SM(tests)ES( subpro)HY(ject)YH(, if present, will inherit its value from
  the project \201which acts as a bundle amal)HY(ga)HY(ma)HY(tion)YH(\202, unless it is being built
  out of source \201for example, to test an installed library\202.)EP(

  )0 P(A project can also whitelist specific libraries using the
  )SM(cxx.inter)HY(nal)YH(.libs)ES( vari)HY(able)YH(. If a library target name \201that is,
  the name inside )SM(lib{})ES(\202 matches any of the wild)HY(card)YH( patterns
  listed in this vari)HY(able)YH(, then the library is consid)HY(ered)YH( inter)HY(nal)YH( regard)HY(less)YH(
  of its loca)HY(tion)YH(. For example \201notice that the pattern is quoted\202:)EP(

  ) 7 31 PR(# root.build

cxx.std = latest
cxx.internal.scope = current
cxx.internal.libs = foo 'bar-*'

using cxx)RP(

  )0 P(Note that this vari)HY(able)YH( should also be set before loading the
  )SM(cxx)ES( module and there is the common
  )SM(cc.inter)HY(nal)YH(.libs)ES( equiv)HY(a)HY(lent)YH(. However, there are no
  )SM(config.*)ES( versions nor the over)HY(ride)YH( by the bundle amal)HY(ga)HY(ma)HY(tion)YH(
  seman)HY(tics)YH(.)EP(

  )0 P(Typi)HY(cally)YH( you would want to whitelist libraries that are devel)HY(oped)YH(
  together but reside in sepa)HY(rate)YH( build system projects. In partic)HY(u)HY(lar)YH(, a
  sepa)HY(rate)YH( )SM(*-tests)ES( project for a library should whitelist the
  library being tested if the inter)HY(nal)YH( scope func)HY(tion)HY(al)HY(ity)YH( is in use. Another
  reason to whitelist is to catch warn)HY(ings)YH( in instan)HY(ti)HY(a)HY(tions)YH( of templates that
  belong to a library that is other)HY(wise)YH( warning-free \201see the MSVC
  )SM(/exter)HY(nal)YH(:templates-)ES( option for back)HY(ground)YH(\202.)EP(

  )0 P(Note also that if multi)HY(ple)YH( libraries are installed into the same loca)HY(tion)YH(
  \201or other)HY(wise)YH( share the same header search paths, for example, as a family
  of libraries\202, then the whitelist may not be effec)HY(tive)YH(.)EP(

  )0 2 179 H(14.4)WB 390 Sn()WB 181 Sn( Auto)HY(matic)YH( DLL Symbol Export)HY(ing)YH()EH(

  )0 P(The )SM(bin.def)ES( module \201auto)HY(mat)HY(i)HY(cally)YH( loaded by the
  )SM(c)ES( and )SM(cxx)ES( modules for the
  )SM(*-win32-msvc)ES( targets\202 provides a rule for gener)HY(at)HY(ing)YH(
  symbol-export)HY(ing)YH( )SM(.def)ES( files. This allows auto)HY(mat)HY(i)HY(cally)YH(
  export)HY(ing)YH( all symbols for all the Windows targets/compil)HY(ers)YH( using the
  follow)HY(ing)YH( arrange)HY(ment)YH( \201showing for )SM(cxx)ES( in this example\202:)EP(

  ) 7 67 PR(lib{foo}: libul{foo}: {hxx cxx}{**} ...

libs{foo}: def{foo}: include = \201$cxx.target.system == 'win32-msvc'\202
def{foo}: libul{foo}

if \201$cxx.target.system == 'mingw32'\202
  cxx.loptions += -Wl,--export-all-symbols)RP(

  )0 P(That is, we use the )SM(.def)ES( file approach for MSVC \201includ)HY(ing)YH(
  when build)HY(ing)YH( with Clang\202 and the built-in support
  \201)SM(--export-all-symbols)ES(\202 for MinGW.)EP(

  )BR(
  )0 P(You will likely also want to add the gener)HY(ated)YH( )SM(.def)ES( file \201or
  the blanket )SM(*.def)ES(\202 to your )SM(.gitig)HY(nore)YH()ES( file.)EP(
  )BR(

  )0 P(Note that it is also possi)HY(ble)YH( to use the )SM(.def)ES( file approach
  for MinGW. In this case we need to explic)HY(itly)YH( load the )SM(bin.def)ES(
  module \201which should be done after loading )SM(c)ES( or
  )SM(cxx)ES(\202 and can use the follow)HY(ing)YH( arrange)HY(ment)YH(:)EP(

  ) 6 35 PR(# root.build

using cxx

if \201$cxx.target.class == 'windows'\202
  using bin.def)RP(

  ) 4 63 PR(lib{foo}: libul{foo}: {hxx cxx}{**} ...

libs{foo}: def{foo}: include = \201$cxx.target.class == 'windows'\202
def{foo}: libul{foo})RP(

  )0 P(Note also that this only deals with export)HY(ing)YH( of the symbols from a DLL.
  In order to work, code that uses such a DLL should be able to import the
  symbols without explicit )SM(__declspec\201dllimport\202)ES( decla)HY(ra)HY(tions)YH(.
  This works thanks to the symbol auto-import)HY(ing)YH( support in Windows linkers.
  Note, however, that auto-import)HY(ing)YH( only works for func)HY(tions)YH( and not for
  global vari)HY(ables)YH(.)EP(

  )0 2 180 H(14.5)WB 391 Sn()WB 182 Sn( Impor)HY(ta)HY(tion)YH( of Installed Libraries)EH(

  )0 P(As discussed in )0 12 1 A(Target Impor)HY(ta)HY(tion)YH()12 0 TN TL()Ec /AF f D(, search)HY(ing)YH(
  for installed C/C++ libraries is seam)HY(lessly)YH( inte)HY(grated)YH( into the general
  target impor)HY(ta)HY(tion)YH( mech)HY(a)HY(nism)YH(. This section provides more details on the
  installed library search seman)HY(tics)YH( and )SM(pkg-config)ES( inte)HY(gra)HY(tion)YH(.
  These details can be partic)HY(u)HY(larly)YH( useful when dealing with libraries that
  were not built with )SM(build2)ES( and which often use idiosyn)HY(cratic)YH(
  )SM(pkg-config)ES( file names.)EP(

  )0 P(The )SM(cc)ES(-based modules use the common installed library search
  imple)HY(men)HY(ta)HY(tion)YH( with the follow)HY(ing)YH( seman)HY(tics)YH(. To illus)HY(trate)YH( the finer points,
  we assume the follow)HY(ing)YH( import:)EP(

  ) 1 30 PR(import libs = libbar%lib{Xfoo})RP(

  )4 OL(  )-1 LI(First, the ordered list of library search direc)HY(to)HY(ries)YH( is obtained by
  combin)HY(ing)YH( two lists: the lists of the compiler's system library search
  direc)HY(to)HY(ries)YH( \201extracted, for example, with )SM(-print-search-dirs)ES(
  GCC/Clang options\202 and the list of user library search direc)HY(to)HY(ries)YH(
  \201spec)HY(i)HY(fied)YH(, for example, with the )SM(-L)ES( options in
  )SM(*.loptions)ES(\202.

  )0 P(The key prop)HY(erty)YH( of this combined list is that it matches the search
  seman)HY(tics)YH( that would be used by the compiler to find libraries spec)HY(i)HY(fied)YH(
  with the )SM(-l)ES( option during linking.)EP(

  )-1 LI(Given the list obtained in the previ)HY(ous)YH( step, a library binary \201shared
  and/or static library\202 is searched for in the correct order and using the
  target plat)HY(form)YH(-appro)HY(pri)HY(ate)YH( library prefix and exten)HY(sion)YH( \201for example,
  )SM(lib)ES( prefix and the )SM(.so)ES(/)SM(.a)ES( exten)HY(sions)YH(
  if target)HY(ing)YH( Linux\202.

  )0 P(For example \201contin)HY(u)HY(ing)YH( with the above import and assum)HY(ing)YH( Linux\202, each
  direc)HY(tory)YH( will be checked for the pres)HY(ence)YH( of )SM(libXfoo.so)ES( and
  )SM(libXfoo.a)ES( \201where the )SM(Xfoo)ES( stem is the imported
  target name\202.)EP(

  )0 P(If only a shared or static binary is found in a given direc)HY(tory)YH(, no
  further direc)HY(to)HY(ries)YH( are checked for the missing variant. Instead, the
  missing variant is assumed to be unavail)HY(able)YH(.)EP(

  )0 P(If neither a shared nor static library is found in a given direc)HY(tory)YH(,
  then it is also checked for the pres)HY(ence)YH( of the corre)HY(spond)HY(ing)YH(
  )SM(pkg-config)ES( file as in the follow)HY(ing)YH( step. If such a file is
  found, then the library is assumed to be )I(binless)ES( \201header-only,
  etc\202.)EP(

  )-1 LI(If a static and/or shared library is found \201or if looking for a binless
  library\202, the corre)HY(spond)HY(ing)YH( )SM(pkg-config)ES( subdi)HY(rec)HY(tory)YH( \201normally
  just )SM(pkgcon)HY(fig)YH(/)ES(\202 is searched for the library's )SM(.pc)ES(
  file.

  )0 P(More precisely, we first look for the )SM(.static.pc)ES( file for a
  static library and for the )SM(.shared.pc)ES( file for a shared library
  falling back to the common )SM(.pc)ES( if they don't exist.)EP(

  )BR(
  )0 P(It is often required to use differ)HY(ent)YH( options for consum)HY(ing)YH( static and
  shared libraries. While there is the )SM(Libs.private)ES( and
  )SM(Cflags.private)ES( mech)HY(a)HY(nism)YH( in )SM(pkg-config)ES(, its
  seman)HY(tics)YH( is to append options to )SM(Libs)ES( and )SM(Cflags)ES(
  rather than to provide alter)HY(na)HY(tive)YH( options. And often the required seman)HY(tics)YH(
  is to provide differ)HY(ent)YH( options for static and shared libraries, such as to
  provide a macro which indi)HY(cates)YH( whether linking static or shared in order to
  setup symbol export)HY(ing)YH(.)EP(

  )0 P(As a result, in )SM(build2)ES( we produce sepa)HY(rate)YH( )SM(.pc)ES(
  files for static and shared libraries in addi)HY(tion)YH( to the "best effort"
  common )SM(.pc)ES( file for compat)HY(i)HY(bil)HY(ity)YH( with other build systems.
  Simi)HY(larly)YH(, when consum)HY(ing)YH( a library we first look for the
  )SM(.static.pc)ES( and )SM(.shared.pc)ES( files falling back to
  the common )SM(.pc)ES( if they are not avail)HY(able)YH(.)EP(
  )BR(

  )0 P(To deal with idiosyn)HY(crasies)YH( in )SM(pkg-config)ES( file names, the
  follow)HY(ing)YH( base names are tried in order, where )SM()I(name)ES()ES( is
  the imported target name \201)SM(Xfoo)ES( in the above import\202,
  )SM()I(proj)ES()ES( is the imported project name \201)SM(libbar)ES(
  in the above import\202, and )SM()I(ext)ES()ES( is one of the
  above-mentioned )SM(pkg-config)ES( exten)HY(sions)YH( \201)SM(static.pc)ES(,
  )SM(shared.pc)ES(, or )SM(pc)ES(\202. The concrete name tried for the
  above import is shown in paren)HY(the)HY(sis)YH( as an example.)EP(

  )4 OL(  )-1 LI()SM(lib)I(name)ES(.)I(ext)ES()ES( \201)SM(libXfoo.pc)ES(\202

  )-1 LI()SM()I(name)ES(.)I(ext)ES()ES( \201)SM(Xfoo.pc)ES(\202

  )-1 LI(lower)HY(case)YH( )SM(lib)I(name)ES(.)I(ext)ES()ES(
  \201)SM(libxfoo.pc)ES(\202

  )-1 LI(lower)HY(case)YH( )SM()I(name)ES(.)I(ext)ES()ES(
  \201)SM(xfoo.pc)ES(\202

  )-1 LI()SM()I(proj)ES(.)I(ext)ES()ES( \201)SM(libbar.pc)ES(; this test
  is omitted if not project-qual)HY(i)HY(fied)YH(\202
  )LO(
  )LO(

  )0 P(In partic)HY(u)HY(lar)YH(, the last try \201for )SM()I(proj)ES(.)I(ext)ES()ES(\202
  serves as an escape hatch for cases where the )SM(.pc)ES( file name
  does not have anything to do with the names of library bina)HY(ries)YH(. The
  canon)HY(i)HY(cal)YH( example of this is )SM(zlib)ES( which names its library
  bina)HY(ries)YH( )SM(libz.so)ES(/)SM(libz.a)ES( while its )SM(.pc)ES(
  file \235 )SM(zlib.pc)ES(. To be able to import )SM(zlib)ES(
  that was not built with )SM(build2)ES(, we have to use the follow)HY(ing)YH(
  import:)EP(

  ) 1 25 PR(import libs = zlib%lib{z})RP(

  )0 P(Note also that these complex rules \201which are unfor)HY(tu)HY(nately)YH( neces)HY(sary)YH( to
  deal with the lack of any consis)HY(tency)YH( in )SM(.pc)ES( file naming\202 can
  some)HY(times)YH( produce surpris)HY(ing)YH( inter)HY(ac)HY(tions)YH(. For example, it may appear that a
  clearly incor)HY(rect)YH( import never)HY(the)HY(less)YH( appears to somehow work, as in the
  follow)HY(ing)YH( example:)EP(

  ) 1 33 PR(import libs = zlib%lib{znonsense})RP(

  )0 P(What happens here is that while no library binary is found,
  )SM(zlib.pc)ES( is found and as a result the library ends up being
  consid)HY(ered)YH( binless with the )SM(-lz)ES( \201that is found in the
  )SM(Libs)ES( value of )SM(zlib.pc)ES(\202 treated as a prereq)HY(ui)HY(site)YH(
  library, resolved using the above algo)HY(rithm)YH(, and linked. In other words, in
  this case we end up with a binless library )SM(lib{znon)HY(sense)YH(})ES( that
  depends on )SM(lib{z})ES( instead of a single )SM(lib{z})ES(
  library.)EP(

  )0 3 181 H(14.5.1)WB 392 Sn()WB 183 Sn( Rewrit)HY(ing)YH( Installed Libraries
  System Root \201sysroot\202)EH(

  )0 P(Some)HY(times)YH( the installed libraries are moved to a differ)HY(ent)YH( loca)HY(tion)YH( after
  the instal)HY(la)HY(tion)YH(. This is espe)HY(cially)YH( common in embed)HY(ded)YH( devel)HY(op)HY(ment)YH( where
  the code is normally cross-compiled and the libraries for the target
  plat)HY(form)YH( are placed into a host direc)HY(tory)YH(, called system root or
  )I(sysroot)ES(, that doesn't match where these libraries were orig)HY(i)HY(nally)YH(
  installed to. For example, the libraries might have been installed into
  )SM(/usr/)ES( but on the host machine they may reside in
  )SM(/opt/target/usr/)ES(. In this example, )SM(/opt/target/)ES( is
  the sysroot.)EP(

  )0 P(While such relo)HY(ca)HY(tions)YH( usually do not affect the library headers or
  bina)HY(ries)YH(, they do break the )SM(pkg-config)ES('s )SM(.pc)ES( files
  which often contain )SM(-I)ES( and )SM(-L)ES( options with
  abso)HY(lute)YH( paths. Continue with the above example, a )SM(.pc)ES( file as
  orig)HY(i)HY(nally)YH( installed may contain )SM(-I/usr/include)ES( and
  )SM(-L/usr/lib)ES( while now, that the libraries have been relo)HY(cated)YH( to
  )SM(/opt/target/)ES(, they somehow need to be adjusted to
  )SM(-I/opt/target/usr/include)ES( and
  )SM(-L/opt/target/usr/lib)ES(.)EP(

  )0 P(While it is possi)HY(ble)YH( \201and perhaps correct\202 to accom)HY(plish)YH( this by fixing
  the )SM(.pc)ES( files to match the new loca)HY(tion)YH(, it is not always
  possi)HY(ble)YH( or easy. As a result, )SM(build2)ES( provides a mech)HY(a)HY(nism)YH( for
  auto)HY(mat)HY(i)HY(cally)YH( adjust)HY(ing)YH( the system root in the )SM(-I)ES( and
  )SM(-L)ES( options extracted from )SM(.pc)ES( files.)EP(

  )BR(
  )0 P(This func)HY(tion)HY(al)HY(ity)YH( is roughly equiv)HY(a)HY(lent)YH( to that provided with the
  )SM(PKG_CONFIG_SYSROOT_DIR)ES( envi)HY(ron)HY(ment)YH( vari)HY(able)YH( by the
  )SM(pkg-config)ES( utility.)EP(
  )BR(

  )0 P(Specif)HY(i)HY(cally)YH(, the )SM(config.cc.pkgcon)HY(fig)YH(.sysroot)ES( vari)HY(able)YH( can
  be used to specify an alter)HY(na)HY(tive)YH( system root. When spec)HY(i)HY(fied)YH(, all abso)HY(lute)YH(
  paths in the )SM(-I)ES( and )SM(-L)ES( options that are not
  already in this direc)HY(tory)YH( will be rewrit)HY(ten)YH( to start with this sysroot.)EP(

  )BR(
  )0 P(Note that this mech)HY(a)HY(nism)YH( is a workaround rather than a proper solu)HY(tion)YH(
  since it is limited to the )SM(-I)ES( and )SM(-L)ES( options. In
  partic)HY(u)HY(lar)YH(, it does not handle any other options that may contain abso)HY(lute)YH(
  paths nor )SM(pkg-config)ES( vari)HY(ables)YH( that may be queried.)EP(

  )0 P(As a result, it should only be used for dealing with issues in
  third-party )SM(.pc)ES( files that do not handle relo)HY(ca)HY(tion)YH( \201for
  example, using the )SM(${pcfiledir})ES( built-in
  )SM(pkg-config)ES( vari)HY(able)YH(\202. In partic)HY(u)HY(lar)YH(, for
  )SM(build2)ES(-gener)HY(ated)YH( )SM(.pc)ES( files a )0 165 1 A(relo)HY(cat)HY(able)YH( instal)HY(la)HY(tion)YH()165 0 TN TL()Ec /AF f D( should be used
  instead.)EP(
  )BR(

  )0 2 182 H(14.6)WB 393 Sn()WB 184 Sn( GCC Compiler Toolchain)EH(

  )0 P(The GCC compiler id is )SM(gcc)ES(.)EP(

  )0 2 183 H(14.7)WB 394 Sn()WB 185 Sn( Clang Compiler Toolchain)EH(

  )0 P(The vanilla Clang compiler id is )SM(clang)ES( \201includ)HY(ing)YH( when
  target)HY(ing)YH( the MSVC runtime\202, Apple Clang compiler id is
  )SM(clang-apple)ES(, and Clang's )SM(cl)ES( compat)HY(i)HY(bil)HY(ity)YH( driver
  \201)SM(clang-cl)ES(\202 id is )SM(msvc-clang)ES(.)EP(

  )0 3 184 H(14.7.1)WB 395 Sn()WB 186 Sn( Clang Target)HY(ing)YH( MSVC)EH(

  )0 P(There are two common ways to obtain Clang on Windows: bundled with the
  MSVC instal)HY(la)HY(tion)YH( or as a sepa)HY(rate)YH( instal)HY(la)HY(tion)YH(. If you are using the
  sepa)HY(rate)YH( instal)HY(la)HY(tion)YH(, then the Clang compiler is most likely already in the
  )SM(PATH)ES( envi)HY(ron)HY(ment)YH( vari)HY(able)YH(. Other)HY(wise)YH(, if you are using Clang
  that is bundled with MSVC, the )SM(cc)ES( module will attempt various
  search strate)HY(gies)YH( described below. Note, however, that in both cases once
  the Clang compiler binary located, the mode \20132 or 64-bit\202 and the rest of
  the envi)HY(ron)HY(ment)YH( \201loca)HY(tions)YH( of binary util)HY(i)HY(ties)YH( as well as the system headers
  and libraries\202 are obtained by query)HY(ing)YH( Clang.)EP(

  )BR(
  )0 P(Normally, if Clang is invoked from one of the Visual Studio command
  prompts, then it will use the corre)HY(spond)HY(ing)YH( Visual Studio version and
  envi)HY(ron)HY(ment)YH( \201it is, however, still up to you to match the mode with the
  )SM(-m32)ES(/)SM(-m64)ES( options, if neces)HY(sary)YH(\202. Other)HY(wise)YH(, Clang
  will try to locate the latest version of Visual Studio and Plat)HY(form)YH( SDK and
  use that \201in this case it matches the envi)HY(ron)HY(ment)YH( to the
  )SM(-m32)ES(/)SM(-m64)ES( options\202.  Refer to Clang docu)HY(men)HY(ta)HY(tion)YH(
  for details.)EP(
  )BR(

  )0 P(If you specify the compiler as just )SM(config.c=clang)ES( or
  )SM(config.cxx=clang++)ES( and it is found in the )SM(PATH)ES(
  envi)HY(ron)HY(ment)YH( vari)HY(able)YH( or if you specify it as an abso)HY(lute)YH( path, then the
  )SM(cc)ES( module will use that.)EP(

  )0 P(Other)HY(wise)YH(, if you are build)HY(ing)YH( from one of the Visual Studio devel)HY(op)HY(ment)YH(
  command prompts, the )SM(cc)ES( module will look for the corre)HY(spond)HY(ing)YH(
  bundled Clang \201)SM(%VCIN)HY(STALLDIR)YH(%\200Tools\200Llvm\200bin)ES(\202.)EP(

  )0 P(Finally, the )SM(cc)ES( module will attempt to locate the latest
  installed version of Visual Studio and look for a bundled Clang in
  there.)EP(

  )0 P(The default mode \20132 or 64-bit\202 depends on the Clang config)HY(u)HY(ra)HY(tion)YH( and
  can be over)HY(rid)HY(den)YH( with the )SM(-m32)ES(/)SM(-m64)ES( options. For
  example:)EP(

  ) 1 29 PR(> b "config.cxx=clang++ -m64")RP(

  )0 P(The default MSVC runtime selected by the )SM(cc)ES( module is
  multi-threaded shared \201the )SM(/MD)ES( option in )SM(cl)ES(\202.
  Unfor)HY(tu)HY(nately)YH(, the Clang driver does not yet provide anything equiv)HY(a)HY(lent)YH( to
  the )SM(cl)ES( )SM(/M*)ES( options \201see )R5 2 A(Clang bug #33273)EA(\202 and
  selec)HY(tion)YH( of an alter)HY(na)HY(tive)YH( runtime has to be performed manu)HY(ally)YH(:)EP(

  ) 19 58 PR(> rem /MD  - multi-threaded shared \201default\202
> rem
> b "config.cxx=clang++ -nostdlib -D_MT -D_DLL" ^
    config.cc.libs=/DEFAULTLIB:msvcrt

> rem /MDd - multi-threaded debug shared
> rem
> b "config.cxx=clang++ -nostdlib -D_MT -D_DLL -D_DEBUG" ^
    config.cc.libs=/DEFAULTLIB:msvcrtd

> rem /MT  - multi-threaded static
> rem
> b "config.cxx=clang++ -nostdlib -D_MT" ^
    config.cc.libs=/DEFAULTLIB:libcmt

> rem /MTd - multi-threaded debug static
> rem
> b "config.cxx=clang++ -nostdlib -D_MT -D_DEBUG" ^
    config.cc.libs=/DEFAULTLIB:libcmtd)RP(

  )0 P(By default the MSVC's binary util)HY(i)HY(ties)YH( \201)SM(link)ES( and
  )SM(lib)ES(\202 are used when compil)HY(ing)YH( with Clang. It is, however,
  possi)HY(ble)YH( to use LLVM's versions instead, for example:)EP(

  ) 3 28 PR(> b config.cxx=clang++     ^
    config.bin.ld=lld-link ^
    config.bin.ar=llvm-lib)RP(

  )0 P(In partic)HY(u)HY(lar)YH(, one benefit of using )SM(llvm-lib)ES( is support for
  thin archives which, if avail)HY(able)YH(, is auto)HY(mat)HY(i)HY(cally)YH( enabled for utility
  libraries.)EP(

  )BR(
  )0 P(While there is basic support for Clang's )SM(cl)ES( compat)HY(i)HY(bil)HY(ity)YH(
  driver \201)SM(clang-cl)ES(\202, its use is not recom)HY(mended)YH(. This driver is a
  very thin wrapper over the stan)HY(dard)YH( Clang inter)HY(face)YH( that does not always
  recre)HY(ate)YH( the )SM(cl)ES('s seman)HY(tics)YH( exactly. Specif)HY(i)HY(cally)YH(, its
  diag)HY(nos)HY(tics)YH( in the )SM(/show)HY(In)HY(cludes)YH()ES( mode does not match that of
  )SM(cl)ES( in the pres)HY(ence)YH( of missing headers. As a result,
  )SM(clang-cl)ES('s use, if any, should be limited to projects that do
  not have auto-gener)HY(ated)YH( headers.)EP(

  )0 P(If you need to link with other projects that use )SM(clang-cl)ES(,
  then the recom)HY(mended)YH( approach is to discover any addi)HY(tional)YH( )SM(cc1)ES(
  options passed by )SM(clang-cl)ES( by compar)HY(ing)YH( the )SM(-v)ES(
  output of a test compi)HY(la)HY(tion)YH( with )SM(clang-cl)ES( and
  )SM(clang)ES(/)SM(clang++)ES( and then passing them explic)HY(itly)YH( to
  )SM(clang)ES(/)SM(clang++)ES(, poten)HY(tially)YH( prefixed with
  )SM(-Xclang)ES(. For example:)EP(

  ) 1 48 PR(b "config.cxx=clang++ -Xclang -fms-volatile ...")RP(

  )0 P(Rele)HY(vant)YH( addi)HY(tional)YH( options that are passed by )SM(clang-cl)ES( at
  the time of this writing:)EP(

  ) 4 24 PR(-fno-strict-aliasing
-fstack-protector-strong
-Xclang -fms-volatile
-ffunction-sections)RP(
  )BR(

  )0 2 185 H(14.8)WB 396 Sn()WB 187 Sn( MSVC Compiler Toolchain)EH(

  )0 P(The Microsoft VC \201MSVC\202 compiler id is )SM(msvc)ES(.)EP(

  )0 P(There are several ways to specify the desired MSVC compiler and mode \20132
  or 64-bit\202 as well as the corre)HY(spond)HY(ing)YH( envi)HY(ron)HY(ment)YH( \201loca)HY(tions)YH( of binary
  util)HY(i)HY(ties)YH( as well as the system headers and libraries\202.)EP(

  )BR(
  )0 P(Unlike other compil)HY(ers)YH(, MSVC compiler \201)SM(cl)ES(\202 bina)HY(ries)YH( are
  target-specific, that is, there are no )SM(-m32)ES(/)SM(-m64)ES(
  options nor some)HY(thing)YH( like the )SM(/MACHINE)ES( option avail)HY(able)YH( in
  )SM(link)ES(.)EP(
  )BR(

  )0 P(If the compiler is spec)HY(i)HY(fied)YH( as just )SM(cl)ES( in
  )SM(config.{c,cxx)ES(} and it is found in the )SM(PATH)ES(
  envi)HY(ron)HY(ment)YH( vari)HY(able)YH(, then the )SM(cc)ES( module assumes the build is
  performed from one of the Visual Studio devel)HY(op)HY(ment)YH( command prompts and
  expects the envi)HY(ron)HY(ment)YH( \201the )SM(PATH)ES(, )SM(INCLUDE)ES(, and
  )SM(LIB)ES( envi)HY(ron)HY(ment)YH( vari)HY(ables)YH(\202 to already be setup.)EP(

  )0 P(If, however, )SM(cl)ES( is not found in )SM(PATH)ES(, then the
  )SM(cc)ES( module will attempt to locate the latest installed version
  of Visual Studio and Plat)HY(form)YH( SDK and use that in the 64-bit mode.)EP(

  )0 P(Finally, if the compiler is spec)HY(i)HY(fied)YH( as an abso)HY(lute)YH( path to
  )SM(cl)ES(, then the )SM(cc)ES( module will attempt to locate the
  corre)HY(spond)HY(ing)YH( Visual Studio instal)HY(la)HY(tion)YH( as well as the latest Plat)HY(form)YH( SDK
  and use that in the mode corre)HY(spond)HY(ing)YH( to the spec)HY(i)HY(fied)YH( )SM(cl)ES(
  executable. Note that to specify an abso)HY(lute)YH( path to )SM(cl)ES( \201which
  most likely contains spaces\202 we have to use two levels of quoting:)EP(

  ) 1 67 PR(> b "config.cxx='...\200VC\200Tools\200MSVC\20014.23.28105\200bin\200Hostx64\200x86\200cl'")RP(

  )BR(
  )0 P(The latter two methods are only avail)HY(able)YH( for Visual Studio 15 \2012017\202 and
  later and for earlier versions the devel)HY(op)HY(ment)YH( command prompt must be
  used.)EP(
  )BR(

  )0 P(The default MSVC runtime selected by the )SM(cc)ES( module is
  multi-threaded shared \201the )SM(/MD)ES( )SM(cl)ES( option\202. An
  alter)HY(na)HY(tive)YH( runtime can be selected by passing one of the )SM(cl)ES(
  )SM(/M*)ES( options, for example:)EP(

  ) 1 23 PR(> b "config.cxx=cl /MT")RP(

  )0 1 186 H(15)WB 397 Sn()WB 188 Sn( )SM(c)ES( Module)EH(

  )0 P(This chapter is a work in progress and is
  incom)HY(plete)YH(.)EP(

  )0 P(This chapter describes the )SM(c)ES( build system module which
  provides the C compi)HY(la)HY(tion)YH( and linking support. Most of its func)HY(tion)HY(al)HY(ity)YH(,
  however, is provided by the )0 176 1 A()SM(cc)ES()176 0 TN TL()Ec /AF f D( module,
  a common imple)HY(men)HY(ta)HY(tion)YH( for the C-family languages.)EP(

  )0 2 187 H(15.1)WB 398 Sn()WB 189 Sn( C Config)HY(u)HY(ra)HY(tion)YH( Vari)HY(ables)YH()EH(

  )0 P(The follow)HY(ing)YH( listing summa)HY(rizes)YH( the )SM(c)ES( module config)HY(u)HY(ra)HY(tion)YH(
  vari)HY(ables)YH( as well as the corre)HY(spond)HY(ing)YH( module-specific vari)HY(ables)YH( that are
  derived from their values. See also )0 177 1 A(C-Common
  Config)HY(u)HY(ra)HY(tion)YH( Vari)HY(ables)YH()177 0 TN TL()Ec /AF f D(.)EP(

  ) 45 23 PR(config.c
  c.path
  c.mode

config.c.id
  c.id
  c.id.type
  c.id.variant
  c.class

config.c.version
  c.version
  c.version.major
  c.version.minor
  c.version.patch
  c.version.build

config.c.target
  c.target
  c.target.cpu
  c.target.vendor
  c.target.system
  c.target.version
  c.target.class

config.c.std
  c.std

config.c.poptions
  c.poptions
)WR(
config.c.coptions
  c.coptions

config.c.loptions
  c.loptions

config.c.aoptions
  c.aoptions

config.c.libs
  c.libs

config.c.internal.scope
  c.internal.scope)RP(

  )0 2 188 H(15.2)WB 399 Sn()WB 190 Sn( C Target Types)EH(

  )0 P(The follow)HY(ing)YH( listing shows the hier)HY(ar)HY(chy)YH( of the target types defined by
  the )SM(c)ES( module while the follow)HY(ing)YH( sections describe each target
  type in detail \201)SM(file{})ES( is a stan)HY(dard)YH( target type defined by the
  )SM(build2)ES( core; see )0 27 1 A(Target Types)27 0 TN TL()Ec /AF f D( for
  details\202. See also )0 178 1 A(C-Common Target Types)178 0 TN TL()Ec /AF f D( for
  target types defined by all the )SM(cc)ES(-based modules.)EP(

  ) 4 10 PR(.--file--.
|   |    |
c   m    S
h)RP(

  )0 P(The )SM(m{})ES( target type repre)HY(sents)YH( an Objec)HY(tive)YH(-C source file,
  see )0 2 A(Objec)HY(tive)YH(-C Compi)HY(la)HY(tion)YH()EA( for details.)EP(

  )0 P(The )SM(S{})ES( target type repre)HY(sents)YH( an Assem)HY(bler)YH( with C
  Prepro)HY(ces)HY(sor)YH( file, see )0 2 A(Assem)HY(bler)YH( with C Prepro)HY(ces)HY(sor)YH(
  Compi)HY(la)HY(tion)YH()EA( for details.)EP(

  )0 3 189 H(15.2.1)WB 400 Sn()WB 191 Sn( )SM(c{})ES(, )SM(h{})ES()EH(

  )0 P(The )SM(c{})ES( and )SM(h{})ES( target types repre)HY(sent)YH( C source
  and header files. They have the default exten)HY(sions)YH( )SM(.c)ES( and
  )SM(.h)ES(, respec)HY(tively)YH(, which can be customized with the
  )SM(exten)HY(sion)YH()ES( vari)HY(able)YH(.)EP(

  )0 2 190 H(15.3)WB 401 Sn()WB 192 Sn( Objec)HY(tive)YH(-C Compi)HY(la)HY(tion)YH()EH(

  )0 P(The )SM(c)ES( module provides the )SM(c.objc)ES( submod)HY(ule)YH(
  which can be loaded in order to regis)HY(ter)YH( the )SM(m{})ES( target type
  and enable Objec)HY(tive)YH(-C compi)HY(la)HY(tion)YH( in the )SM(C)ES( compile rule. Note
  that )SM(c.objc)ES( must be loaded after the )SM(c)ES( module and
  while the )SM(m{})ES( target type is regis)HY(tered)YH( uncon)HY(di)HY(tion)HY(ally)YH(,
  compi)HY(la)HY(tion)YH( is only enabled if the C compiler supports Objec)HY(tive)YH(-C for the
  target plat)HY(form)YH(. Typical usage:)EP(

  ) 4 12 PR(# root.build
#
using c
using c.objc)RP(

  ) 4 57 PR(# buildfile
#
lib{hello}: {h c}{*}
lib{hello}: m{*}: include = \201$c.target.class  == 'macos'\202)RP(

  )0 P(Note also that while there is support for linking Objec)HY(tive)YH(-C executa)HY(bles)YH(
  and libraries, this is done using the C compiler driver and no attempt is
  made to auto)HY(mat)HY(i)HY(cally)YH( link any neces)HY(sary)YH( Objec)HY(tive)YH(-C runtime library \201such
  as )SM(-lobjc)ES(\202.)EP(

  )0 2 191 H(15.4)WB 402 Sn()WB 193 Sn( Assem)HY(bler)YH( with C Prepro)HY(ces)HY(sor)YH( Compi)HY(la)HY(tion)YH()EH(

  )0 P(The )SM(c)ES( module provides the )SM(c.as-cpp)ES( submod)HY(ule)YH(
  which can be loaded in order to regis)HY(ter)YH( the )SM(S{})ES( target type
  and enable Assem)HY(bler)YH( with C Prepro)HY(ces)HY(sor)YH( compi)HY(la)HY(tion)YH( in the )SM(C)ES(
  compile rule. Note that )SM(c.as-cpp)ES( must be loaded after the
  )SM(c)ES( module and while the )SM(S{})ES( target type is
  regis)HY(tered)YH( uncon)HY(di)HY(tion)HY(ally)YH(, compi)HY(la)HY(tion)YH( is only enabled if the C compiler
  supports Assem)HY(bler)YH( with C Prepro)HY(ces)HY(sor)YH( compi)HY(la)HY(tion)YH(. Typical usage:)EP(

  ) 4 14 PR(# root.build
#
using c
using c.as-cpp)RP(

  ) 10 60 PR(# buildfile
#
exe{hello}: {h c}{* -hello.c}

# Use C implementation as a fallback if no assembler.
#
assembler = \201$c.class == 'gcc' && $c.target.cpu == 'x86_64'\202

exe{hello}: S{hello}: include = $assembler
exe{hello}: c{hello}: include = \201!$assembler\202)RP(

  ) 17 39 PR(/* hello.S
 */
#ifndef HELLO_RESULT
#  define HELLO_RESULT 0
#endif

text

.global hello
hello:
  /* ... */
  movq $HELLO_RESULT, %rax
  ret

#ifdef __ELF__
.section .note.GNU-stack, "", @progbits
#endif)RP(

  )0 P(The default file exten)HY(sion)YH( for the )SM(S{})ES( target type is
  )SM(.S)ES( \201capital\202 but that can be customized using the stan)HY(dard)YH(
  mech)HY(a)HY(nisms)YH(. For example:)EP(

  ) 8 20 PR(# root.build
#
using c
using c.as-cpp

h{*}: extension = h
c{*}: extension = c
S{*}: extension = sx)RP(

  )0 P(Note that )SM(*.coptions)ES( are passed to the C compiler when
  compil)HY(ing)YH( Assem)HY(bler)YH( with C Prepro)HY(ces)HY(sor)YH( files because compile options may
  cause addi)HY(tional)YH( prepro)HY(ces)HY(sor)YH( macros to be defined. Plus, some of them \201such
  as )SM(-g)ES(\202 are passed \201poten)HY(tially)YH( trans)HY(lated)YH(\202 to the under)HY(ly)HY(ing)YH(
  assem)HY(bler)YH(. To pass addi)HY(tional)YH( options when compil)HY(ing)YH( Assem)HY(bler)YH( files use
  )SM(c.poptions)ES( and )SM(c.coptions)ES(. For example \201contin)HY(u)HY(ing)YH(
  with the previ)HY(ous)YH( example\202:)EP(

  ) 8 39 PR(if $assembler
{
  obj{hello}:
  {
    c.poptions += -DHELLO_RESULT=1
    c.coptions += -Wa,--no-pad-sections
  }
})RP(

  )0 2 192 H(15.5)WB 403 Sn()WB 194 Sn( C Compiler Prede)HY(fined)YH( Macro Extrac)HY(tion)YH()EH(

  )0 P(The )SM(c)ES( module provides the )SM(c.predefs)ES( submod)HY(ule)YH(
  which can be loaded in order to regis)HY(ter)YH( a rule that gener)HY(ates)YH( a C header
  with prede)HY(fined)YH( compiler macros. Note that the )SM(c.predefs)ES( module
  must be loaded after the )SM(c)ES( module and the rule will only match
  with an explicit rule hint. Typical usage:)EP(

  ) 4 15 PR(# root.build
#
using c
using c.predefs)RP(

  ) 3 33 PR(# buildfile
#
[rule_hint=c.predefs] h{predefs}:)RP(

  )0 P(Note also that the MSVC compiler only supports the prede)HY(fined)YH( macro
  extrac)HY(tion)YH( start)HY(ing)YH( from Visual Studio 2019 \20116.0; )SM(cl.exe)ES(
  version 19.20\202. If support for earlier versions is required, then you will
  need to provide a fall)HY(back)YH( imple)HY(men)HY(ta)HY(tion)YH( appro)HY(pri)HY(ate)YH( for your project. For
  example:)EP(

  ) 12 56 PR([rule_hint=c.predefs] h{predefs}:
% update
if \201$c.id == 'msvc' && \200
    \201$c.version.major < 19 || \200
     \201$c.version.major == 19 && $c.version.minor < 20\202\202\202
{{
  diag c-predefs $>

  cat <<EOF >$path\201$>\202
  #define _WIN32
  EOF
}})RP(

  )0 1 193 H(16)WB 404 Sn()WB 195 Sn( )SM(cxx)ES( Module)EH(

  )0 P(This chapter is a work in progress and is
  incom)HY(plete)YH(.)EP(

  )0 P(This chapter describes the )SM(cxx)ES( build system module which
  provides the C++ compi)HY(la)HY(tion)YH( and linking support. Most of its func)HY(tion)HY(al)HY(ity)YH(,
  however, is provided by the )0 176 1 A()SM(cc)ES()176 0 TN TL()Ec /AF f D( module,
  a common imple)HY(men)HY(ta)HY(tion)YH( for the C-family languages.)EP(

  )0 2 194 H(16.1)WB 405 Sn()WB 196 Sn( C++ Config)HY(u)HY(ra)HY(tion)YH( Vari)HY(ables)YH()EH(

  )0 P(The follow)HY(ing)YH( listing summa)HY(rizes)YH( the )SM(cxx)ES( module
  config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( as well as the corre)HY(spond)HY(ing)YH( module-specific
  vari)HY(ables)YH( that are derived from their values. See also )0 177 1 A(C-Common Config)HY(u)HY(ra)HY(tion)YH( Vari)HY(ables)YH()177 0 TN TL()Ec /AF f D(.)EP(

  ) 48 28 PR(config.cxx
  cxx.path
  cxx.mode

config.cxx.id
  cxx.id
  cxx.id.type
  cxx.id.variant
  cxx.class

config.cxx.version
  cxx.version
  cxx.version.major
  cxx.version.minor
  cxx.version.patch
  cxx.version.build

config.cxx.target
  cxx.target
  cxx.target.cpu
  cxx.target.vendor
  cxx.target.system
  cxx.target.version
  cxx.target.class

config.cxx.std
  cxx.std

config.cxx.poptions
  cxx.poptions
)WR(
config.cxx.coptions
  cxx.coptions

config.cxx.loptions
  cxx.loptions

config.cxx.aoptions
  cxx.aoptions

config.cxx.libs
  cxx.libs

config.cxx.internal.scope
  cxx.internal.scope

config.cxx.translate_include
  cxx.translate_include)RP(

  )0 2 195 H(16.2)WB 406 Sn()WB 197 Sn( C++ Target Types)EH(

  )0 P(The follow)HY(ing)YH( listing shows the hier)HY(ar)HY(chy)YH( of the target types defined by
  the )SM(cxx)ES( module while the follow)HY(ing)YH( sections describe each
  target type in detail \201)SM(file{})ES( is a stan)HY(dard)YH( target type defined
  by the )SM(build2)ES( core; see )0 27 1 A(Target
  Types)27 0 TN TL()Ec /AF f D( for details\202. See also )0 178 1 A(C-Common Target
  Types)178 0 TN TL()Ec /AF f D( for target types defined by all the )SM(cc)ES(-based
  modules.)EP(

  ) 7 11 PR( .--file--.
 |        |
cxx      mm
hxx
ixx
txx
mxx)RP(

  )0 P(The )SM(mm{})ES( target type repre)HY(sents)YH( an Objec)HY(tive)YH(-C++ source
  file, see )0 2 A(Objec)HY(tive)YH(-C++ Compi)HY(la)HY(tion)YH()EA( for
  details.)EP(

  )0 3 196 H(16.2.1)WB 407 Sn()WB 198 Sn( )SM(cxx{})ES(, )SM(hxx{})ES(,
  )SM(ixx{})ES(, )SM(txx{})ES(, )SM(mxx{})ES()EH(

  )0 P(The )SM(cxx{})ES(, )SM(hxx{})ES(, )SM(ixx{})ES(,
  )SM(txx{})ES(, and )SM(mxx{})ES( target types repre)HY(sent)YH( C++
  source, header, inline, template, and module inter)HY(face)YH( files. They have the
  default exten)HY(sions)YH( )SM(.cxx)ES(, )SM(.hxx)ES(, )SM(.ixx)ES(,
  )SM(.txx)ES(, and )SM(.mxx)ES(, respec)HY(tively)YH(, which can be
  customized with the )SM(exten)HY(sion)YH()ES( vari)HY(able)YH(. For example \201normally
  done in )SM(root.build)ES(\202:)EP(

  ) 5 24 PR(using cxx

cxx{*}: extension = cpp
hxx{*}: extension = hpp
mxx{*}: extension = cppm)RP(

  )0 2 197 H(16.3)WB 408 Sn()WB 199 Sn( C++ Modules Support)EH(

  )0 P(This section describes the build system support for C++ modules.)EP(

  )0 3 198 H(16.3.1)WB 409 Sn()WB 200 Sn( Modules Intro)HY(duc)HY(tion)YH()EH(

  )0 P(The goal of this section is to provide a prac)HY(ti)HY(cal)YH( intro)HY(duc)HY(tion)YH( to C++
  Modules and to estab)HY(lish)YH( key concepts and termi)HY(nol)HY(ogy)YH(. You can skip directly
  to )0 201 1 A(Build)HY(ing)YH( Modules)201 0 TN TL()Ec /AF f D( if you are already
  famil)HY(iar)YH( with this topic.)EP(

  )0 P(A pre-modules C++ program or library consists of one or more
  )I(trans)HY(la)HY(tion)YH( units)ES( which are custom)HY(ar)HY(ily)YH( referred to as C++ source
  files. Trans)HY(la)HY(tion)YH( units are compiled to )I(object files)ES( which are then
  linked together to form a program or library.)EP(

  )0 P(Let's also recap the differ)HY(ence)YH( between an )I(exter)HY(nal)YH( name)ES( and a
  )I(symbol)ES(: Exter)HY(nal)YH( names refer to language enti)HY(ties)YH(, for example
  classes, func)HY(tions)YH(, and so on. The )I(exter)HY(nal)YH()ES( qual)HY(i)HY(fier)YH( means they are
  visible across trans)HY(la)HY(tion)YH( units.)EP(

  )0 P(Symbols are derived from exter)HY(nal)YH( names for use inside object files. They
  are the cross-refer)HY(enc)HY(ing)YH( mech)HY(a)HY(nism)YH( for linking a program from multi)HY(ple)YH(,
  sepa)HY(rately)YH(-compiled trans)HY(la)HY(tion)YH( units. Not all exter)HY(nal)YH( names end up
  becom)HY(ing)YH( symbols and symbols are often )I(deco)HY(rated)YH()ES( with addi)HY(tional)YH(
  infor)HY(ma)HY(tion)YH(, for example, a names)HY(pace)YH(. We often talk about a symbol having
  to be satis)HY(fied)YH( by linking an object file or a library that provides it.
  Simi)HY(larly)YH(, dupli)HY(cate)YH( symbol issues may arise if more than one object file or
  library provides the same symbol.)EP(

  )0 P(What is a C++ module? It is hard to give a single but intu)HY(itive)YH( answer to
  this ques)HY(tion)YH(.  So we will try to answer it from three differ)HY(ent)YH(
  perspec)HY(tives)YH(: that of a module consumer, a module producer, and a build
  system that tries to make those two play nice. But we can make one thing
  clear at the outset: modules are a )I(language-level)ES( not a
  prepro)HY(ces)HY(sor)YH(-level mech)HY(a)HY(nism)YH(; it is )SM(import)ES(, not
  )SM(#import)ES(.)EP(

  )0 P(One may also wonder why C++ modules, what are the bene)HY(fits)YH(? Modules offer
  isola)HY(tion)YH(, both from prepro)HY(ces)HY(sor)YH( macros and other modules' symbols. Unlike
  headers, modules require explicit expor)HY(ta)HY(tion)YH( of enti)HY(ties)YH( that will be
  visible to the consumers. In this sense they are a )I(phys)HY(i)HY(cal)YH( design
  mech)HY(a)HY(nism)YH()ES( that forces us to think how we struc)HY(ture)YH( our code. Modules
  promise signif)HY(i)HY(cant)YH( build speedups since import)HY(ing)YH( a module, unlike
  includ)HY(ing)YH( a header, should be essen)HY(tially)YH( free. Modules are also the first
  step to not needing the prepro)HY(ces)HY(sor)YH( in most trans)HY(la)HY(tion)YH( units. Finally,
  modules have a chance of bring)HY(ing)YH( to main)HY(stream)YH( reli)HY(able)YH( and easy to setup
  distributed C++ compi)HY(la)HY(tion)YH(, since with modules build systems can make sure
  compil)HY(ers)YH( on the local and remote hosts are provided with iden)HY(ti)HY(cal)YH(
  inputs.)EP(

  )0 P(To refer to a module we use a )I(module name)ES(, a sequence of
  dot-sepa)HY(rated)YH( iden)HY(ti)HY(fiers)YH(, for example )SM(hello.core)ES(. While the
  spec)HY(i)HY(fi)HY(ca)HY(tion)YH( does not assign any hier)HY(ar)HY(chi)HY(cal)YH( seman)HY(tics)YH( to this sequence,
  it is custom)HY(ary)YH( to refer to )SM(hello.core)ES( as a submod)HY(ule)YH( of
  )SM(hello)ES(. We discuss submod)HY(ules)YH( and provide the module naming
  guide)HY(lines)YH( below.)EP(

  )0 P(From a consumer's perspec)HY(tive)YH(, a module is a collec)HY(tion)YH( of exter)HY(nal)YH(
  names, called )I(module inter)HY(face)YH()ES(, that become )I(visible)ES( once the
  module is imported:)EP(

  ) 1 18 PR(import hello.core;)RP(

  )0 P(What exactly does )I(visible)ES( mean? To quote the stan)HY(dard)YH(: )I(An
  import-decla)HY(ra)HY(tion)YH( makes exported decla)HY(ra)HY(tions)YH( [...] visible to name lookup
  in the current trans)HY(la)HY(tion)YH( unit, in the same names)HY(paces)YH( and contexts [...].
  [ Note: The enti)HY(ties)YH( are not rede)HY(clared)YH( in the trans)HY(la)HY(tion)YH( unit contain)HY(ing)YH(
  the module import decla)HY(ra)HY(tion)YH(. -- end note ])ES( One intu)HY(itive)YH( way to think
  about this visi)HY(bil)HY(ity)YH( is )I(as if)ES( there were only a single trans)HY(la)HY(tion)YH(
  unit for the entire program that contained all the modules as well as all
  their consumers. In such a trans)HY(la)HY(tion)YH( unit all the names would be visible
  to every)HY(one)YH( in exactly the same way and no entity would be rede)HY(clared)YH(.)EP(

  )0 P(This visi)HY(bil)HY(ity)YH( seman)HY(tics)YH( suggests that modules are not a name scoping
  mech)HY(a)HY(nism)YH( and are orthog)HY(o)HY(nal)YH( to names)HY(paces)YH(. Specif)HY(i)HY(cally)YH(, a module can
  export names from any number of names)HY(paces)YH(, includ)HY(ing)YH( the global names)HY(pace)YH(.
  While the module name and its names)HY(pace)YH( names need not be related, it
  usually makes sense to have a paral)HY(lel)YH( naming scheme, as discussed below.
  Finally, the )SM(import)ES( decla)HY(ra)HY(tion)YH( does not imply any addi)HY(tional)YH(
  visi)HY(bil)HY(ity)YH( for names declared inside names)HY(paces)YH(. Specif)HY(i)HY(cally)YH(, to access
  such names we must continue using the exist)HY(ing)YH( mech)HY(a)HY(nisms)YH(, such as
  qual)HY(i)HY(fi)HY(ca)HY(tion)YH( or using decla)HY(ra)HY(tion)YH(/direc)HY(tive)YH(. For example:)EP(

  ) 7 50 PR(import hello.core;        // Exports hello::say\201\202.

say \201\202;                   // Error.
hello::say \201\202;            // Ok.

using namespace hello;
say \201\202;                   // Ok.)RP(

  )0 P(Note also that from the consumer's perspec)HY(tive)YH( a module does not provide
  any symbols, only C++ entity names. If we use names from a module, then we
  may have to satisfy the corre)HY(spond)HY(ing)YH( symbols using the usual mech)HY(a)HY(nisms)YH(:
  link an object file or a library that provides them. In this respect,
  modules are similar to headers and as with headers, module's use is not
  limited to libraries; they make perfect sense when struc)HY(tur)HY(ing)YH( programs.
  Further)HY(more)YH(, a library may also have private or imple)HY(men)HY(ta)HY(tion)YH( modules that
  are not meant to be imported by the library's consumers.)EP(

  )0 P(The producer perspec)HY(tive)YH( on modules is predictably more complex. In
  pre-modules C++ we only had one kind of trans)HY(la)HY(tion)YH( unit \201or source file\202.
  With modules there are three kinds: )I(module inter)HY(face)YH( unit)ES(, )I(module
  imple)HY(men)HY(ta)HY(tion)YH( unit)ES(, and the orig)HY(i)HY(nal)YH( kind which we will call a
  )I(non-module trans)HY(la)HY(tion)YH( unit)ES(.)EP(

  )BR(
  )0 P(There are two addi)HY(tional)YH( modular trans)HY(la)HY(tion)YH( units: module inter)HY(face)YH(
  parti)HY(tion)YH( and module imple)HY(men)HY(ta)HY(tion)YH( parti)HY(tion)YH(. While parti)HY(tions)YH( are
  supported, they are not covered in this intro)HY(duc)HY(tion)YH(. A link to a complete
  example that uses both types of parti)HY(tions)YH( will be given in the next
  section.)EP(
  )BR(

  )0 P(From the producer's perspec)HY(tive)YH(, a module is a collec)HY(tion)YH( of module
  trans)HY(la)HY(tion)YH( units: one inter)HY(face)YH( unit and zero or more imple)HY(men)HY(ta)HY(tion)YH( units.
  A simple module may consist of just the inter)HY(face)YH( unit that includes
  imple)HY(men)HY(ta)HY(tions)YH( of all its func)HY(tions)YH( \201not neces)HY(sar)HY(ily)YH( inline\202. A more
  complex module may span multi)HY(ple)YH( imple)HY(men)HY(ta)HY(tion)YH( units.)EP(

  )0 P(A trans)HY(la)HY(tion)YH( unit is a module inter)HY(face)YH( unit if it contains an
  )I(export)HY(ing)YH( module decla)HY(ra)HY(tion)YH()ES(:)EP(

  ) 1 20 PR(export module hello;)RP(

  )0 P(A trans)HY(la)HY(tion)YH( unit is a module imple)HY(men)HY(ta)HY(tion)YH( unit if it contains a
  )I(non-export)HY(ing)YH( module decla)HY(ra)HY(tion)YH()ES(:)EP(

  ) 1 13 PR(module hello;)RP(

  )0 P(While module inter)HY(face)YH( units may use the same file exten)HY(sion)YH( as normal
  source files, we recom)HY(mend)YH( that a differ)HY(ent)YH( exten)HY(sion)YH( be used to distin)HY(guish)YH(
  them as such, similar to header files. While the compiler vendors suggest
  various \201and predictably differ)HY(ent)YH(\202 exten)HY(sions)YH(, our recom)HY(men)HY(da)HY(tion)YH( is
  )SM(.mxx)ES( for the )SM(.hxx/.cxx)ES( source file naming and
  )SM(.mpp)ES( for )SM(.hpp/.cpp)ES(. And if you are using some
  other naming scheme, then perhaps now is a good oppor)HY(tu)HY(nity)YH( to switch to one
  of the above. Contin)HY(u)HY(ing)YH( using the source file exten)HY(sion)YH( for module
  imple)HY(men)HY(ta)HY(tion)YH( units appears reason)HY(able)YH( and that's what we recom)HY(mend)YH(.)EP(

  )0 P(A modular trans)HY(la)HY(tion)YH( unit \201that is, either module inter)HY(face)YH( or
  imple)HY(men)HY(ta)HY(tion)YH(\202 that does not start with one of the above module
  decla)HY(ra)HY(tions)YH( must then start with the module intro)HY(ducer)YH(:)EP(

  ) 5 20 PR(module;

...

export module hello;)RP(

  )0 P(The frag)HY(ment)YH( from the module intro)HY(ducer)YH( and until the module decla)HY(ra)HY(tion)YH(
  is called the )I(global module frag)HY(ment)YH()ES(. Any name declared in the global
  module frag)HY(ment)YH( belongs to the )I(global module)ES(, an implied module
  contain)HY(ing)YH( "old" or non-modular decla)HY(ra)HY(tions)YH( that don't belong to any named
  module.)EP(

  )0 P(A module decla)HY(ra)HY(tion)YH( \201export)HY(ing)YH( or non-export)HY(ing)YH(\202 starts a )I(module
  purview)ES( that extends until the end of the module trans)HY(la)HY(tion)YH( unit. Any
  name declared in a module's purview )I(belongs)ES( to the said module. For
  example:)EP(

  ) 9 73 PR(module;                               // Start of global module fragment.

#include <cassert>                    // Not in purview.

export module hello;                  // Start of purview.

import std;                           // In purview.

void say_hello \201const std::string&\202;  // In purview.)RP(

  )0 P(A name that belongs to a module is )I(invis)HY(i)HY(ble)YH()ES( to the module's
  consumers unless it is )I(exported)ES(. A name can be declared exported only
  in a module inter)HY(face)YH( unit, only in the module's purview, and there are
  several syntac)HY(tic)YH( ways to accom)HY(plish)YH( this. We can start the decla)HY(ra)HY(tion)YH( with
  the )SM(export)ES( spec)HY(i)HY(fier)YH(, for example:)EP(

  ) 5 47 PR(export module hello;

export enum class volume {quiet, normal, loud};

export void say_hello \201const char*, volume\202;)RP(

  )0 P(Alter)HY(na)HY(tively)YH(, we can enclose one or more decla)HY(ra)HY(tions)YH( into an
  )I(exported group)ES(, for example:)EP(

  ) 8 42 PR(export module hello;

export
{
  enum class volume {quiet, normal, loud};

  void say_hello \201const char*, volume\202;
})RP(

  )0 P(Finally, if a names)HY(pace)YH( defi)HY(ni)HY(tion)YH( is declared exported, then every name
  in its body is exported, for example:)EP(

  ) 13 51 PR(export module hello;

export namespace hello
{
  enum class volume {quiet, normal, loud};

  void say_hello \201const char*, volume\202;
}

namespace hello
{
  void impl \201const char*, volume\202; // Not exported.
})RP(

  )0 P(Up until now we've only been talking about names belong)HY(ing)YH( to a module.
  What about the corre)HY(spond)HY(ing)YH( symbols? All the major C++ compil)HY(ers)YH( have
  chosen to imple)HY(ment)YH( the so-called strong owner)HY(ship)YH( model, where for both
  exported and non-exported names, the corre)HY(spond)HY(ing)YH( symbols are deco)HY(rated)YH(
  with the module name.  As a result, they cannot clash with symbols for
  iden)HY(ti)HY(cal)YH( names from other named modules or the global module.)EP(

  )0 P(What about the prepro)HY(ces)HY(sor)YH(? Modules do not export prepro)HY(ces)HY(sor)YH( macros,
  only C++ names. A macro defined in the module inter)HY(face)YH( unit cannot affect
  the module's consumers. And macros defined by the module's consumers cannot
  affect the module inter)HY(face)YH( they are import)HY(ing)YH(. In other words, module
  produc)HY(ers)YH( and consumers are isolated from each other where the prepro)HY(ces)HY(sor)YH(
  is concerned. For example, consider this module inter)HY(face)YH(:)EP(

  ) 6 36 PR(export module hello;

#ifndef SMALL
#define HELLO
export void say_hello \201const char*\202;
#endif)RP(

  )0 P(And its consumer:)EP(

  ) 8 35 PR(// module consumer
//
#define SMALL       // No effect.
import hello;

#ifdef HELLO        // Not defined.
...
#endif)RP(

  )0 P(This is not to say that the prepro)HY(ces)HY(sor)YH( cannot be used by either the
  module inter)HY(face)YH( or its consumer, it just that macros don't "leak" through
  the module inter)HY(face)YH(. One prac)HY(ti)HY(cal)YH( conse)HY(quence)YH( of this model is the
  insignif)HY(i)HY(cance)YH( of the impor)HY(ta)HY(tion)YH( order.)EP(

  )0 P(If a module imports another module in its purview, the imported module's
  names are not made auto)HY(mat)HY(i)HY(cally)YH( visible to the consumers of the import)HY(ing)YH(
  module. This is unlike headers and can be surpris)HY(ing)YH(. Consider this module
  inter)HY(face)YH( as an example:)EP(

  ) 5 53 PR(export module hello;

import std;

export std::string formal_hello \201const std::string&\202;)RP(

  )0 P(And its consumer:)EP(

  ) 7 41 PR(import hello;

int
main \201\202
{
  std::string s \201format_hello \201"World"\202\202;
})RP(

  )0 P(This example will result in a compile error and the diag)HY(nos)HY(tics)YH( may
  confus)HY(ingly)YH( indi)HY(cate)YH( that there is no member )SM(string)ES( in
  names)HY(pace)YH( )SM(std)ES(. But with the under)HY(stand)HY(ing)YH( of the differ)HY(ence)YH(
  between )SM(import)ES( and )SM(#include)ES( the reason should be
  clear: while the module inter)HY(face)YH( "sees" )SM(std::string)ES( \201because
  it imported its module\202, we \201the consumer\202 do not \201since we did not\202. So the
  fix is to explic)HY(itly)YH( import )SM(std)ES(:)EP(

  ) 8 41 PR(import std;
import hello;

int
main \201\202
{
  std::string s \201format_hello \201"World"\202\202;
})RP(

  )0 P(A module, however, can choose to re-export a module it imports. In this
  case, all the names from the imported module will also be visible to the
  import)HY(ing)YH( module's consumers. For example, with this change to the module
  inter)HY(face)YH( the first version of our consumer will compile without errors
  \201note that whether this is a good design choice is debat)HY(able)YH(, as discussed
  below\202:)EP(

  ) 5 53 PR(export module hello;

export import std;

export std::string formal_hello \201const std::string&\202;)RP(

  )0 P(One way to think of a re-export is )I(as if)ES( an import of a module
  also "injects" all the imports the said module re-exports, recur)HY(sively)YH(.
  That's essen)HY(tially)YH( how most compil)HY(ers)YH( imple)HY(ment)YH( it.)EP(

  )0 P(Module re-export is the mech)HY(a)HY(nism)YH( for assem)HY(bling)YH( bigger modules out of
  submod)HY(ules)YH(. As an example, let's say we had the )SM(hello.core)ES(,
  )SM(hello.basic)ES(, and )SM(hello.extra)ES( modules. To make life
  easier for users that want to import all of them we can create the
  )SM(hello)ES( module that re-exports the three:)EP(

  ) 8 21 PR(export module hello;

export
{
  import hello.core;
  import hello.basic;
  import hello.extra;
})RP(

  )0 P(Besides start)HY(ing)YH( a module purview, a non-export)HY(ing)YH( module decla)HY(ra)HY(tion)YH( in
  the imple)HY(men)HY(ta)HY(tion)YH( unit makes \201non-inter)HY(nal)YH( linkage\202 names declared or made
  visible \201via import\202 in the module purview of an inter)HY(face)YH( unit also visible
  in the module purview of the imple)HY(men)HY(ta)HY(tion)YH( unit. In this sense a
  non-export)HY(ing)YH( module decla)HY(ra)HY(tion)YH( acts as a special )SM(import)ES(. The
  follow)HY(ing)YH( example illus)HY(trates)YH( this point:)EP(

  ) 13 67 PR(module;

import hello.impl;          // Not visible \201exports impl\201\202\202.

#include <string.h>         // Not visible \201declares strlen\201\202\202.

export module hello.extra;  // Start of module purview \201interface\202.

import hello.core;          // Visible \201exports core\201\202\202.

void extra \201\202;              // Visible.

static void extra2 \201\202;      // Not visible \201internal linkage\202.)RP(

  )0 P(And this is the imple)HY(men)HY(ta)HY(tion)YH( unit:)EP(

  ) 11 72 PR(module hello.extra;         // Start of module purview \201implementation\202.

void
f \201\202
{
  impl \201\202;      // Error.
  strlen \201""\202;  // Error.
  core \201\202;      // Ok.
  extra \201\202;     // Ok.
  extra2 \201\202;    // Error.
})RP(

  )0 P(In partic)HY(u)HY(lar)YH(, this means that while the rela)HY(tive)YH( order of imports is not
  signif)HY(i)HY(cant)YH(, the place)HY(ment)YH( of imports in the module inter)HY(face)YH( unit rela)HY(tive)YH(
  to the module decla)HY(ra)HY(tion)YH( can be.)EP(

  )0 P(The final perspec)HY(tive)YH( that we consider is that of the build system. From
  its point of view the central piece of the module infras)HY(truc)HY(ture)YH( is the
  )I(binary module inter)HY(face)YH()ES( or BMI: a binary file that is produced by
  compil)HY(ing)YH( the module inter)HY(face)YH( unit and that is required when compil)HY(ing)YH( any
  trans)HY(la)HY(tion)YH( unit that imports this module as well as the module's
  imple)HY(men)HY(ta)HY(tion)YH( units.)EP(

  )0 P(Then, in a nutshell, the main func)HY(tion)HY(al)HY(ity)YH( of a build system when it
  comes to modules support is figur)HY(ing)YH( out the order in which all the
  trans)HY(la)HY(tion)YH( units should be compiled and making sure that every compi)HY(la)HY(tion)YH(
  process is able to find the binary module inter)HY(faces)YH( it needs.)EP(

  )0 P(Predictably, the details are more complex. Compil)HY(ing)YH( a module inter)HY(face)YH(
  unit produces two outputs: the binary module inter)HY(face)YH( and the object file.
  The latter contains object code for non-inline func)HY(tions)YH(, global vari)HY(ables)YH(,
  etc., that the inter)HY(face)YH( unit may define. This object file has to be linked
  when produc)HY(ing)YH( any binary \201program or library\202 that uses this module.)EP(

  )0 P(Also, all the compil)HY(ers)YH( currently imple)HY(ment)YH( module re-export as a shallow
  refer)HY(ence)YH( to the re-exported module name which means that their binary
  inter)HY(faces)YH( must be discov)HY(er)HY(able)YH( as well, recur)HY(sively)YH(. In fact, currently,
  all the imports are handled like this, though a differ)HY(ent)YH( imple)HY(men)HY(ta)HY(tion)YH( is
  at least plau)HY(si)HY(ble)YH(, if unlikely.)EP(

  )0 P(While the details vary between compil)HY(ers)YH(, the contents of the binary
  module inter)HY(face)YH( can range from a stream of prepro)HY(cessed)YH( tokens to some)HY(thing)YH(
  fairly close to object code. As a result, binary inter)HY(faces)YH( can be sensi)HY(tive)YH(
  to the compiler options and if the options used to produce the binary
  inter)HY(face)YH( \201for example, when build)HY(ing)YH( a library\202 are suffi)HY(ciently)YH( differ)HY(ent)YH(
  compared to the ones used when compil)HY(ing)YH( the module consumers, the binary
  inter)HY(face)YH( may be unus)HY(able)YH(. So while a build system should strive to reuse
  exist)HY(ing)YH( binary inter)HY(faces)YH(, it should also be prepared to compile its own
  versions "on the side".)EP(

  )0 P(This also suggests that binary module inter)HY(faces)YH( are not a distri)HY(bu)HY(tion)YH(
  mech)HY(a)HY(nism)YH( and should prob)HY(a)HY(bly)YH( not be installed. Instead, we should install
  and distribute module inter)HY(face)YH( sources and build systems should be prepared
  to compile them, again, on the side.)EP(

  )0 3 199 H(16.3.2)WB 410 Sn()WB 201 Sn( Build)HY(ing)YH( Modules)EH(

  )0 P(Compiler support for C++ modules is still exper)HY(i)HY(men)HY(tal)YH(, incom)HY(plete)YH(, and
  often buggy. Also, in )SM(build2)ES(, the pres)HY(ence)YH( of modules changes
  the C++ compi)HY(la)HY(tion)YH( model in ways that would intro)HY(duce)YH( unnec)HY(es)HY(sary)YH( over)HY(heads)YH(
  for headers-only code. As a result, a project must explic)HY(itly)YH( enable modules
  using the )SM(cxx.features.modules)ES( boolean vari)HY(able)YH(. This is what
  the rele)HY(vant)YH( )SM(root.build)ES( frag)HY(ment)YH( could look like for a
  modu)HY(lar)HY(ized)YH( project:)EP(

  ) 7 27 PR(cxx.std = latest
cxx.features.modules = true

using cxx

mxx{*}: extension = mxx
cxx{*}: extension = cxx)RP(

  )BR(
  )0 P(Note that you must explic)HY(itly)YH( enable modules in your project even if you
  are only import)HY(ing)YH( other modules, includ)HY(ing)YH( stan)HY(dard)YH( library modules
  \201)SM(std)ES( or )SM(std.compat)ES(\202.)EP(
  )BR(

  )0 P(To support C++ modules the )SM(cxx)ES( build system module defines
  several addi)HY(tional)YH( target types. The )SM(mxx{})ES( target is a module
  inter)HY(face)YH( unit. As you can see from the above )SM(root.build)ES(
  frag)HY(ment)YH(, in this project we are using the )SM(.mxx)ES( exten)HY(sion)YH( for
  our module inter)HY(face)YH( files. While you can use the same exten)HY(sion)YH( as for
  )SM(cxx{})ES( \201source files\202, this is not recom)HY(mended)YH( since some
  func)HY(tion)HY(al)HY(ity)YH(, such as wild)HY(card)YH( patterns, will become unus)HY(able)YH(.)EP(

  )0 P(The )SM(bmi{})ES( group and its )SM(bmie{})ES(,
  )SM(bmia{})ES(, and )SM(bmis{})ES( members are used to repre)HY(sent)YH(
  binary module inter)HY(faces)YH( targets. We normally do not need to mention them
  explic)HY(itly)YH( in our )SM(build)HY(files)YH()ES( except, perhaps, to specify
  addi)HY(tional)YH(, module inter)HY(face)YH(-specific compile options.)EP(

  )0 P(To build a modu)HY(lar)HY(ized)YH( executable or library we simply list the module
  inter)HY(faces)YH( as its prereq)HY(ui)HY(sites)YH(, just as we do for source files. As an
  example, let's build the )SM(hello)ES( program that we have started in
  the intro)HY(duc)HY(tion)YH( \201you can find the complete project in the )R6 2 A()SM(cxx20-modules-exam)HY(ples)YH()ES()EA(
  repos)HY(i)HY(tory)YH( under )SM(hello-module)ES(\202. Specif)HY(i)HY(cally)YH(, we assume our
  project contains the follow)HY(ing)YH( files:)EP(

  ) 10 48 PR(// file: hello.mxx \201module interface\202

export module hello;

import std;

export namespace hello
{
  void say_hello \201const std::string_view& name\202;
})RP(

  ) 11 52 PR(// file: hello.cxx \201module implementation\202

module hello;

namespace hello
{
  void say_hello \201const std::string_view& n\202
  {
    std::cout << "Hello, " << n << '!' << std::endl;
  }
})RP(

  ) 9 29 PR(// file: main.cxx

import hello;

int
main \201\202
{
  hello::say_hello \201"World"\202;
})RP(

  )0 P(To build a )SM(hello)ES( executable from these files we can write
  the follow)HY(ing)YH( )SM(build)HY(file)YH()ES(:)EP(

  ) 1 38 PR(exe{hello}: cxx{main} {mxx cxx}{hello})RP(

  )0 P(Or, if you prefer to use wild)HY(card)YH( patterns:)EP(

  ) 1 24 PR(exe{hello}: {mxx cxx}{*})RP(

  )BR(
  )0 P(Module parti)HY(tions)YH(, both inter)HY(face)YH( and imple)HY(men)HY(ta)HY(tion)YH(, are compiled to
  BMIs and as a result must be listed as )SM(mxx{})ES( prereq)HY(ui)HY(sites)YH(. See
  )SM(hello-parti)HY(tion)YH()ES( in the )R6 2 A()SM(cxx20-modules-exam)HY(ples)YH()ES()EA(
  repos)HY(i)HY(tory)YH( for a complete example.)EP(
  )BR(

  )0 P(Alter)HY(na)HY(tively)YH(, we can place the module into a library and then link the
  library to the executable \201see )SM(hello-library-module)ES( in the )R6 2 A()SM(cxx20-modules-exam)HY(ples)YH()ES()EA(
  repos)HY(i)HY(tory)YH(\202:)EP(

  ) 2 32 PR(exe{hello}: cxx{main} lib{hello}
lib{hello}: {mxx cxx}{hello})RP(

  )0 P(Note that a library consist)HY(ing)YH( of only module inter)HY(face)YH( units is by
  default always binful \201see )0 13 1 A(Library Expor)HY(ta)HY(tion)YH( and
  Version)HY(ing)YH()13 0 TN TL()Ec /AF f D( for back)HY(ground)YH(\202 since compil)HY(ing)YH( a module inter)HY(face)YH( always
  results in an object file, even if the module inter)HY(face)YH( does not contain any
  non-inline/template func)HY(tions)YH( or global vari)HY(ables)YH(. However, you can
  explic)HY(itly)YH( request for such a library to be treated as binless:)EP(

  ) 4 22 PR(lib{hello}: mxx{hello}
{
  bin.binless = true
})RP(

  )BR(
  )0 P(Note that if such a binless library has non-inline/template func)HY(tions)YH( or
  global vari)HY(ables)YH(, then whether it can used in all situ)HY(a)HY(tions)YH( without causing
  dupli)HY(cate)YH( symbols is plat)HY(form)YH(-depen)HY(dent)YH(.)EP(
  )BR(

  )0 P(As you might have surmised from this example, the modules support in
  )SM(build2)ES( auto)HY(mat)HY(i)HY(cally)YH( resolves imports to module inter)HY(face)YH( units
  that are spec)HY(i)HY(fied)YH( either as direct prereq)HY(ui)HY(sites)YH( or as prereq)HY(ui)HY(sites)YH( of
  library prereq)HY(ui)HY(sites)YH(.)EP(

  )0 P(To perform this reso)HY(lu)HY(tion)YH( without a signif)HY(i)HY(cant)YH( over)HY(head)YH(, the
  imple)HY(men)HY(ta)HY(tion)YH( delays the extrac)HY(tion)YH( of the actual module name from module
  inter)HY(face)YH( units \201since not all avail)HY(able)YH( module inter)HY(faces)YH( are neces)HY(sar)HY(ily)YH(
  imported by all the trans)HY(la)HY(tion)YH( units\202. Instead, the imple)HY(men)HY(ta)HY(tion)YH( tries to
  guess which inter)HY(face)YH( unit imple)HY(ments)YH( each module being imported based on
  the inter)HY(face)YH( file path. Or, more precisely, a two-step reso)HY(lu)HY(tion)YH( process
  is performed: first a best match between the desired module name and the
  file path is sought and then the actual module name is extracted and the
  correct)HY(ness)YH( of the initial guess is veri)HY(fied)YH(.)EP(

  )0 P(The prac)HY(ti)HY(cal)YH( impli)HY(ca)HY(tion)YH( of this imple)HY(men)HY(ta)HY(tion)YH( detail is that our
  module inter)HY(face)YH( files must embed a portion of a module name, or, more
  precisely, a suffi)HY(cient)YH( amount of "module name tail" to unam)HY(bigu)HY(ously)YH(
  resolve all the modules used in a project. Note that this guess)HY(work)YH( is only
  performed for direct module inter)HY(face)YH( prereq)HY(ui)HY(sites)YH(; for those that come
  from libraries the module names are known and are there)HY(fore)YH( matched exactly.
  And the guesses are always veri)HY(fied)YH( before the actual compi)HY(la)HY(tion)YH(, so
  misguesses cannot go unno)HY(ticed)YH(.)EP(

  )0 P(As an example, let's assume our )SM(hello)ES( project had two
  modules: )SM(hello.core)ES( and )SM(hello.extra)ES(. While we
  could call our inter)HY(face)YH( files )SM(hello.core.mxx)ES( and
  )SM(hello.extra.mxx)ES(, respec)HY(tively)YH(, this doesn't look partic)HY(u)HY(larly)YH(
  good and may be contrary to the file naming scheme used in our project. To
  resolve this issue the match of module names to file names is made "fuzzy":
  it is case-insen)HY(si)HY(tive)YH(, it treats all sepa)HY(ra)HY(tors)YH( \201dots, dashes, under)HY(scores)YH(,
  etc\202 as equal, and it treats a case change as an imag)HY(i)HY(nary)YH( sepa)HY(ra)HY(tor)YH(. As a
  result, the follow)HY(ing)YH( naming schemes will all match the
  )SM(hello.core)ES( module name:)EP(

  ) 4 14 PR(hello-core.mxx
hello_core.mxx
HelloCore.mxx
hello/core.mxx)RP(

  )0 P(We also don't have to embed the full module name. In our case, for
  example, it would be most natural to call the files )SM(core.mxx)ES(
  and )SM(extra.mxx)ES( since they are already in the project direc)HY(tory)YH(
  called )SM(hello/)ES(. This will work since our module names can still
  be guessed correctly and unam)HY(bigu)HY(ously)YH(.)EP(

  )0 P(If a guess turns out to be incor)HY(rect)YH(, the imple)HY(men)HY(ta)HY(tion)YH( issues
  diag)HY(nos)HY(tics)YH( and exits with an error before attempt)HY(ing)YH( to build anything. To
  resolve this situ)HY(a)HY(tion)YH( we can either adjust the inter)HY(face)YH( file names or we
  can specify the module name explic)HY(itly)YH( with the )SM(cxx.module_name)ES(
  vari)HY(able)YH(. The latter approach can be used with inter)HY(face)YH( file names that
  have nothing in common with module names, for example:)EP(

  ) 1 39 PR(mxx{foobar}@./: cxx.module_name = hello)RP(

  )0 P(Note also that the stan)HY(dard)YH( library modules \201)SM(std)ES( and
  )SM(std.compat)ES(\202 are treated specially and are resolved in a
  compiler-specific manner.)EP(

  )0 P(When C++ modules are enabled and avail)HY(able)YH(, the build system makes sure
  the )SM(__cpp_modules)ES( feature test macro is defined. However, if
  the compiler version being used does not claim complete modules support, its
  value may not be )SM(201907)ES(.)EP(

  )0 3 200 H(16.3.3)WB 411 Sn()WB 202 Sn( Module Symbols Export)HY(ing)YH()EH(

  )0 P(When build)HY(ing)YH( a shared library, some plat)HY(forms)YH( \201notably Windows\202 require
  that we explic)HY(itly)YH( export symbols that must be acces)HY(si)HY(ble)YH( to the library
  consumers. If you don't need to support such plat)HY(forms)YH(, you can thank your
  lucky stars and skip this section.)EP(

  )0 P(When using headers, the tradi)HY(tional)YH( way of achiev)HY(ing)YH( this is via an
  "export macro" that is used to mark exported APIs, for example:)EP(

  ) 1 47 PR(LIBHELLO_EXPORT void say_hello \201const string&\202;)RP(

  )0 P(This macro is then appro)HY(pri)HY(ately)YH( defined \201often in a sepa)HY(rate)YH( "export
  header"\202 to export symbols when build)HY(ing)YH( the shared library and to import
  them when build)HY(ing)YH( the library's consumers \201and to nothing when either
  build)HY(ing)YH( or consum)HY(ing)YH( the static library\202.)EP(

  )0 P(The intro)HY(duc)HY(tion)YH( of modules changes this in a number of ways, at least as
  imple)HY(mented)YH( by MSVC and Clang. While we still have to explic)HY(itly)YH( mark
  exported symbols in our module inter)HY(face)YH( unit, there is no need \201and, in
  fact, no way\202 to do the same when said module is imported. Instead, the
  compiler auto)HY(mat)HY(i)HY(cally)YH( treats all such explic)HY(itly)YH( exported symbols \201note:
  symbols, not names\202 as imported.)EP(

  )BR(
  )0 P(While the auto)HY(matic)YH( import)HY(ing)YH( may look like the same mech)HY(a)HY(nism)YH( as what's
  used to support )0 181 1 A(Auto)HY(matic)YH( DLL Symbol
  Export)HY(ing)YH()181 0 TN TL()Ec /AF f D(, it appears not to be since it also works for global
  vari)HY(ables)YH(, not only func)HY(tions)YH(. However, report)HY(edly)YH(, it does appear to incur
  the same addi)HY(tional)YH( over)HY(head)YH( as auto-import)HY(ing)YH(, at least for func)HY(tions)YH(.)EP(
  )BR(

  )0 P(One notable aspect of this new model is the local)HY(ity)YH( of the export macro:
  it is only defined when compil)HY(ing)YH( the module inter)HY(face)YH( unit and is not
  visible to the consumers of the module. This is unlike headers where the
  macro has to have a unique per-library name \201that )SM(LIBHELLO_)ES(
  prefix\202 because a header from one library can be included while build)HY(ing)YH(
  another library.)EP(

  )0 P(We can continue using the same export macro and header with modules and,
  in fact, that's the recom)HY(mended)YH( approach if main)HY(tain)HY(ing)YH( the dual,
  header/module arrange)HY(ment)YH( for back)HY(wards)YH( compat)HY(i)HY(bil)HY(ity)YH(. However, for
  modules-only code)HY(bases)YH(, we have an oppor)HY(tu)HY(nity)YH( to improve the situ)HY(a)HY(tion)YH( in
  two ways: we can use a single, keyword-like macro instead of a
  library-specific one and we can make the build system manage it for us thus
  getting rid of the export header.)EP(

  )0 P(To enable this func)HY(tion)HY(al)HY(ity)YH( in )SM(build2)ES( we set the
  )SM(cxx.features.symex)HY(port)YH()ES( boolean vari)HY(able)YH( to )SM(true)ES(
  before loading the )SM(cxx)ES( module. For example:)EP(

  ) 7 29 PR(cxx.std = latest
cxx.features.modules = true
cxx.features.symexport = true

using cxx

...)RP(

  )0 P(Once enabled, )SM(build2)ES( auto)HY(mat)HY(i)HY(cally)YH( defines the
  )SM(__symex)HY(port)YH()ES( macro to the appro)HY(pri)HY(ate)YH( value depend)HY(ing)YH( on the
  plat)HY(form)YH( and the type of library being built. As library authors, all we
  have to do is use it in appro)HY(pri)HY(ate)YH( places in our module inter)HY(face)YH( units,
  for example:)EP(

  ) 5 55 PR(export module hello;

import std;

export __symexport void say_hello \201const std::string&\202;)RP(

  )BR(
  )0 P(You may be wonder)HY(ing)YH( why can't a module export auto)HY(mat)HY(i)HY(cally)YH( mean a
  symbol export? While you will normally want to export symbols of all your
  module-exported names, you may also need to do so for some
  non-module-exported ones. For example:)EP(

  ) 8 35 PR(export module foo;

__symexport void f_impl \201\202;

export __symexport inline void f \201\202
{
  f_impl \201\202;
})RP(

  )0 P(Further)HY(more)YH(, symbol export)HY(ing)YH( is a murky area with many limi)HY(ta)HY(tions)YH( and
  pitfalls \201such as auto-export)HY(ing)YH( of base classes\202. As a result, it would not
  be unrea)HY(son)HY(able)YH( to expect such an auto)HY(matic)YH( module export)HY(ing)YH( to only further
  muddy the matter.)EP(
  )BR(

  )0 3 201 H(16.3.4)WB 412 Sn()WB 203 Sn( Modules Instal)HY(la)HY(tion)YH()EH(

  )0 P(As discussed in the intro)HY(duc)HY(tion)YH(, binary module inter)HY(faces)YH( are not a
  distri)HY(bu)HY(tion)YH( mech)HY(a)HY(nism)YH( and installing module inter)HY(face)YH( sources appears to be
  the preferred approach.)EP(

  )0 P(Module inter)HY(face)YH( units are by default installed in the same loca)HY(tion)YH( as
  headers \201for example, )SM(/usr/include)ES(\202. However, instead of
  relying on a header-like search mech)HY(a)HY(nism)YH( \201)SM(-I)ES( paths, etc.\202, an
  explicit list of exported modules is provided for each library in its
  )SM(.pc)ES( \201)SM(pkg-config)ES(\202 file.)EP(

  )0 P(Specif)HY(i)HY(cally)YH(, the library's )SM(.pc)ES( file contains the
  )SM(cxx.modules)ES( vari)HY(able)YH( that lists all the exported C++ modules in
  the )SM(<name>=<path>)ES( form with )SM(<name>)ES( being
  the module's C++ name and )SM(<path>)ES( \235 the module
  inter)HY(face)YH( file's abso)HY(lute)YH( path. For example:)EP(

  ) 6 93 PR(Name: libhello
Version: 1.0.0
Cflags:
Libs: -L/usr/lib -lhello

cxx.modules = hello.core=/usr/include/hello/core.mxx hello.extra=/usr/include/hello/extra.mxx)RP(

  )BR(
  )0 P(The )SM(:)ES( char)HY(ac)HY(ter)YH( in a module parti)HY(tion)YH( name is encoded as
  )SM(..)ES(. For example, for )SM(hello:core)ES( we would have:)EP(

  ) 1 34 PR(cxx.modules = hello..core=/usr/...)RP(
  )BR(

  )0 P(Addi)HY(tional)YH( module prop)HY(er)HY(ties)YH( are spec)HY(i)HY(fied)YH( with vari)HY(ables)YH( in the
  )SM(cxx.module_<prop)HY(erty)YH(>.<name>)ES( form, for example:)EP(

  ) 2 40 PR(cxx.module_symexport.hello.core = true
cxx.module_preprocessed.hello.core = all)RP(

  )0 P(Currently, two prop)HY(er)HY(ties)YH( are defined. The )SM(symex)HY(port)YH()ES(
  prop)HY(erty)YH( with the boolean value signals whether the module uses the
  )SM(__symex)HY(port)YH()ES( support discussed above.)EP(

  )0 P(The )SM(prepro)HY(cessed)YH()ES( prop)HY(erty)YH( indi)HY(cates)YH( the degree of
  prepro)HY(cess)HY(ing)YH( the module unit requires and is used to opti)HY(mize)YH( module
  compi)HY(la)HY(tion)YH(. Valid values are )SM(none)ES( \201not prepro)HY(cessed)YH(\202,
  )SM(includes)ES( \201no )SM(#include)ES( direc)HY(tives)YH( in the source\202,
  )SM(modules)ES( \201as above plus no module decla)HY(ra)HY(tions)YH( depend on the
  prepro)HY(ces)HY(sor)YH(, for example, )SM(#ifdef)ES(, etc.\202, and )SM(all)ES(
  \201the source is fully prepro)HY(cessed)YH(\202. Note that for )SM(all)ES( the
  source may still contain comments and line contin)HY(u)HY(a)HY(tions)YH(.)EP(

  )0 3 202 H(16.3.5)WB 413 Sn()WB 204 Sn( Modules Design Guide)HY(lines)YH()EH(

  )0 P(Modules are a phys)HY(i)HY(cal)YH( design mech)HY(a)HY(nism)YH( for struc)HY(tur)HY(ing)YH( and orga)HY(niz)HY(ing)YH(
  our code. Their explicit expor)HY(ta)HY(tion)YH( seman)HY(tics)YH( combined with the way they
  are built make many aspects of creat)HY(ing)YH( and consum)HY(ing)YH( modules signif)HY(i)HY(cantly)YH(
  differ)HY(ent)YH( compared to headers. This section provides basic guide)HY(lines)YH( for
  design)HY(ing)YH( modules. We start with the overall consid)HY(er)HY(a)HY(tions)YH( such as module
  gran)HY(u)HY(lar)HY(ity)YH( and parti)HY(tion)HY(ing)YH( into trans)HY(la)HY(tion)YH( units then continue with the
  struc)HY(ture)YH( of typical module inter)HY(face)YH( and imple)HY(men)HY(ta)HY(tion)YH( units. The
  follow)HY(ing)YH( section discusses prac)HY(ti)HY(cal)YH( approaches to modu)HY(lar)HY(iz)HY(ing)YH( exist)HY(ing)YH(
  code.)EP(

  )0 P(Unlike headers, the cost of import)HY(ing)YH( modules should be negli)HY(gi)HY(ble)YH(. As a
  result, it may be tempt)HY(ing)YH( to create "mega-modules", for example, one per
  library. After all, this is how the stan)HY(dard)YH( library is modu)HY(lar)HY(ized)YH( with its
  )SM(std)ES( and )SM(std.compat)ES( modules.)EP(

  )0 P(There is, however, a signif)HY(i)HY(cant)YH( draw)HY(back)YH( to this choice: every time we
  make a change, all consumers of such a mega-module will have to be
  recom)HY(piled)YH(, whether the change affects them or not. And the bigger the
  module the higher the chance that any given change does not \201seman)HY(ti)HY(cally)YH(\202
  affect a large portion of the module's consumers. Note also that this is not
  an issue for the stan)HY(dard)YH( library modules since they are not expected to
  change often.)EP(

  )0 P(Another, more subtle, issue with mega-modules \201which does affect the
  stan)HY(dard)YH( library\202 is the inabil)HY(ity)YH( to re-export only specific inter)HY(faces)YH(, as
  will be discussed below.)EP(

  )0 P(The other extreme in choos)HY(ing)YH( module gran)HY(u)HY(lar)HY(ity)YH( is a large number of
  "mini-modules". Their main draw)HY(back)YH( is the tedious)HY(ness)YH( of impor)HY(ta)HY(tion)YH( by the
  consumers.)EP(

  )0 P(The sensi)HY(ble)YH( approach is then to create modules of concep)HY(tu)HY(ally)YH(-related
  and commonly-used enti)HY(ties)YH( possi)HY(bly)YH( comple)HY(mented)YH( with aggre)HY(gate)YH( modules for
  ease of impor)HY(ta)HY(tion)YH(. This also happens to be gener)HY(ally)YH( good design.)EP(

  )0 P(As an example, let's consider a JSON library that provides support for
  both parsing and seri)HY(al)HY(iza)HY(tion)YH(. Since it is common for appli)HY(ca)HY(tions)YH( to only
  use one of the func)HY(tion)HY(al)HY(i)HY(ties)YH(, it makes sense to provide the
  )SM(json.parser)ES( and )SM(json.seri)HY(al)HY(izer)YH()ES( modules. Depend)HY(ing)YH(
  on the repre)HY(sen)HY(ta)HY(tion)YH( of JSON we use in our library, it will most likely
  have some shared types so it prob)HY(a)HY(bly)YH( makes sense to have the
  )SM(json.types)ES( module that is re-exported by the parser and
  seri)HY(al)HY(izer)YH( modules. While it is not too tedious to import both
  )SM(json.parser)ES( and )SM(json.seri)HY(al)HY(izer)YH()ES( if both a needed,
  for conve)HY(nience)YH( we could also provide the )SM(json)ES( module that
  re-exports the two. Some)HY(thing)YH( along these lines:)EP(

  ) 8 25 PR(// types.mxx

export module json.types;

export class json
{
 ...
};)RP(

  ) 7 26 PR(// parser.mxx

export module json.parser;

export import json.types;

export json parse \201...\202;)RP(

  ) 7 35 PR(// serializer.mxx

export module json.serializer;

export import json.types;

export ... serialize \201const json&\202;)RP(

  ) 7 30 PR(// json.mxx

export module json;

export import json.types;
export import json.parser;
export import json.serializer;)RP(

  )0 P(Once we are past select)HY(ing)YH( an appro)HY(pri)HY(ate)YH( gran)HY(u)HY(lar)HY(ity)YH( for our modules,
  the next ques)HY(tion)YH( is how to parti)HY(tion)YH( them into trans)HY(la)HY(tion)YH( units. A module
  can consist of just the inter)HY(face)YH( unit and, as discussed above, such a unit
  can contain anything an imple)HY(men)HY(ta)HY(tion)YH( unit can, includ)HY(ing)YH( non-inline
  func)HY(tion)YH( defi)HY(ni)HY(tions)YH(. Some may then view this as an oppor)HY(tu)HY(nity)YH( to get rid
  of the header/source sepa)HY(ra)HY(tion)YH( and have every)HY(thing)YH( in a single file.)EP(

  )0 P(There are a number of draw)HY(backs)YH( with this approach: Every time we change
  anything in the module inter)HY(face)YH( unit, all its consumers have to be
  recom)HY(piled)YH(. If we keep every)HY(thing)YH( in a single file, then every time we
  change the imple)HY(men)HY(ta)HY(tion)YH( we trigger recom)HY(pi)HY(la)HY(tions)YH( that would have been
  avoided had the imple)HY(men)HY(ta)HY(tion)YH( been factored out into a sepa)HY(rate)YH( unit. Note
  that a build system in coop)HY(er)HY(a)HY(tion)YH( with the compiler could theo)HY(ret)HY(i)HY(cally)YH(
  avoid such unnec)HY(es)HY(sary)YH( recom)HY(pi)HY(la)HY(tions)YH( in certain cases: if the compiler
  produces iden)HY(ti)HY(cal)YH( binary inter)HY(face)YH( files when the module inter)HY(face)YH( is
  unchanged, then the build system could detect this and skip recom)HY(pil)HY(ing)YH( the
  module's consumers.)EP(

  )0 P(A related issue with single-file modules is the reduc)HY(tion)YH( in the build
  paral)HY(leliza)HY(tion)YH( oppor)HY(tu)HY(ni)HY(ties)YH(. If the imple)HY(men)HY(ta)HY(tion)YH( is part of the
  inter)HY(face)YH( unit, then the build system cannot start compil)HY(ing)YH( the module's
  consumers until both the inter)HY(face)YH( and the imple)HY(men)HY(ta)HY(tion)YH( are compiled. On
  the other hand, had the imple)HY(men)HY(ta)HY(tion)YH( been split into a sepa)HY(rate)YH( file, the
  build system could start compil)HY(ing)YH( the module's consumers \201as well as the
  imple)HY(men)HY(ta)HY(tion)YH( unit\202 as soon as the module inter)HY(face)YH( is compiled.)EP(

  )0 P(Another issues with combin)HY(ing)YH( the inter)HY(face)YH( with the imple)HY(men)HY(ta)HY(tion)YH( is
  the read)HY(abil)HY(ity)YH( of the inter)HY(face)YH( which could be signif)HY(i)HY(cantly)YH( reduced if
  littered with imple)HY(men)HY(ta)HY(tion)YH( details. We could keep the inter)HY(face)YH( sepa)HY(rate)YH(
  by moving the imple)HY(men)HY(ta)HY(tion)YH( to the bottom of the inter)HY(face)YH( file but then we
  might as well move it into a sepa)HY(rate)YH( file and avoid the unnec)HY(es)HY(sary)YH(
  recom)HY(pi)HY(la)HY(tions)YH( or paral)HY(leliza)HY(tion)YH( issues.)EP(

  )0 P(The sensi)HY(ble)YH( guide)HY(line)YH( is then to have a sepa)HY(rate)YH( module imple)HY(men)HY(ta)HY(tion)YH(
  unit except perhaps for modules with a simple imple)HY(men)HY(ta)HY(tion)YH( that is mostly
  inline/template. Note that more complex modules may have several
  imple)HY(men)HY(ta)HY(tion)YH( units, however, based on our gran)HY(u)HY(lar)HY(ity)YH( guide)HY(line)YH(, those
  should be rare.)EP(

  )0 P(Once we start writing our first real module the imme)HY(di)HY(ate)YH( ques)HY(tion)YH( that
  normally comes up is where to put )SM(#include)ES( direc)HY(tives)YH( and
  )SM(import)ES( decla)HY(ra)HY(tions)YH( and in what order. To recap, a module unit,
  both inter)HY(face)YH( and imple)HY(men)HY(ta)HY(tion)YH(, is split into two parts: before the
  module decla)HY(ra)HY(tion)YH(, called the global module frag)HY(ment)YH(, which obeys the usual
  or "old" trans)HY(la)HY(tion)YH( unit rules and after the module decla)HY(ra)HY(tion)YH( which is
  the module purview. Inside the module purview all decla)HY(ra)HY(tions)YH( have their
  symbols invis)HY(i)HY(ble)YH( to any other module \201includ)HY(ing)YH( the global module\202. With
  this under)HY(stand)HY(ing)YH(, consider the follow)HY(ing)YH( module inter)HY(face)YH(:)EP(

  ) 3 20 PR(export module hello;

#include <string>)RP(

  )0 P(Do you see the problem? We have included )SM(<string>)ES( in the
  module purview which means all its names \201as well as all the names in any
  headers it might include, recur)HY(sively)YH(\202 are now declared as having the
  )SM(hello)ES( module linkage. The result of doing this can range from
  silent code blot to strange-looking unre)HY(solved)YH( symbols.)EP(

  )0 P(The guide)HY(line)YH( this leads to should be clear: includ)HY(ing)YH( a header in the
  module purview is almost always a bad idea. There are, however, a few types
  of headers that may make sense to include in the module purview. The first
  are headers that only define prepro)HY(ces)HY(sor)YH( macros, for example, config)HY(u)HY(ra)HY(tion)YH(
  or export headers. There are also cases where we do want the included
  decla)HY(ra)HY(tions)YH( to end up in the module purview. The most common example is
  inline/template func)HY(tion)YH( imple)HY(men)HY(ta)HY(tions)YH( that have been factored out into
  sepa)HY(rate)YH( files for code orga)HY(ni)HY(za)HY(tion)YH( reasons. As an example, consider the
  follow)HY(ing)YH( module inter)HY(face)YH( that uses an export header \201which presum)HY(ably)YH( sets
  up symbols export)HY(ing)YH( macros\202 as well as an inline file:)EP(

  ) 14 30 PR(module;

#include <string>

export module hello;

#include <libhello/export.hxx>

export namespace hello
{
  ...
}

#include <libhello/hello.ixx>)RP(

  )0 P(A note on inline/template files: in header-based projects we could
  include addi)HY(tional)YH( headers in those files, for example, if the included
  decla)HY(ra)HY(tions)YH( are only needed in the imple)HY(men)HY(ta)HY(tion)YH(. For the reasons just
  discussed, this does not work with modules and we have to move all the
  includes into the inter)HY(face)YH( file, into the global module frag)HY(ment)YH(. On the
  other hand, with modules, it is safe to use names)HY(pace)YH(-level using-direc)HY(tives)YH(
  \201for example, )SM(using names)HY(pace)YH( std;)ES(\202 in inline/template files
  \201and, with care, even in the inter)HY(face)YH( file\202.)EP(

  )0 P(What about imports, where should we import other modules? Again, to
  recap, unlike a header inclu)HY(sion)YH(, an )SM(import)ES( decla)HY(ra)HY(tion)YH( only
  makes exported names visible without redeclar)HY(ing)YH( them. As result, in module
  imple)HY(men)HY(ta)HY(tion)YH( units, it doesn't really matter where we place imports, in
  the module purview or the global module frag)HY(ment)YH(. There are, however, two
  differ)HY(ences)YH( when it comes to module inter)HY(face)YH( units: only imports in the
  purview are visible to imple)HY(men)HY(ta)HY(tion)YH( units and we can only re-export an
  imported module from the purview.)EP(

  )0 P(The guide)HY(line)YH( is then for inter)HY(face)YH( units to import in the module purview
  unless there is a good reason not to make the import visible to the
  imple)HY(men)HY(ta)HY(tion)YH( units. And for imple)HY(men)HY(ta)HY(tion)YH( units to always import in the
  purview for simplic)HY(ity)YH(. For example:)EP(

  ) 16 30 PR(module;

#include <cassert>

export module hello;

import std;

#include <libhello/export.hxx>

export namespace hello
{
  ...
}

#include <libhello/hello.ixx>)RP(

  )0 P(By putting all these guide)HY(lines)YH( together we can then create a module
  inter)HY(face)YH( unit template:)EP(

  ) 15 62 PR(// Module interface unit.

module;                    // Start of global module fragment.

<header includes>

export module <name>;      // Start of module purview.

<module imports>

<special header includes>  // Configuration, export, etc.

<module interface>

<inline/template includes>)RP(

  )0 P(As well as the module imple)HY(men)HY(ta)HY(tion)YH( unit template:)EP(

  ) 11 62 PR(// Module implementation unit.

module;                    // Start of global module fragment.

<header includes>

module <name>;             // Start of module purview.

<extra module imports>     // Only additional to interface.

<module implementation>)RP(

  )0 P(Let's now discuss module naming. Module names are in a sepa)HY(rate)YH( "name
  plane" and do not collide with names)HY(pace)YH(, type, or func)HY(tion)YH( names. Also, as
  mentioned earlier, the stan)HY(dard)YH( does not assign a hier)HY(ar)HY(chi)HY(cal)YH( meaning to
  module names though it is custom)HY(ary)YH( to assume module )SM(hello.core)ES(
  is a submod)HY(ule)YH( of )SM(hello)ES( and, unless stated explic)HY(itly)YH(
  other)HY(wise)YH(, import)HY(ing)YH( the latter also imports the former.)EP(

  )0 P(It is impor)HY(tant)YH( to choose good names for public modules \201that is, modules
  pack)HY(aged)YH( into libraries and used by a wide range of consumers\202 since
  chang)HY(ing)YH( them later can be costly. We have more leeway with naming private
  modules \201that is, the ones used by programs or inter)HY(nal)YH( to libraries\202 though
  it's worth coming up with a consis)HY(tent)YH( naming scheme here as well.)EP(

  )0 P(The general guide)HY(line)YH( is to start names of public modules with the
  library's names)HY(pace)YH( name followed by a name describ)HY(ing)YH( the module's
  func)HY(tion)HY(al)HY(ity)YH(. In partic)HY(u)HY(lar)YH(, if a module is dedi)HY(cated)YH( to a single class
  \201or, more gener)HY(ally)YH(, has a single primary entity\202, then it makes sense to
  use that name as the module name's last compo)HY(nent)YH(.)EP(

  )0 P(As a concrete example, consider )SM(libbutl)ES( \201the
  )SM(build2)ES( utility library\202: All its compo)HY(nents)YH( are in the
  )SM(butl)ES( names)HY(pace)YH( so all its module names start with
  )SM(butl.)ES( One of its compo)HY(nents)YH( is the )SM(small_vector)ES(
  class template which resides in its own module called
  )SM(butl.small_vector)ES(. Another compo)HY(nent)YH( is a collec)HY(tion)YH( of string
  parsing util)HY(i)HY(ties)YH( that are grouped into the )SM(butl::string_parser)ES(
  names)HY(pace)YH( with the corre)HY(spond)HY(ing)YH( module called
  )SM(butl.string_parser)ES(.)EP(

  )0 P(When is it a good idea to re-export a module? The two straight)HY(for)HY(ward)YH(
  cases are when we are build)HY(ing)YH( an aggre)HY(gate)YH( module out of submod)HY(ules)YH(, for
  example, )SM(json)ES( out of )SM(json.parser)ES( and
  )SM(json.seri)HY(al)HY(izer)YH()ES(, or when one module extends or super)HY(sedes)YH(
  another, for example, as )SM(json.parser)ES( extends
  )SM(json.types)ES(. It is also clear that there is no need to re-export
  a module that we only use in the imple)HY(men)HY(ta)HY(tion)YH(. The case when we use a
  module in our inter)HY(face)YH( is, however, a lot less clear cut.)EP(

  )0 P(But before consid)HY(er)HY(ing)YH( the last case in more detail, let's under)HY(stand)YH( the
  issue with re-export. In other words, why not simply re-export any module we
  import in our inter)HY(face)YH(? In essence, re-export implic)HY(itly)YH( injects another
  module import anywhere our module is imported. If we re-export
  )SM(std)ES( then consumers of our module will also auto)HY(mat)HY(i)HY(cally)YH( "see"
  all the names exported by )SM(std)ES(. They can then start using names
  from )SM(std)ES( without explic)HY(itly)YH( import)HY(ing)YH( )SM(std)ES( and
  every)HY(thing)YH( will compile until one day they no longer need to import our
  module or we no longer need to import )SM(std)ES(. In a sense,
  re-export becomes part of our inter)HY(face)YH( and it is gener)HY(ally)YH( good design to
  keep inter)HY(faces)YH( minimal.)EP(

  )0 P(And so, at the outset, the guide)HY(line)YH( is then to only re-export the
  minimum neces)HY(sary)YH(.)EP(

  )0 P(Let's now discuss a few concrete exam)HY(ples)YH( to get a sense of when
  re-export might or might not be appro)HY(pri)HY(ate)YH(. Unfor)HY(tu)HY(nately)YH(, there does not
  seem to be a hard and fast rule and instead one has to rely on their good
  sense of design.)EP(

  )0 P(To start, let's consider a simple module that uses
  )SM(std::string)ES( in its inter)HY(face)YH(:)EP(

  ) 8 48 PR(export module hello;

import std;

export namespace hello
{
  std::string format_hello \201const std::string&\202;
})RP(

  )0 P(Should we re-export )SM(std)ES( in this case? Most likely not. If
  consumers of our module want to refer to )SM(std::string)ES(, then it
  is natural to expect them to explic)HY(itly)YH( import the neces)HY(sary)YH( module. In a
  sense, this is anal)HY(o)HY(gous)YH( to scoping: nobody expects to be able to use just
  )SM(string)ES( \201without )SM(std::)ES(\202 because of )SM(using
  names)HY(pace)YH( hello;)ES(.)EP(

  )0 P(So it seems that a mere usage of a name in an inter)HY(face)YH( does not
  gener)HY(ally)YH( warrant a re-export. The fact that a consumer may not even use
  this part of our inter)HY(face)YH( further supports this conclu)HY(sion)YH(.)EP(

  )0 P(Let's now consider a more inter)HY(est)HY(ing)YH( case \201inspired by real events\202:)EP(

  ) 9 53 PR(export module small_vector;

import std;

template <typename T, std::size_t N>
export class small_vector: public std::vector<T, ...>
{
  ...
};)RP(

  )0 P(Here we have the )SM(small_vector)ES( container imple)HY(mented)YH( in terms
  of )SM(std::vector)ES( by provid)HY(ing)YH( a custom allo)HY(ca)HY(tor)YH( and with most of
  the func)HY(tions)YH( derived as is. Consider now this inno)HY(cent)YH(-looking consumer
  code:)EP(

  ) 6 26 PR(import small_vector;

small_vector<int, 1> a, b;

if \201a == b\202 // Error.
  ...)RP(

  )0 P(We don't refer)HY(ence)YH( )SM(std::vector)ES( directly so presum)HY(ably)YH( we
  shouldn't need to import its module. However, the compar)HY(i)HY(son)YH( won't compile:
  our )SM(small_vector)ES( imple)HY(men)HY(ta)HY(tion)YH( re-uses the compar)HY(i)HY(son)YH(
  oper)HY(a)HY(tors)YH( provided by )SM(std::vector)ES( \201via implicit to-base
  conver)HY(sion)YH(\202 but they aren't visible.)EP(

  )0 P(There is a palpa)HY(ble)YH( differ)HY(ence)YH( between the two cases: the first merely
  uses )SM(std)ES( inter)HY(face)YH( while the second is )I(based on)ES( and, in
  a sense, )I(extends)ES( it which feels like a stronger rela)HY(tion)HY(ship)YH(.
  Re-export)HY(ing)YH( )SM(std)ES( \201or, better yet, )SM(std.vector)ES(, if
  it were avail)HY(able)YH(\202 seems less unrea)HY(son)HY(able)YH(.)EP(

  )0 P(Note also that there is no re-export of headers nor header inclu)HY(sion)YH(
  visi)HY(bil)HY(ity)YH( in the imple)HY(men)HY(ta)HY(tion)YH( units. Specif)HY(i)HY(cally)YH(, in the previ)HY(ous)YH(
  example, if the stan)HY(dard)YH( library is not modu)HY(lar)HY(ized)YH( and we have to use it
  via headers, then the consumers of our )SM(small_vector)ES( will always
  have to explic)HY(itly)YH( include )SM(<vector>)ES(. This suggest that
  modu)HY(lar)HY(iz)HY(ing)YH( a code)HY(base)YH( that still consumes substan)HY(tial)YH( compo)HY(nents)YH( \201like the
  stan)HY(dard)YH( library\202 via headers can incur some devel)HY(op)HY(ment)YH( over)HY(head)YH( compared
  to the old, headers-only approach.)EP(

  )0 3 203 H(16.3.6)WB 414 Sn()WB 205 Sn( Modu)HY(lar)HY(iz)HY(ing)YH( Exist)HY(ing)YH( Code)EH(

  )0 P(The aim of this section is to provide prac)HY(ti)HY(cal)YH( guide)HY(lines)YH( to
  modu)HY(lar)HY(iz)HY(ing)YH( exist)HY(ing)YH( code)HY(bases)YH(.)EP(

  )0 P(Predictably, a well modu)HY(lar)HY(ized)YH( \201in the general sense\202 set of headers
  makes conver)HY(sion)YH( to C++ modules easier. Inclu)HY(sion)YH( cycles will be
  partic)HY(u)HY(larly)YH( hard to deal with \201C++ modules do not allow circu)HY(lar)YH( inter)HY(face)YH(
  depen)HY(den)HY(cies)YH(\202. Having a one-to-one header to module mapping will simplify
  this task. As a result, it may make sense to spend some time clean)HY(ing)YH( and
  re-orga)HY(niz)HY(ing)YH( your headers prior to attempt)HY(ing)YH( modu)HY(lar)HY(iza)HY(tion)YH(.)EP(

  )0 P(The recom)HY(mended)YH( strat)HY(egy)YH( for modu)HY(lar)HY(iz)HY(ing)YH( our own compo)HY(nents)YH( is to
  iden)HY(tify)YH( and modu)HY(lar)HY(ize)YH( inter-depen)HY(dent)YH( sets of headers one at a time
  start)HY(ing)YH( from the lower-level compo)HY(nents)YH(. This way any newly modu)HY(lar)HY(ized)YH( set
  will only depend on the already modu)HY(lar)HY(ized)YH( ones. After convert)HY(ing)YH( each set
  we can switch its consumers to using imports keeping our entire project
  build)HY(able)YH( and usable.)EP(

  )0 P(While ideally we would want to be able to modu)HY(lar)HY(ize)YH( just a single
  compo)HY(nent)YH( at a time, this does not seem to work in prac)HY(tice)YH( because we will
  have to continue consum)HY(ing)YH( some of the compo)HY(nents)YH( as headers. Since such
  headers can only be imported out of the module purview, it becomes hard to
  reason \201both for us and often the compiler\202 what is imported/included and
  where. For example, it's not uncom)HY(mon)YH( to end up import)HY(ing)YH( the module in its
  imple)HY(men)HY(ta)HY(tion)YH( unit which is not some)HY(thing)YH( that all the compil)HY(ers)YH( can handle
  grace)HY(fully)YH(.)EP(

  )0 P(If our module needs to "export" macros then the recom)HY(mended)YH( approach is
  to simply provide an addi)HY(tional)YH( header that the consumer includes. While it
  might be tempt)HY(ing)YH( to also wrap the module import into this header, some may
  prefer to explic)HY(itly)YH( import the module and include the header, espe)HY(cially)YH( if
  the macros may not be needed by all consumers. This way we can also keep the
  header macro-only which means it can be included freely, in or out of module
  purviews.)EP(

  )0 2 204 H(16.4)WB 415 Sn()WB 206 Sn( Objec)HY(tive)YH(-C++ Compi)HY(la)HY(tion)YH()EH(

  )0 P(The )SM(cxx)ES( module provides the )SM(cxx.objcxx)ES(
  submod)HY(ule)YH( which can be loaded in order to regis)HY(ter)YH( the )SM(mm{})ES(
  target type and enable Objec)HY(tive)YH(-C++ compi)HY(la)HY(tion)YH( in the )SM(C++)ES(
  compile rule. Note that )SM(cxx.objcxx)ES( must be loaded after the
  )SM(cxx)ES( module and while the )SM(mm{})ES( target type is
  regis)HY(tered)YH( uncon)HY(di)HY(tion)HY(ally)YH(, compi)HY(la)HY(tion)YH( is only enabled if the C++ compiler
  supports Objec)HY(tive)YH(-C++ for the target plat)HY(form)YH(. Typical usage:)EP(

  ) 4 16 PR(# root.build
#
using cxx
using cxx.objcxx)RP(

  ) 4 60 PR(# buildfile
#
lib{hello}: {hxx cxx}{*}
lib{hello}: mm{*}: include = \201$cxx.target.class  == 'macos'\202)RP(

  )0 P(Note also that while there is support for linking Objec)HY(tive)YH(-C++
  executa)HY(bles)YH( and libraries, this is done using the C++ compiler driver and no
  attempt is made to auto)HY(mat)HY(i)HY(cally)YH( link any neces)HY(sary)YH( Objec)HY(tive)YH(-C runtime
  library \201such as )SM(-lobjc)ES(\202.)EP(

  )0 2 205 H(16.5)WB 416 Sn()WB 207 Sn( C++ Compiler Prede)HY(fined)YH( Macro Extrac)HY(tion)YH()EH(

  )0 P(The )SM(cxx)ES( module provides the )SM(cxx.predefs)ES(
  submod)HY(ule)YH( which can be loaded in order to regis)HY(ter)YH( a rule that gener)HY(ates)YH( a
  C++ header with prede)HY(fined)YH( compiler macros. Note that the
  )SM(cxx.predefs)ES( module must be loaded after the )SM(cxx)ES(
  module and the rule will only match with an explicit rule hint. Typical
  usage:)EP(

  ) 4 17 PR(# root.build
#
using cxx
using cxx.predefs)RP(

  ) 3 37 PR(# buildfile
#
[rule_hint=cxx.predefs] hxx{predefs}:)RP(

  )0 P(Note also that the MSVC compiler only supports the prede)HY(fined)YH( macro
  extrac)HY(tion)YH( start)HY(ing)YH( from Visual Studio 2019 \20116.0; )SM(cl.exe)ES(
  version 19.20\202. If support for earlier versions is required, then you will
  need to provide a fall)HY(back)YH( imple)HY(men)HY(ta)HY(tion)YH( appro)HY(pri)HY(ate)YH( for your project. For
  example:)EP(

  ) 13 60 PR([rule_hint=cxx.predefs] hxx{predefs}:
% update
if \201$cxx.id == 'msvc' && \200
    \201$cxx.version.major < 19 || \200
     \201$cxx.version.major == 19 && $cxx.version.minor < 20\202\202\202
{{
  diag c++-predefs $>

  cat <<EOF >$path\201$>\202
  #define _WIN32
  #define __cplusplus 201402L
  EOF
}})RP(

  )0 1 206 H(17)WB 417 Sn()WB 208 Sn( )SM(in)ES( Module)EH(

  )0 P(The )SM(in)ES( build system module provides support for
  )SM(.in)ES( \201input\202 file prepro)HY(cess)HY(ing)YH(. Specif)HY(i)HY(cally)YH(, the
  )SM(.in)ES( file can contain a number of )I(substi)HY(tu)HY(tions)YH()ES( \235
  build system vari)HY(able)YH( names enclosed with the substi)HY(tu)HY(tion)YH( symbol
  \201)SM($)ES( by default\202 \235 which are replaced with the
  corre)HY(spond)HY(ing)YH( vari)HY(able)YH( values to produce the output file. For example:)EP(

  ) 3 18 PR(# build/root.build

using in)RP(

  ) 3 29 PR(// config.hxx.in

#define TARGET "$cxx.target$")RP(

  ) 3 23 PR(# buildfile

hxx{config}: in{config})RP(

  )0 P(The )SM(in)ES( module defines the )SM(in{})ES( target type and
  imple)HY(ments)YH( the )SM(in)ES( build system rule.)EP(

  )0 P(While we can specify the )SM(.in)ES( exten)HY(sion)YH( explic)HY(itly)YH(, it is not
  neces)HY(sary)YH( because the )SM(in{})ES( target type imple)HY(ments)YH(
  )I(target-depen)HY(dent)YH( search)ES( by taking into account the target it is a
  prereq)HY(ui)HY(site)YH( of. In other words, the follow)HY(ing)YH( depen)HY(dency)YH( decla)HY(ra)HY(tions)YH(
  produce the same result:)EP(

  ) 3 34 PR(hxx{config}:     in{config}
hxx{config.hxx}: in{config}
hxx{config.hxx}: in{config.hxx.in})RP(

  )0 P(By default the )SM(in)ES( rule uses )SM($)ES( as the
  substi)HY(tu)HY(tion)YH( symbol. This can be changed using the )SM(in.symbol)ES(
  vari)HY(able)YH(. For example:)EP(

  ) 3 29 PR(// data.cxx.in

const char data[] = "@data@";)RP(

  ) 7 24 PR(# buildfile

cxx{data}: in{data}
{
  in.symbol = '@'
  data = 'Hello, World!'
})RP(

  )0 P(Note that the substi)HY(tu)HY(tion)YH( symbol must be a single char)HY(ac)HY(ter)YH(.)EP(

  )0 P(The default substi)HY(tu)HY(tion)YH( mode is strict. In this mode every substi)HY(tu)HY(tion)YH(
  symbol is expected to start a substi)HY(tu)HY(tion)YH( with unre)HY(solved)YH( \201to a vari)HY(able)YH(
  value\202 names treated as errors. The double substi)HY(tu)HY(tion)YH( symbol \201for example,
  )SM($$)ES(\202 serves as an escape sequence.)EP(

  )0 P(The substi)HY(tu)HY(tion)YH( mode can be relaxed using the )SM(in.mode)ES(
  vari)HY(able)YH(. Its valid values are )SM(strict)ES( \201default\202 and
  )SM(lax)ES(. In the lax mode a pair of substi)HY(tu)HY(tion)YH( symbols is only
  treated as a substi)HY(tu)HY(tion)YH( if what's between them looks like a build system
  vari)HY(able)YH( name \201that is, it doesn't contain spaces, etc\202. Every)HY(thing)YH( else,
  includ)HY(ing)YH( unter)HY(mi)HY(nated)YH( substi)HY(tu)HY(tion)YH( symbols, is copied as is. Note also that
  in this mode the double substi)HY(tu)HY(tion)YH( symbol is not treated as an escape
  sequence.)EP(

  )0 P(The lax mode is mostly useful when trying to reuse exist)HY(ing)YH(
  )SM(.in)ES( files from other build systems, such as
  )SM(auto)HY(conf)YH()ES(. Note, however, that the lax mode is still stricter
  than )SM(auto)HY(conf)YH()ES('s seman)HY(tics)YH( which also leaves unre)HY(solved)YH(
  substi)HY(tu)HY(tions)YH( as is. For example:)EP(

  ) 10 40 PR(# buildfile

h{config}: in{config} # config.h.in
{
  in.symbol = '@'
  in.mode = lax

  CMAKE_SYSTEM_NAME = $c.target.system
  CMAKE_SYSTEM_PROCESSOR = $c.target.cpu
})RP(

  )0 P(The )SM(in)ES( rule tracks changes to the input file as well as the
  substi)HY(tuted)YH( vari)HY(able)YH( values and auto)HY(mat)HY(i)HY(cally)YH( regen)HY(er)HY(ates)YH( the output file if
  any were detected. Substi)HY(tuted)YH( vari)HY(able)YH( values are looked up start)HY(ing)YH( from
  the target-specific vari)HY(ables)YH(. Typed vari)HY(able)YH( values are converted to string
  using the corre)HY(spond)HY(ing)YH( )SM(builtin.string\201\202)ES( func)HY(tion)YH( over)HY(load)YH(
  before substi)HY(tu)HY(tion)YH(.)EP(

  )0 P(While spec)HY(i)HY(fy)HY(ing)YH( substi)HY(tu)HY(tion)YH( values as )SM(build)HY(file)YH()ES( vari)HY(ables)YH(
  is usually natural, some)HY(times)YH( this may not be possi)HY(ble)YH( or conve)HY(nient)YH(.
  Specif)HY(i)HY(cally)YH(, we may have substi)HY(tu)HY(tion)YH( names that cannot be spec)HY(i)HY(fied)YH( as
  )SM(build)HY(file)YH()ES( vari)HY(ables)YH(, for example, because they start with an
  under)HY(score)YH( \201and are thus reserved\202 or because they refer to one of the
  prede)HY(fined)YH( vari)HY(ables)YH(. Also, we may need to have differ)HY(ent)YH( groups of
  substi)HY(tu)HY(tion)YH( values for differ)HY(ent)YH( cases, for example, for differ)HY(ent)YH(
  plat)HY(forms)YH(, and it would be conve)HY(nient)YH( to pass such groups around as a single
  value.)EP(

  )0 P(To support these require)HY(ments)YH( the substi)HY(tu)HY(tion)YH( values can alter)HY(na)HY(tively)YH(
  be spec)HY(i)HY(fied)YH( as key-value pairs in the )SM(in.substi)HY(tu)HY(tions)YH()ES(
  vari)HY(able)YH(. Note that entries in this substi)HY(tu)HY(tion)YH( map take prece)HY(dence)YH( over
  the )SM(build)HY(file)YH()ES( vari)HY(ables)YH(. For example:)EP(

  ) 4 37 PR(/* config.h.in */

#define _GNU_SOURCE   @_GNU_SOURCE@
#define _POSIX_SOURCE @_POSIX_SOURCE@)RP(

  ) 9 50 PR(# buildfile

h{config}: in{config}
{
  in.symbol = '@'
  in.mode = lax

  in.substitutions = _GNU_SOURCE@0 _POSIX_SOURCE@1
})RP(

  )BR(
  )0 P(In the above example, the )SM(@)ES( char)HY(ac)HY(ters)YH( in
  )SM(in.symbol)ES( and )SM(in.substi)HY(tu)HY(tions)YH()ES( are unre)HY(lated)YH(.)EP(
  )BR(

  )0 P(Using an unde)HY(fined)YH( vari)HY(able)YH( in a substi)HY(tu)HY(tion)YH( is an error. Using a
  )SM(null)ES( value in a substi)HY(tu)HY(tion)YH( is also an error unless the
  fall)HY(back)YH( value is spec)HY(i)HY(fied)YH( with the )SM(in.null)ES( vari)HY(able)YH(. For
  example:)EP(

  ) 6 58 PR(# buildfile

h{config}: in{config}
{
  in.null = '' # Substitute null values with empty string.
})RP(

  )BR(
  )0 P(To specify a )SM(null)ES( value using the
  )SM(in.substi)HY(tu)HY(tions)YH()ES( mech)HY(a)HY(nism)YH( omit the value, for example:)EP(

  ) 1 30 PR(in.substitutions = _GNU_SOURCE)RP(
  )BR(

  )0 P(A number of other build system modules, for example, )R2 2 A()SM(auto)HY(conf)YH()ES()EA(,
  )0 167 1 A()SM(version)ES()167 0 TN TL()Ec /AF f D(, and )0 209 1 A()SM(bash)ES()209 0 TN TL()Ec /AF f D(, are based on the )SM(in)ES(
  module and provide extended func)HY(tion)HY(al)HY(ity)YH(. The )SM(in)ES( prepro)HY(cess)HY(ing)YH(
  rule matches any )SM(file{})ES(-based target that has the corre)HY(spond)HY(ing)YH(
  )SM(in{})ES( prereq)HY(ui)HY(site)YH( provided none of the extended rules
  match.)EP(

  )0 1 207 H(18)WB 418 Sn()WB 209 Sn( )SM(bash)ES( Module)EH(

  )0 P(The )SM(bash)ES( build system module provides modu)HY(lar)HY(iza)HY(tion)YH( support
  for )SM(bash)ES( scripts. It is based on the )0 208 1 A()SM(in)ES()208 0 TN TL()Ec /AF f D( build system module and extends its
  prepro)HY(cess)HY(ing)YH( rule with support for )I(import substi)HY(tu)HY(tions)YH()ES( in the
  )SM(@import\240<module>@)ES( form. During prepro)HY(cess)HY(ing)YH(, such
  imports are replaced with suit)HY(able)YH( )SM(source)ES( builtin calls. For
  example:)EP(

  ) 3 18 PR(# build/root.build

using bash)RP(

  ) 6 22 PR(# hello/say-hello.bash

function say_hello \201\202
{
  echo "Hello, $1!"
})RP(

  ) 7 24 PR(#!/usr/bin/env bash

# hello/hello.in

@import hello/say-hello@

say_hello 'World')RP(

  ) 3 37 PR(# hello/buildfile

exe{hello}: in{hello} bash{say-hello})RP(

  )0 P(By default the )SM(bash)ES( prepro)HY(cess)HY(ing)YH( rule uses the lax
  substi)HY(tu)HY(tion)YH( mode and )SM(@)ES( as the substi)HY(tu)HY(tion)YH( symbol but this can
  be over)HY(rid)HY(den)YH( using the stan)HY(dard)YH( )SM(in)ES( module mech)HY(a)HY(nisms)YH(.)EP(

  )0 P(In the above example, )SM(say-hello.bash)ES( is a )I(module)ES(. By
  conven)HY(tion)YH(, )SM(bash)ES( modules have the )SM(.bash)ES( exten)HY(sion)YH(
  and we use the )SM(bash{})ES( target type \201defined by the
  )SM(bash)ES( build system module\202 to refer to them in build)HY(files)YH(.)EP(

  )0 P(The )SM(say-hello.bash)ES( module is )I(imported)ES( by the
  )SM(hello)ES( script with the
  )SM(@import\240hello/say-hello@)ES( substi)HY(tu)HY(tion)YH(. The )I(import
  path)ES( \201)SM(hello/say-hello)ES( in our case\202 is a path to the module
  file within the project. Its first compo)HY(nent)YH( \201)SM(hello)ES( in our
  case\202 must be both the project name and the top-level subdi)HY(rec)HY(tory)YH( within
  the project. The )SM(.bash)ES( module exten)HY(sion)YH( can be omitted. The constraint placed on the first compo)HY(nent)YH( of the import path
  is required to imple)HY(ment)YH( impor)HY(ta)HY(tion)YH( of installed modules, as discussed
  below.)EP(

  )0 P(During prepro)HY(cess)HY(ing)YH(, the import substi)HY(tu)HY(tion)YH( will be replaced with a
  )SM(source)ES( builtin call and the import path resolved to one of the
  )SM(bash{})ES( prereq)HY(ui)HY(sites)YH( from the script's depen)HY(dency)YH( decla)HY(ra)HY(tion)YH(.
  The actual module path used in )SM(source)ES( depends on whether the
  script is prepro)HY(cessed)YH( for instal)HY(la)HY(tion)YH(. If it's not \201devel)HY(op)HY(ment)YH( build\202,
  then the abso)HY(lute)YH( path to the module file is used. Other)HY(wise)YH(, a path
  rela)HY(tive)YH( to the sourc)HY(ing)YH( script's direc)HY(tory)YH( is derived. This allows
  installed scripts and their modules to be moved around.)EP(

  )BR(
  )0 P(The deriva)HY(tion)YH( of the sourc)HY(ing)YH( script's direc)HY(tory)YH( works even if the
  script is executed via a symbolic link from another direc)HY(tory)YH(. Imple)HY(ment)HY(ing)YH(
  this, however, requires )SM(read)HY(link)YH(\2011\202)ES( with support for the
  )SM(-f)ES( option. One notable plat)HY(form)YH( that does not provide such
  )SM(read)HY(link)YH(\2011\202)ES( by default is Mac OS. The script, however, can
  provide a suit)HY(able)YH( imple)HY(men)HY(ta)HY(tion)YH( as a func)HY(tion)YH(. See the )SM(bash)ES(
  module tests for a sample imple)HY(men)HY(ta)HY(tion)YH( of such a func)HY(tion)YH(.)EP(
  )BR(

  )0 P(By default, )SM(bash)ES( modules are installed into a subdi)HY(rec)HY(tory)YH(
  of the )SM(bin/)ES( instal)HY(la)HY(tion)YH( direc)HY(tory)YH( named as the project name
  plus the )SM(.bash)ES( exten)HY(sion)YH(. For instance, in the above example,
  the script will be installed as )SM(bin/hello)ES( and the module as
  )SM(bin/hello.bash/say-hello.bash)ES( with the script sourc)HY(ing)YH( the
  module rela)HY(tive)YH( to the )SM(bin/)ES( direc)HY(tory)YH(. Note that currently it
  is assumed the script and all its modules are installed into the same
  )SM(bin/)ES( direc)HY(tory)YH(.)EP(

  )0 P(Natu)HY(rally)YH(, modules can import other modules and modules can be pack)HY(aged)YH(
  into )I(module libraries)ES( and imported using the stan)HY(dard)YH( build system
  import mech)HY(a)HY(nism)YH(. For example, we could factor the
  )SM(say-hello.bash)ES( module into a sepa)HY(rate)YH( )SM(libhello)ES(
  project:)EP(

  ) 8 40 PR(# build/export.build

$out_root/
{
  include libhello/
}

export $src_root/libhello/$import.target)RP(

  ) 6 27 PR(# libhello/say-hello.bash

function hello_say_hello \201\202
{
  echo "Hello, $1!"
})RP(

  )0 P(And then import it in a module of our )SM(hello)ES( project:)EP(

  ) 8 27 PR(# hello/hello-world.bash.in

@import libhello/say-hello@

function hello_world \201\202
{
  hello_say_hello 'World'
})RP(

  ) 7 26 PR(#!/usr/bin/env bash

# hello/hello.in

@import hello/hello-world@

hello_world)RP(

  ) 6 52 PR(# hello/buildfile

import mods = libhello%bash{say-hello}

exe{hello}:        in{hello}       bash{hello-world}
bash{hello-world}: in{hello-world} $mods)RP(

  )0 P(The )SM(bash)ES( prepro)HY(cess)HY(ing)YH( rule also supports impor)HY(ta)HY(tion)YH( of
  installed modules by search)HY(ing)YH( in the )SM(PATH)ES( envi)HY(ron)HY(ment)YH(
  vari)HY(able)YH(.)EP(

  )0 P(By conven)HY(tion)YH(, )SM(bash)ES( module libraries should use the
  )SM(lib)ES( name prefix, for example, )SM(libhello)ES(. If there
  is also a native library \201that is, one written in C/C++\202 that provides the
  same func)HY(tion)HY(al)HY(ity)YH( \201or the )SM(bash)ES( library is a language binding
  for the said library\202, then it is custom)HY(ary)YH( to add the )SM(.bash)ES(
  exten)HY(sion)YH( to the )SM(bash)ES( library name, for example,
  )SM(libhello.bash)ES(. Note that in this case the top-level
  subdi)HY(rec)HY(tory)YH( within the project is expected to be called without the
  )SM(bash)ES( exten)HY(sion)YH(, for example, )SM(libhello)ES(.)EP(

  )0 P(Modules can be )I(private)ES( or )I(public)ES(. Private modules are
  imple)HY(men)HY(ta)HY(tion)YH( details of a specific project and are not expected to be
  imported from other projects. The )SM(hello/hello-world.bash.in)ES(
  module above is an example of a private module. Public modules are meant to
  be used by other projects and are normally pack)HY(aged)YH( into libraries, like the
  )SM(libhello/say-hello.bash)ES( module above.)EP(

  )0 P(Public modules must take care to avoid name clashes. Since
  )SM(bash)ES( does not have a notion of names)HY(paces)YH(, the recom)HY(mended)YH( way
  is to prefix all module func)HY(tions)YH( \201and global vari)HY(ables)YH(, if any\202 with the
  library name \201without the )SM(lib)ES( prefix\202, like in the
  )SM(libhello/say-hello.bash)ES( module above.)EP(

  )0 P(While using such deco)HY(rated)YH( func)HY(tion)YH( names can be unwieldy, it is
  rela)HY(tively)YH( easy to create wrap)HY(pers)YH( with shorter names and use those instead.
  For example:)EP(

  ) 3 47 PR(@import libhello/say-hello@

function say_hello \201\202 { hello_say_hello "$@"; })RP(

  )0 P(A module should normally also prevent itself from being sourced multi)HY(ple)YH(
  times. The recom)HY(mended)YH( way to achieve this is to begin the module with a
  )I(source guard)ES(. For example:)EP(

  ) 12 31 PR(# libhello/say-hello.bash

if [ "$hello_say_hello" ]; then
  return 0
else
  hello_say_hello=true
fi

function hello_say_hello \201\202
{
  echo "Hello, $1!"
})RP(

  )0 P(The )SM(bash)ES( prepro)HY(cess)HY(ing)YH( rule matches )SM(exe{})ES(
  targets that have the corre)HY(spond)HY(ing)YH( )SM(in{})ES( and one or more
  )SM(bash{})ES( prereq)HY(ui)HY(sites)YH( as well as )SM(bash{})ES( targets
  that have the corre)HY(spond)HY(ing)YH( )SM(in{})ES( prereq)HY(ui)HY(site)YH( \201if you need to
  prepro)HY(cess)YH( a script that does not depend on any modules, you can use the
  )SM(in)ES( module's rule\202.)EP(

  )0 1 208 H(19)WB 419 Sn()WB 210 Sn( Appendix A \235 JSON Dump Format)EH(

  )0 P(This appendix describes the machine-read)HY(able)YH(, JSON-based build system
  state dump format that can be requested with the
  )SM(--dump-format=json-v0.1)ES( build system driver option \201see )0 2 A()SM()BD(b\2011\202)ES()ES()EA( for details\202.)EP(

  )0 P(The format is spec)HY(i)HY(fied)YH( in terms of the seri)HY(al)HY(ized)YH( repre)HY(sen)HY(ta)HY(tion)YH( of C++
  )SM(struct)ES( instances. See )0 2 A(JSON
  OUTPUT)EA( for details on the overall prop)HY(er)HY(ties)YH( of this format and the
  seman)HY(tics)YH( of the )SM(struct)ES( seri)HY(al)HY(iza)HY(tion)YH(.)EP(

  )BR(
  )0 P(This format is currently unsta)HY(ble)YH( \201thus the tempo)HY(rary)YH( )SM(-v0.1)ES(
  suffix\202 and may be changed in ways other than as described in )0 2 A(JSON OUTPUT)EA(. In case of such changes the
  format version will be incre)HY(mented)YH( to allow detect)HY(ing)YH( incom)HY(pat)HY(i)HY(bil)HY(i)HY(ties)YH( but
  no support for older versions is guar)HY(an)HY(teed)YH(.)EP(
  )BR(

  )0 P(The build system state can be dumped after the load phase
  \201)SM(--dump=load)ES(\202, once the build state has been loaded, and/or
  after the match phase \201)SM(--dump=match)ES(\202, after rules have been
  matched to targets to execute the desired action. The JSON format differs
  depend)HY(ing)YH( on after which phase it is produced. After the load phase the
  format aims to describe the action-inde)HY(pen)HY(dent)YH( state, essen)HY(tially)YH( as
  spec)HY(i)HY(fied)YH( in the )SM(build)HY(files)YH()ES(. While after the match phase it
  aims to describe the state for execut)HY(ing)YH( the spec)HY(i)HY(fied)YH( action, as deter)HY(mined)YH(
  by the rules that have been matched. The former state would be more
  appro)HY(pri)HY(ate)YH(, for example, for an IDE that tries to use
  )SM(build)HY(files)YH()ES( as project files. While the latter state could be
  used to deter)HY(mine)YH( the actual build graph for a certain action, for example,
  in order to infer which executable targets are consid)HY(ered)YH( tests by the
  )SM(test)ES( oper)HY(a)HY(tion)YH(.)EP(

  )0 P(While it's possi)HY(ble)YH( to dump the build state as a byprod)HY(uct)YH( of execut)HY(ing)YH(
  an action \201for example, perform)HY(ing)YH( an update\202, it's often desir)HY(able)YH( to only
  dump the build state and do it as quickly as possi)HY(ble)YH(. For such cases the
  recom)HY(mended)YH( option combi)HY(na)HY(tions)YH( are as follows \201see the
  )SM(--load-only)ES( and )SM(--match-only)ES( docu)HY(men)HY(ta)HY(tion)YH( for
  details\202:)EP(

  ) 4 72 PR($ b --load-only --dump=load --dump-format=json-v0.1 .../dir/

$ b --match-only --dump=match --dump-format=json-v0.1 .../dir/
$ b --match-only --dump=match --dump-format=json-v0.1 .../dir/type{name})RP(

  )BR(
  )0 P(Note that a match dump for a large project can produce a large amount of
  data, espe)HY(cially)YH( for the )SM(update)ES( oper)HY(a)HY(tion)YH( \201tens and even
  hundreds of megabytes is not uncom)HY(mon)YH(\202. To reduce this size it is possi)HY(ble)YH(
  to limit the dump to specific scopes and/or targets with the
  )SM(--dump-scope)ES( and )SM(--dump-target)ES( options.)EP(
  )BR(

  )0 P(The complete dump \201that is, not of a specific scope or target\202 is a tree
  of nested scope objects \201see )0 6 1 A(Output Direc)HY(to)HY(ries)YH(
  and Scopes)6 0 TN TL()Ec /AF f D( for back)HY(ground)YH(\202. The scope object has the seri)HY(al)HY(ized)YH(
  repre)HY(sen)HY(ta)HY(tion)YH( of the follow)HY(ing)YH( C++ )SM(struct)ES( )SM(scope)ES(.
  It is the same for both load and match dumps except for the type of the
  )SM(targets)ES( member:)EP(

  ) 11 66 PR(struct scope
{
  string           out_path;
  optional<string> src_path;

  vector<variable> variables; // Non-type/pattern scope variables.

  vector<scope> scopes; // Immediate children.

  vector<loaded_target|matched_target> targets;
};)RP(

  )0 P(For example \201parts of the output are omitted for brevity\202:)EP(

  )BR(
  )0 P(The actual output is produced unin)HY(dented)YH( to reduce the size.)EP(
  )BR(

  ) 32 51 PR($ cd /tmp
$ bdep new hello
$ cd hello
$ bdep new -C @gcc cc
$ b --load-only --dump=load --dump-format=json-v0.1
{
  "out_path": "",
  "variables": [ ... ],
  "scopes": [
    {
      "out_path": "/tmp/hello-gcc",
      "variables": [ ... ],
      "scopes": [
        {
          "out_path": "hello",
          "src_path": "/tmp/hello",
          "variables": [ ... ],
          "scopes": [
            {
              "out_path": "hello",
              "src_path": "/tmp/hello/hello",
              "variables": [ ... ],
              "targets": [ ... ]
            }
          ],
          "targets": [ ... ]
        }
      ],
      "targets": [ ... ]
    }
  ])WR(
})RP(

  )0 P(The )SM(out_path)ES( member is rela)HY(tive)YH( to the parent scope. It is
  empty for the special global scope, which is the root of the tree. The
  )SM(src_path)ES( member is absent if it is the same as
  )SM(out_path)ES( \201in source build or scope outside of project\202.)EP(

  )BR(
  )0 P(For the match dump, targets that have not been matched for the spec)HY(i)HY(fied)YH(
  action are omitted.)EP(
  )BR(

  )0 P(In the load dump, the target object has the seri)HY(al)HY(ized)YH( repre)HY(sen)HY(ta)HY(tion)YH( of
  the follow)HY(ing)YH( C++ )SM(struct)ES( )SM(loaded_target)ES(:)EP(

  ) 11 68 PR(struct loaded_target
{
  string           name;  // Relative quoted/qualified name.
  string   display_name;  // Relative display name.
  string           type;  // Target type.
  optional<string> group; // Absolute quoted/qualified group target.

  vector<variable> variables; // Target variables.

  vector<prerequisite> prerequisites;
};)RP(

  )0 P(For example \201contin)HY(u)HY(ing)YH( with the previ)HY(ous)YH( )SM(hello)ES( setup\202:)EP(

  ) 37 55 PR({
  "out_path": "",
  "scopes": [
    {
      "out_path": "/tmp/hello-gcc",
      "scopes": [
        {
          "out_path": "hello",
          "src_path": "/tmp/hello",
          "scopes": [
            {
              "out_path": "hello",
              "src_path": "/tmp/hello/hello",
              "targets": [
                {
                  "name": "exe{hello}",
                  "display_name": "exe{hello}",
                  "type": "exe",
                  "prerequisites": [
                    {
                      "name": "cxx{hello}",
                      "type": "cxx"
                    },
                    {
                      "name": "testscript{testscript}",
                      "type": "testscript"
                    }
                  ]
                }
              ]
            })WR(
          ]
        }
      ]
    }
  ]
})RP(

  )0 P(The target )SM(name)ES( member is the target name that is qual)HY(i)HY(fied)YH(
  with the exten)HY(sion)YH( \201if appli)HY(ca)HY(ble)YH( and known\202 and, if required, is quoted so
  that it can be passed back to the build system driver on the command line.
  The )SM(display_name)ES( member is unqual)HY(i)HY(fied)YH( and unquoted. Note that
  both the target )SM(name)ES( and )SM(display_name)ES( members are
  normally rela)HY(tive)YH( to the contain)HY(ing)YH( scope \201if any\202.)EP(

  )0 P(The prereq)HY(ui)HY(site)YH( object has the seri)HY(al)HY(ized)YH( repre)HY(sen)HY(ta)HY(tion)YH( of the
  follow)HY(ing)YH( C++ )SM(struct)ES( )SM(prereq)HY(ui)HY(site)YH()ES(:)EP(

  ) 6 56 PR(struct prerequisite
{
  string name; // Quoted/qualified name.
  string type;
  vector<variable> variables; // Prerequisite variables.
};)RP(

  )0 P(The prereq)HY(ui)HY(site)YH( )SM(name)ES( member is normally rela)HY(tive)YH( to the
  contain)HY(ing)YH( scope.)EP(

  )0 P(In the match dump, the target object has the seri)HY(al)HY(ized)YH( repre)HY(sen)HY(ta)HY(tion)YH( of
  the follow)HY(ing)YH( C++ )SM(struct)ES( )SM(matched_target)ES(:)EP(

  ) 14 68 PR(struct matched_target
{
  string           name;
  string   display_name;
  string           type;
  optional<string> group;

  optional<path> path; // Absent if not path target, not assigned.

  vector<variable> variables;

  optional<operation_state> outer_operation; // null if not matched.
  operation_state           inner_operation; // null if not matched.
};)RP(

  )0 P(For example \201outer scopes removed for brevity\202:)EP(

  ) 53 63 PR($ b --match-only --dump=match --dump-format=json-v0.1
{
  "out_path": "hello",
  "src_path": "/tmp/hello/hello",
  "targets": [
    {
      "name": "/tmp/hello/hello/cxx{hello.cxx}@./",
      "display_name": "/tmp/hello/hello/cxx{hello}@./",
      "type": "cxx",
      "path": "/tmp/hello/hello/hello.cxx",
      "inner_operation": {
        "rule": "build.file",
        "state": "unchanged"
      }
    },
    {
      "name": "obje{hello.o}",
      "display_name": "obje{hello}",
      "type": "obje",
      "group": "/tmp/hello-gcc/hello/hello/obj{hello}",
      "path": "/tmp/hello-gcc/hello/hello/hello.o",
      "inner_operation": {
        "rule": "cxx.compile",
        "prerequisite_targets": [
          {
            "name": "/tmp/hello/hello/cxx{hello.cxx}@./",
            "type": "cxx"
          },
          {
            "name": "/usr/include/c++/12/h{iostream.}",
            "type": "h")WR(
          },
          ...
        ]
      }
    },
    {
      "name": "exe{hello.}",
      "display_name": "exe{hello}",
      "type": "exe",
      "path": "/tmp/hello-gcc/hello/hello/hello",
      "inner_operation": {
        "rule": "cxx.link",
        "prerequisite_targets": [
          {
            "name": "/tmp/hello-gcc/hello/hello/obje{hello.o}",
            "type": "obje"
          }
        ]
      }
    }
  ]
})RP(

  )0 P(The first four members in )SM(matched_target)ES( have the same
  seman)HY(tics)YH( as in )SM(loaded_target)ES(.)EP(

  )0 P(The )SM(outer_oper)HY(a)HY(tion)YH()ES( member is only present if the action has
  an outer oper)HY(a)HY(tion)YH(. For example, when perform)HY(ing)YH(
  )SM(update-for-test)ES(, )SM(test)ES( is the outer oper)HY(a)HY(tion)YH( while
  )SM(update)ES( is the inner oper)HY(a)HY(tion)YH(.)EP(

  )0 P(The oper)HY(a)HY(tion)YH( state object has the seri)HY(al)HY(ized)YH( repre)HY(sen)HY(ta)HY(tion)YH( of the
  follow)HY(ing)YH( C++ )SM(struct)ES( )SM(oper)HY(a)HY(tion)YH(_state)ES(:)EP(

  ) 10 60 PR(struct operation_state
{
  string rule; // null if direct recipe match.

  optional<string> state; // One of unchanged|changed|group.

  vector<variable> variables; // Rule variables.

  vector<prerequisite_target> prerequisite_targets;
};)RP(

  )0 P(The )SM(rule)ES( member is the matched rule name. The
  )SM(state)ES( member is the target state, if known after match. The
  )SM(prereq)HY(ui)HY(site)YH(_targets)ES( array is a subset of prereq)HY(ui)HY(sites)YH(
  resolved to targets that are in effect for this action. The matched rule may
  add addi)HY(tional)YH( targets, for example, dynam)HY(i)HY(cally)YH( extracted addi)HY(tional)YH(
  depen)HY(den)HY(cies)YH(, like )SM(/usr/include/c++/12/h{iostream.})ES( in the
  above listing.)EP(

  )0 P(The prereq)HY(ui)HY(site)YH( target object has the seri)HY(al)HY(ized)YH( repre)HY(sen)HY(ta)HY(tion)YH( of the
  follow)HY(ing)YH( C++ )SM(struct)ES( )SM(prereq)HY(ui)HY(site)YH(_target)ES(:)EP(

  ) 6 56 PR(struct prerequisite_target
{
  string name; // Absolute quoted/qualified target name.
  string type;
  bool adhoc;
};)RP(

  )0 P(The )SM(vari)HY(ables)YH()ES( array in the scope, target, prereq)HY(ui)HY(site)YH(, and
  prereq)HY(ui)HY(site)YH( target objects contains scope, target, prereq)HY(ui)HY(site)YH(, and rule
  vari)HY(ables)YH(, respec)HY(tively)YH(.)EP(

  )0 P(The vari)HY(able)YH( object has the seri)HY(al)HY(ized)YH( repre)HY(sen)HY(ta)HY(tion)YH( of the follow)HY(ing)YH(
  C++ )SM(struct)ES( )SM(vari)HY(able)YH()ES(:)EP(

  ) 6 68 PR(struct variable
{
  string           name;
  optional<string> type;
  json_value       value; // null|boolean|number|string|object|array
};)RP(

  )0 P(For example:)EP(

  ) 57 72 PR({
  "out_path": "",
  "variables": [
    {
      "name": "build.show_progress",
      "type": "bool",
      "value": true
    },
    {
      "name": "build.verbosity",
      "type": "uint64",
      "value": 1
    },
    ...
  ],
  "scopes": [
    {
      "out_path": "/tmp/hello-gcc",
      "scopes": [
        {
          "out_path": "hello",
          "src_path": "/tmp/hello",
          "scopes": [
            {
              "out_path": "hello",
              "src_path": "/tmp/hello/hello",
              "variables": [
                {
                  "name": "out_base",
                  "type": "dir_path",
                  "value": "/tmp/hello-gcc/hello/hello")WR(
                },
                {
                  "name": "src_base",
                  "type": "dir_path",
                  "value": "/tmp/hello/hello"
                },
                {
                  "name": "cxx.poptions",
                  "type": "strings",
                  "value": [
                    "-I/tmp/hello-gcc/hello",
                    "-I/tmp/hello"
                  ]
                },
                {
                  "name": "libs",
                  "value": "/tmp/hello-gcc/libhello/libhello/lib{hello}"
                }
              ]
            }
          ]
        }
      ]
    }
  ]
})RP(

  )0 P(The )SM(type)ES( member is absent if the vari)HY(able)YH( value is
  untyped.)EP(

  )0 P(The )SM(value)ES( member contains the vari)HY(able)YH( value in a suit)HY(able)YH(
  JSON repre)HY(sen)HY(ta)HY(tion)YH(. Specif)HY(i)HY(cally)YH(:)EP(

  )UL(  )-1 LI()SM(null)ES( values are repre)HY(sented)YH( as JSON )SM(null)ES(.

  )-1 LI()SM(bool)ES( values are repre)HY(sented)YH( as JSON
  )SM(boolean)ES(.

  )-1 LI()SM(int64)ES( and )SM(uint64)ES( values are repre)HY(sented)YH( as
  JSON )SM(number)ES(.

  )-1 LI()SM(string)ES(, )SM(path)ES(, )SM(dir_path)ES( values are
  repre)HY(sented)YH( as JSON )SM(string)ES(.

  )-1 LI(Untyped simple name values are repre)HY(sented)YH( as JSON
  )SM(string)ES(.

  )-1 LI(Pairs of above values are repre)HY(sented)YH( as JSON objects with the
  )SM(first)ES( and )SM(second)ES( members corre)HY(spond)HY(ing)YH( to the pair
  elements.

  )-1 LI(Untyped complex name values are seri)HY(al)HY(ized)YH( as target names and
  repre)HY(sented)YH( as JSON )SM(string)ES(.

  )-1 LI(Contain)HY(ers)YH( of above values are repre)HY(sented)YH( as JSON arrays corre)HY(spond)HY(ing)YH(
  to the container elements.

  )-1 LI(An empty value is repre)HY(sented)YH( as an empty JSON object if it's a typed
  pair, as an empty JSON array if it's a typed container or is untyped, and as
  an empty string other)HY(wise)YH(.
  )LU(

  )0 P(One expected use-case for the match dump is to deter)HY(mine)YH( the set of
  targets for which a given action is appli)HY(ca)HY(ble)YH(. For example, we may want to
  deter)HY(mine)YH( all the executa)HY(bles)YH( in a project that can be tested with the
  )SM(test)ES( oper)HY(a)HY(tion)YH( in order to present this list to the user in an
  IDE plugin or some such. To further illu)HY(mi)HY(nate)YH( the problem, consider the
  follow)HY(ing)YH( )SM(build)HY(file)YH()ES( which declares a number of executable
  targets, some are tests and some are not:)EP(

  ) 8 70 PR(exe{hello1}: ... testscript # Test because of testscript prerequisite.

exe{hello2}: test = true    # Test because of test=true.

exe{hello3}: ... testscript # Not a test because of test=false.
{
  test = false
})RP(

  )0 P(As can be seen, trying to infer this infor)HY(ma)HY(tion)YH( is not straight)HY(for)HY(ward)YH(
  and doing so manu)HY(ally)YH( by exam)HY(in)HY(ing)YH( prereq)HY(ui)HY(sites)YH(, vari)HY(ables)YH(, etc., while
  possi)HY(ble)YH(, will be complex and likely brittle. Instead, the recom)HY(mended)YH(
  approach is to use the match dump and base the deci)HY(sion)YH( on the
  )SM(state)ES( target object member. Specif)HY(i)HY(cally)YH(, a rule which matched
  the target but deter)HY(mined)YH( that nothing needs to be done for this target,
  returns the special )SM(noop)ES( recipe. The )SM(build2)ES( core
  recog)HY(nizes)YH( this situ)HY(a)HY(tion)YH( and sets such target's state to
  )SM(unchanged)ES( during match. Here is what the match dump will look
  like for the above three executa)HY(bles)YH(:)EP(

  ) 34 58 PR($ b --match-only --dump=match --dump-format=json-v0.1 test
{
  "out_path": "hello",
  "src_path": "/tmp/hello/hello",
  "targets": [
    {
      "name": "exe{hello1.}",
      "display_name": "exe{hello1}",
      "type": "exe",
      "path": "/tmp/hello-gcc/hello/hello/hello1",
      "inner_operation": {
        "rule": "test"
      }
    },
    {
      "name": "exe{hello2.}",
      "display_name": "exe{hello2}",
      "type": "exe",
      "path": "/tmp/hello-gcc/hello/hello/hello2",
      "inner_operation": {
        "rule": "test"
      }
    },
    {
      "name": "exe{hello3}",
      "display_name": "exe{hello3}",
      "type": "exe",
      "inner_operation": {
        "rule": "test",
        "state": "unchanged"
      })WR(
    }
  ]
})RP(

)BR(

)WB NL
/TE t D NP /OU t D TU PM 1 eq and{/Pn () D showpage}if end restore
