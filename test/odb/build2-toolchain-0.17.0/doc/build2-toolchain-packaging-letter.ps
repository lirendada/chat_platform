%!PS
%%Title: The build2 Packaging Guide
%%Creator: html2ps version 1.0 beta7
%%EndComments
save
2000 dict begin
/d {bind def} bind def
/D {def} d
/t true D
/f false D
/FL [/Times-Roman
/Times-Italic
/Times-Bold
/Times-BoldItalic
/Courier
/Courier-Oblique
/Courier-Bold
/Courier-BoldOblique
/Helvetica
/Helvetica-Oblique
/Helvetica-Bold
/Helvetica-BoldOblique] D
/WF t D
/WI 0 D
/F 1 D
/IW 471 F div D
/IL 621 F div D
/PS 791 D
/EF [0 1 0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 0 2 2] D
/EZ [12 9 19 17 15 13 12 11 12 12 12 12 12 12 12 12 12 12 12 12 12 12 8 8] D
/Ey [0 0 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] D
/EG [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1] D
/Tm [1 1 0.8 0.8 0.8 0.8 0.8 0.8 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1.3 0 0] D
/Bm [1 1 0.5 0.5 0.5 0.5 0.5 0.5 0 0 0 0 0 0 0.5 1 1 1 1 0 0 1 0 0] D
/Lm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 2 0 0 2 0 0 0] D
/Rm [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0] D
/EU [-1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 0 0] D
/NO f D
/YY [[{()}{ h }][{ h }{()}][{()}{()}]] D
/ZZ [[{ (Revision ) ME 0 get join(, June 2024)join }{ Pn }][{ Pn }{ (Revision ) ME 0 get join(, June 2024)join }][{ Ti }{ Ti }]] D
/Ts EZ 0 get D
/TU f D
/Xp t D
/AU f D
/SN 0 D
/Cf t D
/Tp t D
/Fe f D
/TI 2 Ts mul D
/Fm 14 D
/xL 71 D
/xR 71 D
/yL 706 D
/yR 706 D
/Wl 471 F div D
/Wr 471 F div D
/hL 621 F div D
/hR 621 F div D
/FE {newpath Fm neg Fm M CP BB IW Fm add Fm L IW Fm add IL Fm add neg L CP BB
 Fm neg IL Fm add neg L closepath} D
/LA {PM 0 eq{/IW Wl D /IL hL D}{/IW Wr D /IL hR D}ie /W IW D /LL W D /LS W D
 TU PM 0 eq and{IW 56 F div add SA{Sf div}if 0 translate}
 {PM 0 eq{xL yL}{xR yR}ie translate F SA{Sf mul}if dup scale
 CS CF FS Cf{CA CL get VC}if /Bb f D}ie 0 0 M
 TF not Tc or {Cf{gsave SA{1 Sf div dup scale}if Cb VC FE fill grestore}if}if}D
/Pi 0 Ts mul D
/SG [0.8 1 1] D
/Ab 15 D
/J 0 D
/Tc t D
/NH 6 D
/Nf f D
/Pa f D
/LH 1.2 D
/XR f D
/Xr {/pN E D ( [p ) WB pN WB (] )WB} D
/Db [16#FF 16#FF 16#FF] D
/Dt [16#00 16#00 16#00] D
/eA f D
/Fi f D
/bT f D
/Lc t D
/Dl [16#00 16#00 16#00] D
/LX f D
/Br 0.25 D
/IA ([IMAGE]) D
/DS {/PF f D()WB NL NP()pop RC ZF} D
/Gb f D
/Mb t D
/Hc [16#00 16#00 16#00] D
/Bl 3 D
/MI -15.6 D
/DX (DRAFT) D
/Di 0 D
/Tt 113.385826771654 D
/Th { (
) 2 Al()BR (
  ) 0 1 -1 H()4 FZ (The ) SM (build2) ES ( ) ME 1 get join ES()EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
  ) 0 1 -1 H ( ) EH (
) Ea()BR (
  ) 0 P (Copyright © ) ME 2 get join(.)join BR (  Permission is granted to copy, distribute and/or modify this document under
  the terms of the MIT License.) EP (

  ) 0 P (Revision ) SM() ME 0 get join ES (, June 2024) BR (  This revision of the document describes the ) SM (build2) ES ( ) ME 3 get join(
  )join SM() ME 0 get join(.x)join ES ( series.) EP()} D
/tH {()0 1 -1 H (Table of Contents) EH()} D
/FD 2 D
/Dy 2 D
/cD [16#F0 16#F0 16#F0] D
/FW 0.6 D
/FU [16#00 16#00 16#00] D
/ET {/RM f D /A0 3 D /PN SN D /OU t D /Ou t D /W IW D /LL W D D1
 Ms not TP and{Ip}if /TF f D} D

%-- End of variable part --
/MySymbol 10 dict dup begin
 /FontType 3 D /FontMatrix [.001 0 0 .001 0 0 ] D /FontBBox [25 -10 600 600] D
 /Encoding 256 array D 0 1 255{Encoding exch /.notdef put}for
 Encoding (e) 0 get /euro put
 /Metrics 2 dict D Metrics begin
  /.notdef 0 D
  /euro 651 D
 end
 /BBox 2 dict D BBox begin
  /.notdef [0 0 0 0] D
  /euro [25 -10 600 600] D
 end
 /CharacterDefs 2 dict D CharacterDefs begin
  /.notdef {} D
  /euro{newpath 114 600 moveto 631 600 lineto 464 200 lineto 573 200 lineto
   573 0 lineto -94 0 lineto 31 300 lineto -10 300 lineto closepath clip
   50 setlinewidth newpath 656 300 moveto 381 300 275 0 360 arc stroke
   -19 350 moveto 600 0 rlineto -19 250 moveto 600 0 rlineto stroke}d
 end
 /BuildChar{0 begin
  /char E D /fontdict E D /charname fontdict /Encoding get char get D
  fontdict begin
   Metrics charname get 0 BBox charname get aload pop setcachedevice
   CharacterDefs charname get exec
  end
 end}D
 /BuildChar load 0 3 dict put /UniqueID 1 D
end
definefont pop

/Cd {aload length 2 idiv dup dict begin {D} repeat currentdict end} D
/EX {EC cvx exec} D
/DU {} d
/BB {pop pop}d
/ie {ifelse} d
/E {exch} d
/M {moveto} d
/R {rmoveto} d
/L {lineto} d
/RL {rlineto} d
/CP {currentpoint} d
/SW {stringwidth} d
/GI {getinterval} d
/PI {putinterval} d
/Sg {setgray} d
/LW {setlinewidth} d
/S {dup () ne OU and{0 Co R AT 3 eq LB and HF not and A1 0 ne A2 0 ne or and
 {A2 0 32 A1 0 6 -1 roll awidthshow}{show}ie 0 Co neg R}{pop}ie
 OU PH 3 eq or{/Ms t D}if} D
/U {OU{gsave CP currentfont /FontInfo get /UnderlinePosition get
 0 E currentfont /FontMatrix get dtransform E pop add newpath M dup SW pop
 CJ 0 RL stroke grestore}if} D
/B {OU Br 0 gt and{CP Ts neg Ts .33 mul R gsave 0 Sg
 CP newpath Ts Br mul 0 360 arc closepath UI 2 mod 0 eq{stroke}{fill}ie
 grestore M CP E Ts Br 1 add mul sub E BB /Ms t D}if}D
/NP {Ms TP not or PA and OU and{TP{OR}if f1{mF k2 /mF E D /YC 0 D}if
 TP TU not PM 0 eq or and{showpage}if DU Ip TE not{LA}if 0.6 LW
 /CI 0 D /TP t D /Hs f D /hl 6 D /Hv 6 D /HI hi D /Ms f D}if Bs XO BO M} D
/Np {LE sub CP E pop gt PL 0 eq and{NP}if}D
/Ip {/PN PN 1 add D /Pn RM{1}{4}ie PN Ns D /PM PN SN sub 2 mod D} D
/GP {E dup 3 -1 roll get PN 1 add 2 mod get dup type /integertype eq
 {get 0 get}{E pop}ie}d
/Fc {dup 2 GP exec SW pop /S1 E D dup 1 GP exec SW pop /S2 E D 0 GP exec SW
 pop /S3 E D S1 0 gt{S2 2 mul S1 add S3 2 mul S1 add 2 copy lt{E}if pop}{0}ie
 S2 S3 add 2 copy lt{E}if pop IW .9 mul div dup 1 gt{1 E div}{pop 1}ie}D
/OR {Df{Sd}if tp not{gsave SA{1 Sf div dup scale}if Fe{Cf{FU VC}if FW LW
 1 setlinejoin FE stroke}if /YO {60 F div dup 40 gt{pop 40}if}D /cs CS D
 /cf CF D /CF 0 D /pf PF D /PF f D /Fn FN D /At AT D /AT 0 D /FN EF Hf 1 add
 get D Fz Fs FS ZZ Fc Fz mul Fs FS EU Hf 1 add get dup type /arraytype eq
 Cf and{VC}{pop 0 Sg}ie IW IL neg YO sub M ZZ 1 GP exec dup SW pop neg 0 R Sh
 0 IL neg YO sub M ZZ 0 GP exec Sh ZZ 2 GP exec dup SW pop IW E sub 2 div
 IL neg YO sub M Sh Fz Fs FS NO{/AW IW Pn SW pop sub D AW 2 div IL neg YO sub
 S1 0 gt S2 AW .45 mul gt or S3 AW .45 mul gt or{Fz 2 mul sub}if M Pn Sh}if
 EU Hf get dup type /arraytype eq Cf and{VC}{pop 0 Sg}ie YY Fc /FN EF Hf get D
 Hz mul HS FS IW YO M YY 1 GP exec dup SW pop neg 0 R Sh 0 YO M YY 0 GP exec Sh
 YY 2 GP exec dup SW pop IW E sub 2 div YO M Sh /FN Fn D /AT At D t Pb XO SZ
 SL get neg R /PF pf D grestore /CF 0 D cs cf FS}if}D
/Sh {dup () ne{CP Hz 4 div sub BB show CP CS add BB}{pop}ie}D
/Pb {/OU E D /Ou OU D /PB t D 0 0 M Ba{/Sa save D /BP t D /Fl t D RC /PL 0 D
 /PH 0 D /W IW D /LE IL .7 mul D /EO 0 D SI ZF /YA 0 D /BO 0 D /C1 () D
 BA 0 Ts neg R Bb{Xl Yl Xh Yh}if Bb CP Sa restore M
 {/Yh E D /Xh E D /Yl E D /Xl E D}if /Fl t D}if
 BL /OU t D /HM f D /Ou t D /PB f D} D
/Bs {/BP Ba not D}D
/reencodeISO {
 dup dup findfont dup length dict begin{1 index /FID ne{D}{pop pop}ie}forall
 /Encoding ISOLatin1Encoding D currentdict end definefont} D
/ISOLatin1Encoding [
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/space/exclam/quotedbl/numbersign/dollar/percent/ampersand/quoteright
/parenleft/parenright/asterisk/plus/comma/hyphen/period/slash
/zero/one/two/three/four/five/six/seven/eight/nine/colon/semicolon
/less/equal/greater/question/at/A/B/C/D/E/F/G/H/I/J/K/L/M/N
/O/P/Q/R/S/T/U/V/W/X/Y/Z/bracketleft/backslash/bracketright
/asciicircum/underscore/quoteleft/a/b/c/d/e/f/g/h/i/j/k/l/m
/n/o/p/q/r/s/t/u/v/w/x/y/z/braceleft/bar/braceright/asciitilde
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef/.notdef
/.notdef/space/exclamdown/cent/sterling/currency/yen/brokenbar
/section/dieresis/copyright/ordfeminine/guillemotleft/logicalnot
/hyphen/registered/macron/degree/plusminus/twosuperior/threesuperior
/acute/mu/paragraph/periodcentered/cedilla/onesuperior/ordmasculine
/guillemotright/onequarter/onehalf/threequarters/questiondown
/Agrave/Aacute/Acircumflex/Atilde/Adieresis/Aring/AE/Ccedilla
/Egrave/Eacute/Ecircumflex/Edieresis/Igrave/Iacute/Icircumflex
/Idieresis/Eth/Ntilde/Ograve/Oacute/Ocircumflex/Otilde/Odieresis
/multiply/Oslash/Ugrave/Uacute/Ucircumflex/Udieresis/Yacute
/Thorn/germandbls/agrave/aacute/acircumflex/atilde/adieresis
/aring/ae/ccedilla/egrave/eacute/ecircumflex/edieresis/igrave
/iacute/icircumflex/idieresis/eth/ntilde/ograve/oacute/ocircumflex
/otilde/odieresis/divide/oslash/ugrave/uacute/ucircumflex/udieresis
/yacute/thorn/ydieresis
] D
[128/backslash 129/parenleft 130/parenright 141/circumflex 142/tilde
143/perthousand 144/dagger 145/daggerdbl 146/Ydieresis 147/scaron 148/Scaron
149/oe 150/OE 151/guilsinglleft 152/guilsinglright 153/quotesinglbase
154/quotedblbase 155/quotedblleft 156/quotedblright 157/endash 158/emdash
159/trademark]
aload length 2 idiv 1 1 3 -1 roll{pop ISOLatin1Encoding 3 1 roll put}for
/colorimage where{pop}{
 /colorimage {
  pop pop /Pr E D {/Cv Pr D /Gr Cv length 3 idiv string D 0 1 Gr length 1 sub
   {Gr E dup /i E 3 mul D Cv i get 0.299 mul Cv i 1 add get 0.587 mul add
    Cv i 2 add get 0.114 mul add cvi put}for Gr} image} D
}ie
/pdfmark where{pop}{userdict /pdfmark /cleartomark load put}ie
WF{FL{reencodeISO D}forall}{4 1 FL length 1 sub{FL E get reencodeISO D}for}ie
/Symbol dup dup findfont dup length dict begin
 {1 index /FID ne{D}{pop pop}ie}forall /Encoding [Encoding aload pop]
 dup 128 /therefore put D currentdict end definefont D

/SF {/CS E D SZ SL CS put FO SL FN put /YI CS LH neg mul D dup ST cvs ( ) join
 CS ST cvs join C1 E join ( NF ) join /C1 E D CS NF /Wf WF FN 0 gt or D
 /BW Wf{( ) SW pop}{0}ie D}D
/NF {/cS E D /cF E D cF 0 ge{FL cF get}{cF -1 eq{/Symbol}{/MySymbol}ie}ie
 findfont cS scalefont setfont} D
/FS {CF or /CF E D FR SL CF put CF CF 0 ge{FN 4 mul add}if E SF} D
/PC {SH /BP f D fin not GL not and{NL}if /HM t D /LL LS D} D
/BS {/TX E D Wf{/fin f D /CW 0 D /LK 0 D /SC 0 D
 /RT TX D {RT ( ) search{/NW E D pop /RT E D /WH NW SW pop D CW WH add LL gt
 {TX SC LK SC sub 1 sub NN GI GL{SH cF cS OC
 2 copy cS ne E cF ne or{NF}{pop pop}ie}{PC /CW WH BW add D}ie
 /SC LK D}
 {GL{JC}if
 /CW CW WH add BW add D /HM t D}ie /GL f D /Ph f D
 /LK LK NW length 1 add add D}{pop exit}ie}loop
 /fin t D TX SC LK SC sub GI SH RT () ne{GL not{CC}if}if
 /LC TX length D /WH RT SW pop D CW WH add Hy{HC SW pop add}if LL gt
 {RT GL{SH cF cS OC 2 copy cS ne E cF ne or{NF}{pop pop}ie
 Hy{/Ph t D}if /LL LS D}{NL /LL LS D SH}ie}
 {RT PC Hy{CC}if /Ph Ph Hy or D}ie RT () ne{/GL t D /HM t D}if}
 {TX SW pop LL le{TX SH}{/NW () D 0 2 TX length 1 sub
 {/CW E D TX 0 CW GI dup SW pop LL gt{pop NW SH /HM t D NL/LL W XO sub MR sub D
 /CW CW 2 sub NN D /TX TX CW TX length CW sub GI D TX BS exit}
 {/NW E D}ie}for}ie}ie /HM t D}D
/CC {C0 length 0 gt{JC}if /C0 [C1 L1 YA YB Mf NS NB TB AF Bw] D
 /C1 () D /L0 L1 D /YA 0 D /YB 0 D /Mf 0 D /NS 0 D /NB 0 D}D
/JC {C0 aload length 0 gt{pop pop pop NB add /NB E D NS add /NS E D
 dup Mf gt{/Mf E D}{pop}ie dup YB gt{/YB E D}{pop}ie
 dup YA gt{/YA E D}{pop}ie pop C1 join /C1 E D /C0 [] D}if}D
/OC {C0 length 0 gt{C1 L1 L0 sub YA YB Mf NS NB TB AF Bw GL C0 aload pop
 /Bw E D /AF E D /TB E D /NB E D /NS E D /Mf E D /YB E D /YA E D /C0 [] D
 /L1 E D /C1 E D Ph{HC SH}if NL /GL E D /Bw E D /AF E D /TB E D /NB E D /NS E D
 /Mf E D /YB E D /YA E D /L1 E D /LL W L1 sub XO sub MR sub WH sub D /CW 0 D
 C1 E join /C1 E D}if}D
/BT {/LB t D dup length string copy RS dup dup () ne E ( ) ne and
 {/CI 0 D /LS LL D /LL W L1 sub XO sub MR sub D BS}
 {dup ( ) eq{/GL f D}if dup () eq L1 0 eq or{pop}{SH /BP f D /Ph f D}ie}ie
 /LB f D} D
/BL {CP E pop XO E M} D
/NL {JC /GL f D /SK W XO sub MR sub L1 sub TB{Bw add}if D
 /YA LF{Mf HM Fl not and PF or{LH mul}if}{0 /LF t D}ie YA 2 copy lt{E}if pop D
 C1 () ne{/FB YB Mf SA{Sf mul}if 4 div 2 copy lt{E}if pop D}if Fl{/Ya YA D}if
 CP E pop YA sub YB sub LE neg lt Fl not and PB not and{NP}if NT TL BL
 OU PF not and PB or{/RE L1 TB{Bw sub}if
 W XO sub MR sub div YA YB add LE BO add div 2 copy lt{E}if pop D
 RE 1 gt{BL 1 RE div dup scale}if}if
 AT 2 le{SK AT mul 2 div YA neg R}if
 AT 3 eq{0 YA neg R TB{/NB NB 1 sub D /NS NS 1 sub D}if /NB NB 1 sub NN D
 /A3 NS 6 mul NB add D NS NB add 0 eq
  {/A1 0 D /A2 0 D}
  {NS 0 eq{/A1 SK NB div dup J gt{pop 0}if D /A2 0 D}{J A3 mul SK lt
   {/A1 J D /A2 SK J NB mul sub NS div dup Ab gt{/A1 0 D pop 0}if D}
   {/A1 SK A3 div D /A2 A1 6 mul D}ie}ie}ie /A1 A1 NN D /A2 A2 NN D}if
 AT 4 eq{0 YA neg R PH 2 le{PD 0 lt{/PD L1 D}if PD M1 gt{/M1 PD D}if
 L1 PD sub M2 gt{/M2 L1 PD sub D}if}{DV ID 1 sub get 0 ge{Lo 0 R}if}ie}if
 F0 cF ne Cs cS ne or{F0 Cs NF}if
 /ms Ms D /Ms f D CP FB sub
 C1 cvx exec XO EO sub L1 add TB{BW sub}if dup LM gt{/LM E D}{pop}ie
 PH 0 eq PH 4 eq or Ms and{HF not{/PO t D /AH t D}if
 BB CP YA add E AT 3 eq LB and{A1 sub}if TB{BW sub}if E BB}
 {pop pop}ie Ms HM PH 3 eq and or{/BP f D /Fl f D}if
 /Lo 0 D /L1 0 D /F0 cF D /Cs cS D BP not{0 YB NN neg R}if
 OU f1 and mF not and{k2 /f1 f D}if
 OU PF not and PB or{RE 1 gt{RE dup scale}if}if /Ms ms Ms or D
 /C1 AF{(Cp )}{()}ie D /YA 0 D /YB 0 D BL
 AT 4 eq LB not and PH 3 ge and
 {ID DV length lt{DV ID get dup 0 ge{DO E sub /Lo E D /L1 Lo D}{pop}ie
 /ID ID 1 add D}if}if /T t D CD{/LN LN 1 add D PD}if
 /PD -1 D /NS 0 D /NB 0 D /TB f D /Ph f D /Mf 0 D /HM f D} D
/RS {/TM E D /CN 0 D TM{10 eq{TM CN ( ) PI}if /CN CN 1 add D}forall
 /CN 0 D /BK HM EN and{0}{1}ie D TM
 {dup 32 ne{TM CN 3 2 roll put /CN CN 1 add D /BK 0 D}
 {pop BK 0 eq{TM CN 32 put /CN CN 1 add D}if /BK 1 D}ie}forall
 TM 0 CN GI dup dup () ne E ( ) ne and
 {dup CN 1 sub get 32 eq{/EN f D}{/EN t D}ie}if} D
/join {2 copy length E length add string dup 4 2 roll 2 index 0 3 index
 PI E length E PI}d
/WR {(\n) search{dup () ne BP not or
 {Li 4 le CP E pop YI Li mul add LE add 0 lt and PL 0 eq and{NP}if
 SH NL pop /Li Li 1 sub D WR}{pop pop WR}ie}{SH}ie /CI 0 D /BP f D} D
/SH {dup dup () ne E ( ) ne and PF or CS Mf gt and{/Mf CS D}if
 T not Wf and{( ) E join /T t D}if dup BP{/MF CS D}if
 AT 3 eq{2 copy length dup 0 gt{/NB E NB add D
 {( ) search{/NS NS 1 add D pop pop}{pop exit}ie}loop}{pop pop}ie}if
 CD PD 0 lt and{dup DC search{SW pop /PD E L1 add D pop pop}{pop}ie}if
 0 Np dup SW pop L1 add /L1 E D dup () ne
 {C1 (\() join E join (\)) join AU AF and UF or Wf and{( U ) join}if
 sF{( s ) join}if ( S ) join
 /C1 E D dup length 1 sub get 32 eq /TB E D /Bw BW D}{pop pop}ie} D
/BG {AI LG BC add add 0 eq} D
/ON {OU{Ty AR AI NN get dup 1 add Ln Ns Ty 2 mod 0 eq{(.  )}{(\)  )}ie join
 dup SW pop neg 0 R CP E 0 lt{0 E M}{pop}ie CP BB show /Ms t D}if} D
/Ln {AR AI 3 -1 roll put}D
/SP {dup CI lt BP not and{dup CI sub 0 E R /CI E D}{pop}ie} D
/BN {PF{WR /HM f D}{BT NL}ie} D
/NN {dup 0 lt{pop 0}if} D
/h {(h) HI ST cvs join cvx exec dup 1 get E Nf{0 get E join}{pop}ie} D
/H {/fn FN D /Hi E 1 add D 1 sub /HL E D /H2 HL 2 add D /GS EZ H2 get D
 E Tm H2 get GS mul BE dup 0 gt{1 sub}{pop EG H2 get dup 0 lt{pop AT}if}ie NA
 WW Np /SL SL 1 add D /FN EF H2 get D GS Ey H2 get FS
 EU H2 get Sc Hs not HL Hl lt and Hs HL hl lt and or Hi 0 eq or
 {/HI Hi D /Hs t D /hl HL D /Hv HL D}if HL Hl lt{/hi Hi D}if
 Nf HI 0 gt and{(h) Hi ST cvs join cvx exec 0 get WB}if
 /HF t D /AH f D /PO f D} D
/EH {Bm H2 get GS mul BE OA /SL SL 1 sub NN D /CF 0 D /FN fn D
 SZ SL get FR SL get FS /HF f D /GS Ts D ()Ec} D
/P {E PF{WR}{PO{EP}{BN}ie Ts 4 mul Np AE not{Tm 0 get Ts mul neg SP}if
 dup 0 ge AH and{Pi Pd}if}ie 1 sub dup 0 lt{pop AV AL get}if /AT E D /PO t D} D
/EP {PF{WR}{BN Ts 4 mul Np}ie AE not{Bm 0 get Ts mul neg SP}if
 /AT AV AL get D /PO f D} D
/BE {E PO{EP}{BN}ie Ts 4 mul Np neg SP} D
/HR {/Aw W EO sub D /RW E dup 0 gt{Aw mul}{neg}ie dup Aw gt{pop Aw}if D /RZ E D
 E BN Ts neg SP 1 sub 2 div Aw RW sub mul EO add CP E pop M PF{0 Ps neg R}if
 0 Np OU{gsave RZ LW Cf{Hc VC}{0 Sg}ie CP BB RW 0 RL CP BB stroke grestore}if
 /CI 0 D /BP f D PF not{Ts neg SP}if /Ms t D} D
/AD {I NL EG 14 get dup 0 lt{pop AT}if NA /AE t D Tm 14 get Ts mul neg SP
 Cf{EU 14 get dup -1 eq{pop CA CL get}if Sc}if} D
/DA {BN ()ES OA /AE f D ()Ec Bm 14 get Ts mul neg SP} D
/PR {/MW E D /Li E D Tm 1 get Ps mul BE 0 NA /FN Fp D /PF t D SI /SL SL 1 add D
 /CF 0 D Ps CS mul Ts div MW WC mul CS mul Ts div dup LL gt PL 0 eq and
 {LL div div}{pop}ie Ey 1 get FS CP E pop LE add YI neg div cvi dup Li lt
 AH and{4 lt YI Li mul 5 mul LE add 0 gt or PL 0 eq and{NP}if}{pop}ie
 EU 1 get Sc /GS Ps D}D
/RP {WR NL () /PF f D SI /FN 0 D ES Bm 1 get Ps mul neg SP OA /GS Ts D} D
/SI {/XO Lm 15 get BC NN mul Lm 16 get AI UI sub NN mul add
 Lm 17 get UI NN mul add Lm 20 get LG NN mul add Ts mul
 PF{Lm 1 get Ps mul add}if EO add D
 /MR Rm 15 get BC NN mul Rm 16 get AI UI sub NN mul add
 Rm 17 get UI NN mul add Rm 20 get LG NN mul add Ts mul
 PF{Rm 1 get Ps mul add}if D /LL W XO sub MR sub D} D
/DT {/cC E D BN /LG LG 1 sub D SI /LG LG 1 add D WW 2 div Np BL} D
/DD {WB Cc 0 eq cC 0 eq and L1 0 eq or Lm 20 get Ts mul L1 sub TB{BW add}if
 Ts 2 div lt or NL /LF E D SI BL /cC 0 D} D
/DL {Dc LG Cc put /Cc E D BG{Tm 18 get Ts mul BE}{BN}ie /LG LG 1 add D BL} D
/LD {BN LG 0 gt{/LG LG 1 sub D}if /Cc Dc LG get D SI
 BG{()Bm 18 get Ts mul BE}if BL} D
/UL {BG{Tm 17 get Ts mul BE}{BN}ie NR AI NN 0 put /UI UI 1 add D
 /AI AI 1 add D SI BL} D
/LU {BN /UI UI 1 sub D /AI AI 1 sub D SI BG{()Bm 17 get Ts mul BE}if BL} D
/OL {E BG{Tm 16 get Ts mul BE}{BN}ie TR AI NN Ty put /Ty E D NR AI NN 1 put
 /AI AI 1 add D SI BL 1 Ln} D
/LO {BN /AI AI 1 sub D /Ty TR AI get D SI BG{()Bm 16 get Ts mul BE}if BL} D
/LI {E BN -1 SP /BP f D /CI 0 D 0 Np NR AI 1 sub NN get 1 eq
 {dup dup 0 gt E 4 le and{/Ty E D}{pop}ie
 /L1 L1 Ty AR AI NN get Ns SW pop XO sub dup 0 lt{pop 0}if add D ( ON )}
 {pop ( B )}ie C1 E join /C1 E D CS Mf gt{/Mf CS D}if BL} D
/BQ {Tm 15 get Ts mul BE /BC BC 1 add D SI BL} D
/QB {Bm 15 get Ts mul BE /BC BC 1 sub D SI BL} D
/Al {E EP 1 sub dup 0 lt{pop AV AL get}if NA} D
/Ea {EP OA} D
/WB {PF{WR}{BT}ie} D
/F1 {WB /FN 0 D CS 0 FS} D
/F2 {WB /FN WI D CS 0 FS} D
/HY {/Hy t D WB /Hy f D} D
/YH {WB} D
/A {/LT E D LT 1 eq{/RN E D}if /Lh E D WB /C1 C1 ( Cp ) join D
 Lc AF not and{Cl Sc}if /AF t D} D
/EA {Lc AF and{Ec}{WB}ie TL Pa AF and Lh 0 ne and
 {( \() Lh join (\)) join /AF f D WB}if /AF f D} D
/TL {C1 ( Tl ) apa /C1 E D} d
/apa {AF OU and Lh 0 ne LT 1 eq or and{LT 1 eq{RN ( /) E ST cvs join}
 {(\() Lh join (\)) join}ie E join join}{pop}ie} d
/Cp {/Xc CP /Yc E D D} D
/SS {Cf{dup 0 ge{EU E get dup -1 eq{pop CA CL get}if}{pop CA CL get}ie Sc}
 {pop}ie SZ SL get /SL SL 1 add D} D
/I {WB 8 SS 1 FS} D
/EM {WB 8 SS /CF CF 1 xor D 0 FS} D
/BD {WB 9 SS 2 FS} D
/TT {WB 10 SS /FN Fp D 0 FS} D
/KB {WB 11 SS /FN Fp D 2 FS} D
/CT {WB 12 SS 1 FS} D
/SM {WB 13 SS /FN Fp D 0 FS} D
/Q {/QL QL 1 add D QO QL 2 mod get La get join WB} D
/EQ {QC QL 2 mod get La get join WB /QL QL 1 sub D} D
/RO {WB -1 SS /CF 0 D 0 FS} D
/SY {WB -1 SS -1 FS} D
/MY {WB -1 SS -2 FS} D
/ES {WB /SL SL 1 sub NN D /CF 0 D /FN FO SL get D SZ SL get FR SL get FS ()Ec}D
/FZ {3 sub 1.2 E exp GS mul E WB TL /C1 C1 ( Cp ) join D /SL SL 1 add D 0 FS} D
/Ef {WB TL ()ES /C1 C1 ( Cp ) join D} D
/BZ {dup /Bf E D FZ}D
/Sc {dup -1 ne Cf and{/CL CL 1 add D dup 0 eq{pop [0 0 0]}if
 dup CA E CL E put VS ( VC ) join C1 E join /C1 E D}{pop}ie} D
/Ec {WB Cf{/CL CL 1 sub NN D CA CL get VS ( VC ) join C1 E join /C1 E D}if} D
/VS {dup type /arraytype eq{([) E {ST cvs join ( ) join}forall (]) join}if} D
/VC {{255 div}forall setrgbcolor} D
/Sl {dup type /integertype ne{Ds}if /La E D WB}d
/UN {WB /UF t D} D
/NU {WB /UF f D} D
/SE {WB /sF t D} D
/XE {WB /sF f D} D
/sM {/C1 C1 ( k1 ) join D}d
/eM {/C1 C1 ( k2 ) join D}d
/k1 {/YC CP E pop Ts add D /mF t D /f1 t D}d
/k2 {gsave 3 LW -9 CP E pop Ts 0.2 mul sub M -9 YC L stroke grestore /mF f D}d
/Ac {/AC E D WB}d
/Ca {eA{( \()join AC join(\) )join}if WB}d
/s {OU{gsave 0 CS .25 mul R dup SW pop CJ 0 RL stroke grestore}if}D
/CJ {AT 3 eq LB and{E dup dup length 1 sub A1 mul E
 {( ) search{pop pop E A2 add E}{pop exit}ie}loop 3 -1 roll add
 W CP pop sub 2 copy gt{E}if pop}if}D
/So {/Co E D} D
/SO {C1 Yo ST cvs join ( So ) join /C1 E D (j) SW pop 2 div Pd} D
/Se {E WB CS E div Pd}D
/Pd {dup type /stringtype eq{SW pop}if dup /L1 E L1 add D
 ST cvs ( 0 R ) join C1 E join /C1 E D} D
/Sp {0.35 CO} D
/Sb {-0.2 CO} D
/CO {OV Io Yo put /Yo E CS mul Yo add D /Io Io 1 add D -1.5 Io mul 3 add FZ SO
 CS Yo add dup YA gt{/YA E D}{pop}ie
 Yo neg dup YB gt{/YB E D}{pop}ie} D
/Es {ES /Io Io 1 sub NN D /Yo OV Io get D SO} D
/SB {/N2 0 D 0 1 NI{/N E D{IX N2 get 0 lt{/N2 N2 1 add D}{exit}ie}loop
 /K WS N get FC N get mul D /NY AY N2 get D /BV NY array D
 0 1 NY 1 sub{/TM K string D currentfile TM readhexstring pop pop BV E TM put}
 for BM N BV put /N2 N2 1 add D}for} D
/IC [{/MA E D /MB 0 D}{2 div /MA E D /MB MA D}{/MB E CS sub D /MA CS D}
 {pop /MA YS AB mul D /MB 1 AB sub YS mul D}{pop /MA 0 D /MB 0 D}] D
/IP {BV N get /N N 1 add D} D
/II {/K E D IX K get 0 lt{/EC E D}if /TY E D
 TY 4 eq{/Y E D /X E D}if TY 3 eq{/AB E D}if
 /XW AX K get D /YW AY K get D /IS SG IT K get get D /XS XW IS mul D
 /YS YW IS mul D YS IC TY get exec /MA MA Fl not{3 add}if D} D
/IM {II /ty TY D /xs XS D /ys YS D /ya YA D /yb YB D /ma MA D /mb MB D /k K D
 /ec EC D /BP f D /CI 0 D WB TL L1 xs add dup XO add MR add W gt
 {pop /ma ma Fl{3 add}if D NL /YA ma D /YB mb D /YS ys D /L1 xs D}
 {/L1 E D ma YA gt{/YA ma D}if mb YB gt{/YB mb D}if}ie /TB f D
 OU{CP E pop YS sub LE neg lt Fl not and PB not and{NP /YA ma D /YB mb D}if
 /BP f D ty ST cvs ( ) join IX k get 0 lt{(\() join ec join (\) ) join}if
 k ST cvs join ty 3 eq{AB ST cvs ( ) join E join}if
 ty 4 eq{X ST cvs ( ) join Y ST cvs join ( ) join E join}if C1 E join
 ( DI ) join FP 2 eq FP 1 eq AF and or{( FM ) join}if
 ( Il Cp ) apa /C1 E D /EN f D}if /HM t D /T f D} D
/DI {II /Xc CP /Yc E D D /YN YW neg D /HM t D /CI 0 D /K2 IX K get D gsave
 TY 4 eq{OX X IS mul add OY FY add YS sub Y IS mul sub}
 {/FY YS D CP MB sub 2 copy /OY E D /OX E D}ie
 translate K2 0 ge{/DP AZ K2 get D /BV BM K2 get D XS YS scale /N 0 D XW YW DP
 [XW 0 0 YN 0 YW] {IP} FC K2 get 1 eq{image}{f 3 colorimage}ie}
 {EX}ie grestore XS 0 R /Ms t D} D
/FM {gsave 0 Sg CP MB sub translate XS neg 0 M 0 YS RL XS 0 RL 0 YS neg RL
 XS neg 0 RL stroke grestore} D
/NA {/AT E D /AL AL 1 add D AV AL AT put} D
/OA {AL 0 gt{/AL AL 1 sub D /AT AV AL get D}if} D
/D1 {/BR {CP E pop E BN Mb{CP E pop eq{0 YI R}if}{pop}ie} D
 /Sn {OU{C1 E ST cvs join ( Ld ) join /C1 E D}{pop}ie} D} D
/D1 {/BR {BN} D /Sn {OU {C1 E ST cvs join ( Ld ) join /C1 E D} {pop} ie} D} D
/TC {/TF t D /ML 0 D HN{SW pop dup ML gt{/ML E D}{pop}ie}forall NP /RM RM not D
 RC /OU Tc D Ep /PN 0 D Ms not TP and{Ip}if /W IW ML sub Ts sub D
 /A0 0 D TH{/BR {( ) join BT} D /Sn {pop} D /Au () D}if} D
/TN {0 eq{E EA PF HF or not XR and{HN E get Xr}{pop}ie}
 {OU{Tn 0 ge{() BN}if /Tn E D}{pop}ie WB}ie} D
/NT {OU LB not and Tn 0 ge and{PL 0 eq{Ms not{CS CF FS}if CP dup
 /y E YA sub D W 9 sub CS -1.8 mul XO L1 add 2 add{y M (.) show}for
 HN Tn get dup SW pop IW E sub y M show CP BB M}if /Tn -1 D}if} D
/Ld {/DN E D HN DN Pn put [/View [/XYZ -4 Fl{PS}{CP YA add US E pop}ie null]
 /Dest DN ST cvs cvn /DEST pdfmark} D
/C {ND 1 eq{1 sub}if TI mul /XO E D NL Nf not{pop()}if 0 3 -1 roll 1 A} D
/OP {BP not{NP}if PN 2 mod 0 eq{/Ms t D NP}if}D
/Ep {Xp PN 2 mod 0 eq and OU and{/Pn (-) D showpage /PM 1 D LA}if}D
/Dg [73 86 88 76 67 68 77] D
/Rd [0 [1 1 0][2 1 0][3 1 0][2 1 1][1 1 1][2 2 1][3 3 1][4 4 1][2 1 2]] D
/Ns {/m E D /c E 32 mul D /j m 1000 idiv D /p j 12 add string D
 c 96 le m 0 gt and{c 32 le {/i 0 D /d 77 D /l 100 D /m m j 1000 mul sub D
  j -1 1 {pop p i d c add put /i i 1 add D}for
  4 -2 0 {/j E D /n m l idiv D /m m n l mul sub D /d Dg j get D
   n 0 gt {/x Rd n get D x 0 get -1 1 {pop p i d c add put /i i 1 add D}for
   p i x 1 get sub Dg x 2 get j add get c add put}if /l l 10 idiv D
  }for p 0 i GI}
  {/i ST length 1 sub D m {1 sub dup 0 ge{dup 26 mod c add 1 add
   ST i 3 -1 roll put 26 idiv dup 0 eq{pop exit}if}if /i i 1 sub D}loop
   ST i ST length i sub GI}ie}
 {m p cvs}ie} D
/US {matrix currentmatrix matrix defaultmatrix matrix invertmatrix
 matrix concatmatrix transform} D
/GB {Gb{US}if}D
/Tl {/Rn E D Xc CP pop ne{
 [/Rect [Xc 1 sub Yc cS 0.25 mul sub GB CP E 1 add E cS 0.85 mul add GB]
  /Subtype /Link /Border [0 0 Cf Lc and LX and AU or{0}{1}ie] Rn type
  /nametype eq {/Dest Rn}{/Action [/Subtype /URI /URI Rn] Cd}ie
  /ANN pdfmark}if} D
/Il {/Rn E D [/Rect [Xc Yc GB Xc XS add Yc YS add GB] /Subtype /Link
 /Border [0 0 0] Rn type /nametype eq{/Dest Rn}
 {/Action [/Subtype /URI /URI Rn] Cd}ie /ANN pdfmark} D
/XP {[{/Z Bz 2 div D Z 0 R Z Z RL Z neg Z RL Z neg Z neg RL Z Z neg RL
 Fi cH 1 eq and{fill}if} {Bz 0 RL 0 Bz RL Bz neg 0 RL 0 Bz neg RL
 Fi cH 1 eq and{fill}if} {0 -5 R Bz 0 RL 0 21 RL Bz neg 0 RL 0 -21 RL}]} D
/MS {/Sm E D WB}D
/O {BN()0 Sm BX} D
/BX {/Bt E D Bt 2 lt{/Ch E D CS 0.8 mul}{11 mul}ie W XO sub MR sub
 2 copy gt{E}if pop /HZ E D Bt 2 eq{Fi not{pop()}if ( )E join /Ft E D TT
 /PF t D /MW 1 D /Li 1 D /Fw Ft SW pop D Fw HZ gt{/HZ Fw 8 add D}if
 HZ ST cvs( )join}{WB Ch ST cvs( )join}ie L1 HZ add XO add MR add W gt{NL}if
 Bt 2 eq{Ft ES Fw neg HM{CS sub}if Pd}if Bt ST cvs join( Bx )join
 Bt 2 eq HM and{CS Pd}if C1 E join /C1 E D /L1 L1 HZ add D /T f D
 ( ) Pd /PF f D Bt 2 lt{YA CS .8 mul lt{/YA CS .8 mul D}if}
 {YB 5 lt{/YB 5 D}if YA 21 lt{/YA 21 D}if}ie /CI 0 D} D
/Bx {dup 2 eq{E /Bz E D}{E /cH E D /Bz CS .8 mul D}ie
 OU {gsave 0 Sg XP E get exec stroke grestore}{pop}ie Bz 0 R /Ms t D}D
/SD {FD 4 mul Dy add DZ NF newpath 0 0 M DX t charpath pathbbox
 3 -1 roll sub /DY E D E dup /X1 E D sub WM mul WX DY mul add WM DG mul E div
 /DF E D /DR WX DF mul DY mul WM div 2 div D} d
/Sd {gsave 0 IL Di mul neg translate IL IW atan Di 0 eq{neg}if rotate
 FD 4 mul Dy add DZ NF DR X1 sub DY 2 div neg M cD VC DX show grestore} d
/Pt {/tp t D Tp{NP /Pn (TP) D 0 Tt neg R Th BN NP Ep ET RC ZF}if /tp f D} D
/RC {/AI 0 D /LG 0 D /BC 0 D /UI 0 D /PF f D /Cc 0 D /cC 0 D /Dc 10 array D
 /NR [0 1 9{pop 0}for] D /La Ds D /AR 10 array D /TR 10 array D /AV 30 array D
 SI /AL -1 D /AT A0 D AT NA /OV 9 array D /Yo 0 D /Co 0 D /Io 0 D /Hy f D
 /Ph f D /CL -1 D Ct Sc}D
/ZF {/FR [0 1 30{pop 0}for] D /SZ [0 1 30{pop 0}for] D /FO [0 1 30{pop 0}for] D
 /SL 0 D /CF 0 D /FN 0 D 0 Ts SF}D
/QO [[(\233)(\234)(\253)(\273)(\232)(\253\240)][(`)(')(\253)(\273)(\231)(\253\240)]] D
/QC [[(\234)(\234)(\273)(\253)(\233)(\240\273)][(')(')(\273)(\253)(`)(\240\273)]] D
/Hf EF length 2 sub D
/Hz EZ Hf get D
/HS Ey Hf get D
/Fz EZ Hf 1 add get D
/Fs Ey Hf 1 add get D
/LE IL D
/Ps EZ 1 get D
/Fp EF 1 get D
/XO 0 D
/YI 0 D
/CI 0 D
/FP 0 D
/WW Ts 7 mul D
/Mf 0 D
/YA 0 D
/YB 0 D
/Cs Ts D
/GS Ts D
/F0 0 D
/NS 0 D
/NB 0 D
/N 0 D
/C0 [] D
/C1 () D
/Lo 0 D
/L1 0 D
/LM 0 D
/PH 0 D
/EC 0 D
/Lh 0 D
/LT 0 D
/CH 1 string D
/ST 16 string D
/CA 9 array D
/HC (\255) D
/HM f D
/PF f D
/EN f D
/TB f D
/UF f D
/sF f D
/AE f D
/AF f D
/BP t D
/CD f D
/PA t D
/GL f D
/T t D
/HF f D
/AH f D
/SA f D
/PB f D
/f1 f D
/mF f D
/OX 0 D
/OY 0 D
/FY 0 D
/EO 0 D
/FB 0 D
/PL 0 D
/Bw 0 D
/PD -1 D
/TP f D
/tp f D
/TH t D
/Ty 4 D
/Tn -1 D
/Fl t D
/LB t D
/PM 1 D
/Ms f D
/Ba f D
/Bb f D
/Hl 3 D
/hl 6 D
/Hv 6 D
/Hs f D
/HI 0 D
/hi 0 D
/PO t D
/TE f D
/LF t D
/BO 0 D
/Sm 1 D
/Bf 3 D
/A1 0 D
/A2 0 D
/Ds 0 D
/QL -1 D
/Cb Db D
/Ct Dt D
/Cl Dl D
[/Creator (html2ps version 1.0 beta7) /Author () /Keywords () /Subject (toolchain)
 /Title (The build2 Packaging Guide) /DOCINFO pdfmark
/ND 1 D
/HN [(1) (1) (1) (1) (3) (3) (4) (4) (4) (4) (6) (7) (8) (8) (12) (15) (19)
(21) (23) (24) (24) (25) (28) (30) (30) (32) (32) (33) (35) (37) (38) (38)
(40) (43) (45) (45) (47) (48) (48) (49) (49) (50) (51) (52) (52) (53) (54)
(54) (56) (57) (57) (57) (58) (58) (59) (61) (62) (63) (64) (64) (64) (65)
(67) (67) (68) (68) (69) (70) (71) (72) (72) (73) (73) (74) (74) (74) (74)
(74) (75) (75) (75) (75) (75) (76) (76) (76) (77) (77) (77) (78) (79) (81)
(81) (81) (81) (82) (83) (84) (86) (87) (88) (89) (89) (90) (90) (91) (1)
(1) (3) (3) (4) (4) (4) (4) (6) (7) (8) (8) (12) (15) (19) (21) (23) (24)
(24) (25) (28) (30) (30) (32) (32) (33) (35) (37) (38) (38) (40) (43) (45)
(45) (47) (48) (48) (49) (49) (50) (51) (52) (52) (53) (54) (54) (56) (57)
(57) (57) (58) (58) (59) (61) (62) (63) (64) (64) (64) (65) (67) (67) (68)
(68) (69) (70) (71) (72) (72) (73) (73) (74) (74) (74) (74) (74) (75) (75)
(75) (75) (75) (76) (76) (76) (77) (77) (77) (78) (79) (81) (81) (81) (81)
(82) (83) (84) (86) (87) (88) (89) (89) (90) (90) (91)] D
/h0 [()(Table of Contents)] D
/h1 [(1\240\240)(Preface)] D
/h2 [(2\240\240)(1 Introduction)] D
/h3 [(2.1\240\240)(1.1 Terminology)] D
/h4 [(3\240\240)(2 Common Guidelines)] D
/h5 [(3.1\240\240)(2.1 Setup the package repository)] D
/h6 [(3.1.1\240\240)(2.1.1 Check if package repository already exists)] D
/h7 [(3.1.2\240\240)(2.1.2 Use upstream repository name as package repository name)] D
/h8 [(3.1.3\240\240)(2.1.3 Create package repository in personal workspace)] D
/h9 [(3.1.4\240\240)(2.1.4 Initialize package repository with bdep new)] D
/h10 [(3.1.5\240\240)(2.1.5 Add upstream repository as git submodule)] D
/h11 [(3.2\240\240)(2.2 Create package and generate buildfile templates)] D
/h12 [(3.2.1\240\240)(2.2.1 Decide on the package name)] D
/h13 [(3.2.2\240\240)(2.2.2 Decide on the package source code layout)] D
/h14 [(3.2.3\240\240)(2.2.3 Craft bdep new command line to create package)] D
/h15 [(3.2.4\240\240)(2.2.4 Review and test auto-generated buildfile templates)] D
/h16 [(3.2.5\240\240)(2.2.5 Create final package)] D
/h17 [(3.2.6\240\240)(2.2.6 Adjust package version)] D
/h18 [(3.3\240\240)(2.3 Fill package with source code and add dependencies)] D
/h19 [(3.3.1\240\240)(2.3.1 Initialize package in build configurations)] D
/h20 [(3.3.2\240\240)(2.3.2 Add dependencies)] D
/h21 [(3.3.3\240\240)(2.3.3 Fill with upstream source code)] D
/h22 [(3.4\240\240)(2.4 Adjust project-wide and source buildfiles)] D
/h23 [(3.4.1\240\240)(2.4.1 Adjust project-wide build system files in build/)] D
/h24 [(3.4.2\240\240)(2.4.2 Adjust source subdirectory buildfiles)] D
/h25 [(3.4.3\240\240)(2.4.3 Adjust header buildfile)] D
/h26 [(3.4.4\240\240)(2.4.4 Adjust source buildfile: overview)] D
/h27 [(3.4.5\240\240)(2.4.5 Adjust source buildfile: cleanup)] D
/h28 [(3.4.6\240\240)(2.4.6 Adjust source buildfile: dependencies)] D
/h29 [(3.4.7\240\240)(2.4.7 Adjust source buildfile: public headers)] D
/h30 [(3.4.8\240\240)(2.4.8 Adjust source buildfile: sources, private headers)] D
/h31 [(3.4.9\240\240)(2.4.9 Adjust source buildfile: build and export options)] D
/h32 [(3.4.10\240\240)(2.4.10 Adjust source buildfile: symbol exporting)] D
/h33 [(3.4.11\240\240)(2.4.11 Adjust source buildfile: shared library version)] D
/h34 [(3.4.12\240\240)(2.4.12 Adjust source buildfile: executables)] D
/h35 [(3.4.13\240\240)(2.4.13 Adjust source buildfile: extra requirements)] D
/h36 [(3.4.14\240\240)(2.4.14 Test library build)] D
/h37 [(3.5\240\240)(2.5 Make smoke test)] D
/h38 [(3.5.1\240\240)(2.5.1 Adjust project-wide build system files in tests/build/)] D
/h39 [(3.5.2\240\240)(2.5.2 Convert generated test to library smoke test)] D
/h40 [(3.5.3\240\240)(2.5.3 Make smoke test: executables)] D
/h41 [(3.5.4\240\240)(2.5.4 Test locally)] D
/h42 [(3.5.5\240\240)(2.5.5 Test locally: installation)] D
/h43 [(3.5.6\240\240)(2.5.6 Test locally: distribution)] D
/h44 [(3.5.7\240\240)(2.5.7 Commit and test with CI)] D
/h45 [(3.6\240\240)(2.6 Replace smoke test with upstream tests)] D
/h46 [(3.6.1\240\240)(2.6.1 Understand how upstream tests work)] D
/h47 [(3.6.2\240\240)(2.6.2 Convert smoke test to upstream tests)] D
/h48 [(3.6.3\240\240)(2.6.3 Test locally)] D
/h49 [(3.6.4\240\240)(2.6.4 Commit and test with CI)] D
/h50 [(3.7\240\240)(2.7 Add upstream examples, benchmarks, if any)] D
/h51 [(3.8\240\240)(2.8 Adjust root files \(buildfile, manifest, etc\))] D
/h52 [(3.8.1\240\240)(2.8.1 Adjust root buildfile)] D
/h53 [(3.8.2\240\240)(2.8.2 Adjust root buildfile: other subdirectories)] D
/h54 [(3.8.3\240\240)(2.8.3 Adjust root buildfile: commit and test)] D
/h55 [(3.8.4\240\240)(2.8.4 Adjust manifest)] D
/h56 [(3.8.5\240\240)(2.8.5 Adjust manifest: summary)] D
/h57 [(3.8.6\240\240)(2.8.6 Adjust manifest: license)] D
/h58 [(3.8.7\240\240)(2.8.7 Adjust manifest: commit and test)] D
/h59 [(3.8.8\240\240)(2.8.8 Adjust PACKAGE-README.md)] D
/h60 [(3.9\240\240)(2.9 Adjust package repository README.md)] D
/h61 [(3.10\240\240)(2.10 Release and publish)] D
/h62 [(3.10.1\240\240)(2.10.1 Transfer package repository)] D
/h63 [(3.10.2\240\240)(2.10.2 Release final version)] D
/h64 [(3.10.3\240\240)(2.10.3 Publish released version)] D
/h65 [(3.11\240\240)(2.11 Package version management)] D
/h66 [(3.11.1\240\240)(2.11.1 New revision)] D
/h67 [(3.11.2\240\240)(2.11.2 New version)] D
/h68 [(3.11.3\240\240)(2.11.3 New version: create new work branch)] D
/h69 [(3.11.4\240\240)(2.11.4 New version: open new version)] D
/h70 [(3.11.5\240\240)(2.11.5 New version: update upstream submodule)] D
/h71 [(3.11.6\240\240)(2.11.6 New version: review upstream changes)] D
/h72 [(3.11.7\240\240)(2.11.7 New version: layout changes)] D
/h73 [(3.11.8\240\240)(2.11.8 New version: new/old dependencies)] D
/h74 [(3.11.9\240\240)(2.11.9 New version: new/old source files)] D
/h75 [(3.11.10\240\240)(2.11.10 New version: changes to build system)] D
/h76 [(3.11.11\240\240)(2.11.11 New version: other new/old files/subdirectories)] D
/h77 [(3.11.12\240\240)(2.11.12 New version: review manifest and PACKAGE-README.md)] D
/h78 [(3.11.13\240\240)(2.11.13 New version: review repository README.md)] D
/h79 [(3.11.14\240\240)(2.11.14 New version: review/fix accumulated issues)] D
/h80 [(3.11.15\240\240)(2.11.15 New version: test locally and with CI)] D
/h81 [(3.11.16\240\240)(2.11.16 New version: merge, release, and publish)] D
/h82 [(3.11.17\240\240)(2.11.17 New version/revision in old release series)] D
/h83 [(4\240\240)(3 What Not to Do)] D
/h84 [(4.1\240\240)(3.1 Don't write buildfiles from scratch, use bdep-new)] D
/h85 [(4.2\240\240)(3.2 Avoid fixing upstream issues in the build2 package)] D
/h86 [(4.3\240\240)(3.3 Avoid changing upstream source code layout)] D
/h87 [(4.4\240\240)(3.4 Don't make library header-only if it can be compiled)] D
/h88 [(4.5\240\240)(3.5 Don't bundle dependencies)] D
/h89 [(4.6\240\240)(3.6 Don't build your main targets in the root buildfile)] D
/h90 [(4.7\240\240)(3.7 Don't make extensive changes in a revision)] D
/h91 [(5\240\240)(4 Packaging HOWTO)] D
/h92 [(5.1\240\240)(4.1 How do I patch upstream source code?)] D
/h93 [(5.1.1\240\240)(4.1.1 Modifying upstream source code manually)] D
/h94 [(5.1.2\240\240)(4.1.2 Modifying upstream source code during build)] D
/h95 [(5.1.3\240\240)(4.1.3 Modifying upstream source code with C/C++ preprocessor)] D
/h96 [(5.2\240\240)(4.2 How do I deal with bad header inclusion practice?)] D
/h97 [(5.3\240\240)(4.3 How do I handle extra header installation subdirectory?)] D
/h98 [(5.4\240\240)(4.4 How do I handle headers without an extension?)] D
/h99 [(5.5\240\240)(4.5 How do I expose extra debug macros of a library?)] D
/h100 [(6\240\240)(5 Packaging FAQ)] D
/h101 [(6.1\240\240)(5.1 Publishing FAQ)] D
/h102 [(6.1.1\240\240)(5.1.1 Why is my package in alpha rather than stable?)] D
/h103 [(6.1.2\240\240)(5.1.2 Where to publish if package requires staged toolchain?)] D
/h104 [(6.1.3\240\240)(5.1.3 Why "project owner authentication failed" while publishing?)] D
/Hr [106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122
123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140
141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158
159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176
177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194
195 196 197 198 199 200 201 202 203 204 205 206 207 208 209]D
/HV [1 1 2 1 2 3 3 3 3 3 2 3 3 3 3 3 3 2 3 3 3 2 3 3 3 3 3 3 3 3 3 3 3
3 3 3 2 3 3 3 3 3 3 3 2 3 3 3 3 2 2 3 3 3 3 3 3 3 3 2 2 3 3 3 2 3 3 3 3
3 3 3 3 3 3 3 3 3 3 3 3 3 1 2 2 2 2 2 2 2 1 2 3 3 3 2 2 2 2 1 2 3 3 3]D
/Cn [0 1 0 11 5 0 0 0 0 0 6 0 0 0 0 0 0 3 0 0 0 14 0 0 0 0 0 0 0 0 0 0
0 0 0 0 7 0 0 0 0 0 0 0 4 0 0 0 0 0 8 0 0 0 0 0 0 0 0 0 3 0 0 0 17 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 7 0 0 0 0 0 0 0 5 3 0 0 0 0 0 0 0 1 3 0 0 0]D
Hr length 0 gt{[/PageMode /UseOutlines /DOCVIEW pdfmark}if
/Hn 1 D
0 1 Hr length 1 sub{
 /Bn E D [Cn Bn get dup 0 gt{/Count E HV Bn get Bl ge{neg}if}{pop}ie
 /Dest Hr Bn get dup abs ST cvs cvn E 0 ge{(h)Hn ST cvs join cvx exec
 dup 1 get E Nf{0 get E join}{pop}ie /Hn Hn 1 add D}{()}ie
 /Title E dup length 255 gt{0 255 getinterval}if /OUT pdfmark}for
ZF /FN Fp D Ps 0 FS /WC Wf{( )}{<A1A1>}ie SW pop D
ET RC ZF
/Df f D
/R1 (https://cppget.org/) D
/R2 (https://build2.org/doc.xhtml) D
/R3 (https://build2.org/faq.xhtml#why-syspkg) D
/R4 (https://build2.org/faq.xhtml#why-package-managers) D
/R5 (https://github.com/build2-packaging) D
/R6 (https://ci.cppget.org/) D
/R7 (https://queue.cppget.org/) D
/R8 (https://queue.stage.build2.org/) D
/R9 (https://github.com/build2-packaging/WISHLIST/issues) D
/R10 (https://build2.org/community.xhtml#help) D
/R11 (https://github.com/build2-packaging/WISHLIST) D
/R12 (https://github.com/build2/HOWTO/blob/master/entries/handle-tests-with-extra-dependencies.md) D
/R13 (https://build2.org/article/symlinks.xhtml) D
/R14 (https://build2.org/article/symlinks.xhtml#windows) D
/R15 (https://packages.debian.org/) D
/R16 (https://github.com/build2/HOWTO/blob/master/entries/name-packages-in-project.md) D
/R17 (https://github.com/build2/HOWTO/blob/master/entries/make-header-only-library.md) D
/R18 (https://github.com/build2/HOWTO/blob/master/entries/handle-projects-which-dont-use-semver.md) D
/R19 (https://github.com/build2/HOWTO/blob/master/entries/handle-projects-which-dont-use-version.md) D
/R20 (https://cppget.org/catch2) D
/R21 (https://cppget.org/?about) D
/R22 (https://github.com/build2/HOWTO/blob/master/entries/link-system-library.md) D
/R23 (https://github.com/build2/HOWTO/blob/master/entries/keep-build-graph-config-independent.md) D
/R24 (https://github.com/build2/HOWTO/blob/master/entries/compile-options-in-buildfile.md) D
/R25 (https://github.com/build2-packaging/sqlite) D
/R26 (https://github.com/build2/HOWTO/blob/master/entries/convey-additional-information-with-exe-lib.md) D
/R27 (https://github.com/build2/libbuild2-autoconf) D
/R28 (https://github.com/build2-packaging/zstd) D
/R29 (https://cppget.org/reflex) D
/R30 (https://cppget.org/byacc) D
/R31 (https://github.com/build2/HOWTO/) D
/R32 (https://github.com/build2/HOWTO/blob/master/entries/use-assert-in-tests.md) D
/R33 (https://github.com/build2-packaging/thrift/tree/0.17) D
/R34 (https://github.com/build2/HOWTO/blob/master/entries/sanitize-test-execution.md) D
/R35 (https://cppget.org/gtest) D
/R36 (https://cppget.org/doctest) D
/R37 (https://cppget.org/libboost-test) D
/R38 (https://lists.build2.org/) D
/R39 (https://spdx.org/licenses/) D
/R40 (https://build2.org/bpkg/doc/build2-package-manager-manual.xhtml#manifest-package-license) D
/R41 (https://github.com/build2-packaging/zstd/blob/master/libzstd/PACKAGE-README.md) D
/R42 (https://github.com/build2-packaging/libevent/blob/main/PACKAGE-README.md) D
/R43 (https://github.com/build2-packaging/libevent) D
/R44 (https://github.com/build2-packaging/zstd/blob/master/zstd/PACKAGE-README.md) D
/R45 (https://github.com/build2-packaging/xxd/blob/master/xxd/README.md) D
/R46 (https://github.com/build2-packaging/xxd) D
/R47 (https://github.com/build2-packaging/zstd/blob/master/README.md) D
/R48 (https://build2.org/community.xhtml#stage) D
/R49 (https://github.com/cppget/) D
/Ba f D /BO 0 D Bs
/UR (-) D
/Ti (The build2 Packaging Guide) D
/Au () D
/Df f D
/ME [(0.17)(Packaging Guide)(2014-2024 the build2 authors)(toolchain)] D
Pt
/BO 0 D TC /Ba f D Bs /AU f D /UR () D RC ZF
 tH WB
ND 1 gt{Ts 3 mul Np 0()0 C()BD(The build2 Packaging Guide)ES()0 1 TN()EA()BN}if
1 NH le{106(1\240\240)1 C(Preface)WB 2 Sn()106 1 TN()EA()BN}if
1 NH le{107(2\240\240)1 C(1)WB 3 Sn( Intro)HY(duc)HY(tion)YH()107 1 TN()EA()BN}if
2 NH le{108(2.1\240\240)2 C(1.1)WB 4 Sn( Termi)HY(nol)HY(ogy)YH()108 1 TN()EA()BN}if
1 NH le{109(3\240\240)1 C(2)WB 5 Sn( Common Guide)HY(lines)YH()109 1 TN()EA()BN}if
2 NH le{110(3.1\240\240)2 C(2.1)WB 6 Sn( Setup the package repos)HY(i)HY(tory)YH()110 1 TN()EA()BN}if
3 NH le{111(3.1.1\240\240)3 C(2.1.1)WB 7 Sn( Check if package repos)HY(i)HY(tory)YH( already
  exists)111 1 TN()EA()BN}if
3 NH le{112(3.1.2\240\240)3 C(2.1.2)WB 8 Sn( Use upstream repos)HY(i)HY(tory)YH( name as package
  repos)HY(i)HY(tory)YH( name)112 1 TN()EA()BN}if
3 NH le{113(3.1.3\240\240)3 C(2.1.3)WB 9 Sn( Create package repos)HY(i)HY(tory)YH( in personal
  workspace)113 1 TN()EA()BN}if
3 NH le{114(3.1.4\240\240)3 C(2.1.4)WB 10 Sn( Initial)HY(ize)YH( package repos)HY(i)HY(tory)YH( with )SM(bdep
  new)ES()114 1 TN()EA()BN}if
3 NH le{115(3.1.5\240\240)3 C(2.1.5)WB 11 Sn( Add upstream repos)HY(i)HY(tory)YH( as
  )SM(git)ES( submod)HY(ule)YH()115 1 TN()EA()BN}if
2 NH le{116(3.2\240\240)2 C(2.2)WB 12 Sn( Create package and gener)HY(ate)YH( )SM(build)HY(file)YH()ES(
  templates)116 1 TN()EA()BN}if
3 NH le{117(3.2.1\240\240)3 C(2.2.1)WB 13 Sn( Decide on the package name)117 1 TN()EA()BN}if
3 NH le{118(3.2.2\240\240)3 C(2.2.2)WB 14 Sn( Decide on the package source code
  layout)118 1 TN()EA()BN}if
3 NH le{119(3.2.3\240\240)3 C(2.2.3)WB 15 Sn( Craft )SM(bdep new)ES( command
  line to create package)119 1 TN()EA()BN}if
3 NH le{120(3.2.4\240\240)3 C(2.2.4)WB 16 Sn( Review and test auto-gener)HY(ated)YH(
  )SM(build)HY(file)YH()ES( templates)120 1 TN()EA()BN}if
3 NH le{121(3.2.5\240\240)3 C(2.2.5)WB 17 Sn( Create final package)121 1 TN()EA()BN}if
3 NH le{122(3.2.6\240\240)3 C(2.2.6)WB 18 Sn( Adjust package version)122 1 TN()EA()BN}if
2 NH le{123(3.3\240\240)2 C(2.3)WB 19 Sn( Fill package with source code and add
  depen)HY(den)HY(cies)YH()123 1 TN()EA()BN}if
3 NH le{124(3.3.1\240\240)3 C(2.3.1)WB 20 Sn( Initial)HY(ize)YH( package in build
  config)HY(u)HY(ra)HY(tions)YH()124 1 TN()EA()BN}if
3 NH le{125(3.3.2\240\240)3 C(2.3.2)WB 21 Sn( Add depen)HY(den)HY(cies)YH()125 1 TN()EA()BN}if
3 NH le{126(3.3.3\240\240)3 C(2.3.3)WB 22 Sn( Fill with upstream source code)126 1 TN()EA()BN}if
2 NH le{127(3.4\240\240)2 C(2.4)WB 23 Sn( Adjust project-wide and source
  )SM(build)HY(files)YH()ES()127 1 TN()EA()BN}if
3 NH le{128(3.4.1\240\240)3 C(2.4.1)WB 24 Sn( Adjust project-wide build system files
  in )SM(build/)ES()128 1 TN()EA()BN}if
3 NH le{129(3.4.2\240\240)3 C(2.4.2)WB 25 Sn( Adjust source subdi)HY(rec)HY(tory)YH(
  )SM(build)HY(files)YH()ES()129 1 TN()EA()BN}if
3 NH le{130(3.4.3\240\240)3 C(2.4.3)WB 26 Sn( Adjust header
  )SM(build)HY(file)YH()ES()130 1 TN()EA()BN}if
3 NH le{131(3.4.4\240\240)3 C(2.4.4)WB 27 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: overview)131 1 TN()EA()BN}if
3 NH le{132(3.4.5\240\240)3 C(2.4.5)WB 28 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: cleanup)132 1 TN()EA()BN}if
3 NH le{133(3.4.6\240\240)3 C(2.4.6)WB 29 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: depen)HY(den)HY(cies)YH()133 1 TN()EA()BN}if
3 NH le{134(3.4.7\240\240)3 C(2.4.7)WB 30 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: public headers)134 1 TN()EA()BN}if
3 NH le{135(3.4.8\240\240)3 C(2.4.8)WB 31 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: sources, private headers)135 1 TN()EA()BN}if
3 NH le{136(3.4.9\240\240)3 C(2.4.9)WB 32 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: build and export options)136 1 TN()EA()BN}if
3 NH le{137(3.4.10\240\240)3 C(2.4.10)WB 33 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: symbol export)HY(ing)YH()137 1 TN()EA()BN}if
3 NH le{138(3.4.11\240\240)3 C(2.4.11)WB 34 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: shared library version)138 1 TN()EA()BN}if
3 NH le{139(3.4.12\240\240)3 C(2.4.12)WB 35 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: executa)HY(bles)YH()139 1 TN()EA()BN}if
3 NH le{140(3.4.13\240\240)3 C(2.4.13)WB 36 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: extra require)HY(ments)YH()140 1 TN()EA()BN}if
3 NH le{141(3.4.14\240\240)3 C(2.4.14)WB 37 Sn( Test library build)141 1 TN()EA()BN}if
2 NH le{142(3.5\240\240)2 C(2.5)WB 38 Sn( Make smoke test)142 1 TN()EA()BN}if
3 NH le{143(3.5.1\240\240)3 C(2.5.1)WB 39 Sn( Adjust project-wide build system
  files in )SM(tests/build/)ES()143 1 TN()EA()BN}if
3 NH le{144(3.5.2\240\240)3 C(2.5.2)WB 40 Sn( Convert gener)HY(ated)YH( test to library
  smoke test)144 1 TN()EA()BN}if
3 NH le{145(3.5.3\240\240)3 C(2.5.3)WB 41 Sn( Make smoke test: executa)HY(bles)YH()145 1 TN()EA()BN}if
3 NH le{146(3.5.4\240\240)3 C(2.5.4)WB 42 Sn( Test locally)146 1 TN()EA()BN}if
3 NH le{147(3.5.5\240\240)3 C(2.5.5)WB 43 Sn( Test locally:
  instal)HY(la)HY(tion)YH()147 1 TN()EA()BN}if
3 NH le{148(3.5.6\240\240)3 C(2.5.6)WB 44 Sn( Test locally: distri)HY(bu)HY(tion)YH()148 1 TN()EA()BN}if
3 NH le{149(3.5.7\240\240)3 C(2.5.7)WB 45 Sn( Commit and test with CI)149 1 TN()EA()BN}if
2 NH le{150(3.6\240\240)2 C(2.6)WB 46 Sn( Replace smoke test with upstream tests)150 1 TN()EA()BN}if
3 NH le{151(3.6.1\240\240)3 C(2.6.1)WB 47 Sn( Under)HY(stand)YH( how upstream tests
  work)151 1 TN()EA()BN}if
3 NH le{152(3.6.2\240\240)3 C(2.6.2)WB 48 Sn( Convert smoke test to upstream
  tests)152 1 TN()EA()BN}if
3 NH le{153(3.6.3\240\240)3 C(2.6.3)WB 49 Sn( Test locally)153 1 TN()EA()BN}if
3 NH le{154(3.6.4\240\240)3 C(2.6.4)WB 50 Sn( Commit and test with CI)154 1 TN()EA()BN}if
2 NH le{155(3.7\240\240)2 C(2.7)WB 51 Sn( Add upstream exam)HY(ples)YH(, bench)HY(marks)YH(, if
  any)155 1 TN()EA()BN}if
2 NH le{156(3.8\240\240)2 C(2.8)WB 52 Sn( Adjust root files \201)SM(build)HY(file)YH()ES(,
  )SM(mani)HY(fest)YH()ES(, etc\202)156 1 TN()EA()BN}if
3 NH le{157(3.8.1\240\240)3 C(2.8.1)WB 53 Sn( Adjust root )SM(build)HY(file)YH()ES()157 1 TN()EA()BN}if
3 NH le{158(3.8.2\240\240)3 C(2.8.2)WB 54 Sn( Adjust root )SM(build)HY(file)YH()ES(:
  other subdi)HY(rec)HY(to)HY(ries)YH()158 1 TN()EA()BN}if
3 NH le{159(3.8.3\240\240)3 C(2.8.3)WB 55 Sn( Adjust root
  )SM(build)HY(file)YH()ES(: commit and test)159 1 TN()EA()BN}if
3 NH le{160(3.8.4\240\240)3 C(2.8.4)WB 56 Sn( Adjust )SM(mani)HY(fest)YH()ES()160 1 TN()EA()BN}if
3 NH le{161(3.8.5\240\240)3 C(2.8.5)WB 57 Sn( Adjust )SM(mani)HY(fest)YH()ES(:
  )SM(summary)ES()161 1 TN()EA()BN}if
3 NH le{162(3.8.6\240\240)3 C(2.8.6)WB 58 Sn( Adjust )SM(mani)HY(fest)YH()ES(:
  )SM(license)ES()162 1 TN()EA()BN}if
3 NH le{163(3.8.7\240\240)3 C(2.8.7)WB 59 Sn( Adjust )SM(mani)HY(fest)YH()ES(:
  commit and test)163 1 TN()EA()BN}if
3 NH le{164(3.8.8\240\240)3 C(2.8.8)WB 60 Sn( Adjust
  )SM(PACKAGE-README.md)ES()164 1 TN()EA()BN}if
2 NH le{165(3.9\240\240)2 C(2.9)WB 61 Sn( Adjust package repos)HY(i)HY(tory)YH(
  )SM(README.md)ES()165 1 TN()EA()BN}if
2 NH le{166(3.10\240\240)2 C(2.10)WB 62 Sn( Release and publish)166 1 TN()EA()BN}if
3 NH le{167(3.10.1\240\240)3 C(2.10.1)WB 63 Sn( Trans)HY(fer)YH( package
  repos)HY(i)HY(tory)YH()167 1 TN()EA()BN}if
3 NH le{168(3.10.2\240\240)3 C(2.10.2)WB 64 Sn( Release final version)168 1 TN()EA()BN}if
3 NH le{169(3.10.3\240\240)3 C(2.10.3)WB 65 Sn( Publish released version)169 1 TN()EA()BN}if
2 NH le{170(3.11\240\240)2 C(2.11)WB 66 Sn( Package version manage)HY(ment)YH()170 1 TN()EA()BN}if
3 NH le{171(3.11.1\240\240)3 C(2.11.1)WB 67 Sn( New revi)HY(sion)YH()171 1 TN()EA()BN}if
3 NH le{172(3.11.2\240\240)3 C(2.11.2)WB 68 Sn( New version)172 1 TN()EA()BN}if
3 NH le{173(3.11.3\240\240)3 C(2.11.3)WB 69 Sn( New version:
  create new work branch)173 1 TN()EA()BN}if
3 NH le{174(3.11.4\240\240)3 C(2.11.4)WB 70 Sn( New version: open
  new version)174 1 TN()EA()BN}if
3 NH le{175(3.11.5\240\240)3 C(2.11.5)WB 71 Sn( New version:
  update )SM(upstream)ES( submod)HY(ule)YH()175 1 TN()EA()BN}if
3 NH le{176(3.11.6\240\240)3 C(2.11.6)WB 72 Sn( New version:
  review upstream changes)176 1 TN()EA()BN}if
3 NH le{177(3.11.7\240\240)3 C(2.11.7)WB 73 Sn( New version:
  layout changes)177 1 TN()EA()BN}if
3 NH le{178(3.11.8\240\240)3 C(2.11.8)WB 74 Sn( New
  version: new/old depen)HY(den)HY(cies)YH()178 1 TN()EA()BN}if
3 NH le{179(3.11.9\240\240)3 C(2.11.9)WB 75 Sn( New version:
  new/old source files)179 1 TN()EA()BN}if
3 NH le{180(3.11.10\240\240)3 C(2.11.10)WB 76 Sn( New version:
  changes to build system)180 1 TN()EA()BN}if
3 NH le{181(3.11.11\240\240)3 C(2.11.11)WB 77 Sn( New version:
  other new/old files/subdi)HY(rec)HY(to)HY(ries)YH()181 1 TN()EA()BN}if
3 NH le{182(3.11.12\240\240)3 C(2.11.12)WB 78 Sn( New version:
  review )SM(mani)HY(fest)YH()ES( and )SM(PACKAGE-README.md)ES()182 1 TN()EA()BN}if
3 NH le{183(3.11.13\240\240)3 C(2.11.13)WB 79 Sn( New version:
  review repos)HY(i)HY(tory)YH( )SM(README.md)ES()183 1 TN()EA()BN}if
3 NH le{184(3.11.14\240\240)3 C(2.11.14)WB 80 Sn( New version:
  review/fix accu)HY(mu)HY(lated)YH( issues)184 1 TN()EA()BN}if
3 NH le{185(3.11.15\240\240)3 C(2.11.15)WB 81 Sn( New version: test
  locally and with CI)185 1 TN()EA()BN}if
3 NH le{186(3.11.16\240\240)3 C(2.11.16)WB 82 Sn( New version:
  merge, release, and publish)186 1 TN()EA()BN}if
3 NH le{187(3.11.17\240\240)3 C(2.11.17)WB 83 Sn( New version/revi)HY(sion)YH( in
  old release series)187 1 TN()EA()BN}if
1 NH le{188(4\240\240)1 C(3)WB 84 Sn( What Not to Do)188 1 TN()EA()BN}if
2 NH le{189(4.1\240\240)2 C(3.1)WB 85 Sn( Don't write )SM(build)HY(files)YH()ES( from
  scratch, use )SM(bdep-new)ES()189 1 TN()EA()BN}if
2 NH le{190(4.2\240\240)2 C(3.2)WB 86 Sn( Avoid fixing upstream issues in the
  )SM(build2)ES( package)190 1 TN()EA()BN}if
2 NH le{191(4.3\240\240)2 C(3.3)WB 87 Sn( Avoid chang)HY(ing)YH( upstream source code
  layout)191 1 TN()EA()BN}if
2 NH le{192(4.4\240\240)2 C(3.4)WB 88 Sn( Don't make library header-only if it can be
  compiled)192 1 TN()EA()BN}if
2 NH le{193(4.5\240\240)2 C(3.5)WB 89 Sn( Don't bundle depen)HY(den)HY(cies)YH()193 1 TN()EA()BN}if
2 NH le{194(4.6\240\240)2 C(3.6)WB 90 Sn( Don't build your main targets
  in the root )SM(build)HY(file)YH()ES()194 1 TN()EA()BN}if
2 NH le{195(4.7\240\240)2 C(3.7)WB 91 Sn( Don't make exten)HY(sive)YH( changes in a
  revi)HY(sion)YH()195 1 TN()EA()BN}if
1 NH le{196(5\240\240)1 C(4)WB 92 Sn( Pack)HY(ag)HY(ing)YH( HOWTO)196 1 TN()EA()BN}if
2 NH le{197(5.1\240\240)2 C(4.1)WB 93 Sn( How do I patch upstream source
  code?)197 1 TN()EA()BN}if
3 NH le{198(5.1.1\240\240)3 C(4.1.1)WB 94 Sn( Modi)HY(fy)HY(ing)YH( upstream source
  code manu)HY(ally)YH()198 1 TN()EA()BN}if
3 NH le{199(5.1.2\240\240)3 C(4.1.2)WB 95 Sn( Modi)HY(fy)HY(ing)YH( upstream source
  code during build)199 1 TN()EA()BN}if
3 NH le{200(5.1.3\240\240)3 C(4.1.3)WB 96 Sn( Modi)HY(fy)HY(ing)YH( upstream source
  code with C/C++ prepro)HY(ces)HY(sor)YH()200 1 TN()EA()BN}if
2 NH le{201(5.2\240\240)2 C(4.2)WB 97 Sn( How do I deal with bad header
  inclu)HY(sion)YH( prac)HY(tice)YH(?)201 1 TN()EA()BN}if
2 NH le{202(5.3\240\240)2 C(4.3)WB 98 Sn( How do I handle extra header
  instal)HY(la)HY(tion)YH( subdi)HY(rec)HY(tory)YH(?)202 1 TN()EA()BN}if
2 NH le{203(5.4\240\240)2 C(4.4)WB 99 Sn( How do I handle headers without an
  exten)HY(sion)YH(?)203 1 TN()EA()BN}if
2 NH le{204(5.5\240\240)2 C(4.5)WB 100 Sn( How do I expose extra debug macros of a
  library?)204 1 TN()EA()BN}if
1 NH le{205(6\240\240)1 C(5)WB 101 Sn( Pack)HY(ag)HY(ing)YH( FAQ)205 1 TN()EA()BN}if
2 NH le{206(6.1\240\240)2 C(5.1)WB 102 Sn( Publish)HY(ing)YH( FAQ)206 1 TN()EA()BN}if
3 NH le{207(6.1.1\240\240)3 C(5.1.1)WB 103 Sn( Why is my package in )SM(alpha)ES(
  rather than )SM(stable)ES(?)207 1 TN()EA()BN}if
3 NH le{208(6.1.2\240\240)3 C(5.1.2)WB 104 Sn( Where to publish if package requires staged
  toolchain?)208 1 TN()EA()BN}if
3 NH le{209(6.1.3\240\240)3 C(5.1.3)WB 105 Sn( Why "project owner authen)HY(ti)HY(ca)HY(tion)YH( failed"
  while publish)HY(ing)YH(?)209 1 TN()EA()BN}if
/OU t D /Cb Db D NP Ep ET 
/Cb Db D /Ct [16#00 16#00 16#00] D /Cl [16#00 16#00 16#00] D /CL -1 D Ct Sc

/Ba f D /BO 0 D Bs
/UR (-) D
/Ti (The build2 Packaging Guide) D
/Au () D
/Df f D
/ME [(0.17)(Packaging Guide)(2014-2024 the build2 authors)(toolchain)] D

NP RC ZF
()0 Sl()WB 0 Sn(
)BR()WB 1 Sn(
   
  )0 1 0 H(Preface)WB 106 Sn()WB 2 Sn()EH(

  )0 P(This docu)HY(ment)YH( provides guide)HY(lines)YH( for convert)HY(ing)YH( third-party C/C++
  projects to the )SM(build2)ES( build system and making them avail)HY(able)YH(
  as pack)HY(ages)YH( from )R1 2 A(cppget.org)EA(, the
  )SM(build2)ES( commu)HY(nity)YH('s central package repos)HY(i)HY(tory)YH(. For addi)HY(tional)YH(
  infor)HY(ma)HY(tion)YH(, includ)HY(ing)YH( docu)HY(men)HY(ta)HY(tion)YH( for indi)HY(vid)HY(ual)YH( )SM(build2)ES(
  toolchain compo)HY(nents)YH(, man pages, HOWTOs, etc., refer to the project )R2 2 A(Docu)HY(men)HY(ta)HY(tion)YH()EA( page.)EP(

  )0 1 1 H(1)WB 107 Sn()WB 3 Sn( Intro)HY(duc)HY(tion)YH()EH(

  )0 P(The aim of this guide is to ease the conver)HY(sion)YH( of third-party C/C++
  projects to the )SM(build2)ES( build system and publish)HY(ing)YH( them to the
  )R1 2 A(cppget.org)EA( package repos)HY(i)HY(tory)YH( by codi)HY(fy)HY(ing)YH(
  the best prac)HY(tices)YH( and tech)HY(niques)YH(. By follow)HY(ing)YH( the presented guide)HY(lines)YH( you
  will also make it easier for others to review your work and help with
  ongoing main)HY(te)HY(nance)YH(.)EP(

  )BR(
  )0 P(A )SM(build2)ES(-based project can only consume pack)HY(ages)YH( that use
  the )SM(build2)ES( build system \201with the excep)HY(tion)YH( of )R3 2 A(system-installed
  pack)HY(ages)YH()EA(\202. In other words, there is no support for "wrap)HY(ping)YH(" or
  other)HY(wise)YH( adapt)HY(ing)YH( third-party projects' exist)HY(ing)YH( build systems. While
  replac)HY(ing)YH( the build system unques)HY(tion)HY(ably)YH( requires more work upfront, the
  )SM(build2)ES( project's expe)HY(ri)HY(ence)YH( is that the long-term bene)HY(fits)YH( of
  this effort are well justi)HY(fied)YH( \201see )R4 2 A(How does
  )SM(build2)ES( compare to other package managers?)EA( for details\202.)EP(
  )BR(

  )0 P(The primary focus of this guide is exist)HY(ing)YH( C/C++ projects that use a
  differ)HY(ent)YH( build system and that are main)HY(tained)YH( by a third-party, which we
  will refer to as )I(upstream)ES(. Unless upstream is willing to incor)HY(po)HY(rate)YH(
  support for )SM(build2)ES( directly into their repos)HY(i)HY(tory)YH(, such
  projects are normally pack)HY(aged)YH( for )SM(build2)ES( in a sepa)HY(rate)YH(
  )SM(git)ES( repos)HY(i)HY(tory)YH( under the )R5 2 A(github.com/build2-pack)HY(ag)HY(ing)YH()EA(
  orga)HY(ni)HY(za)HY(tion)YH(. Note, however, that many of the presented guide)HY(lines)YH( are also
  appli)HY(ca)HY(ble)YH( when convert)HY(ing)YH( your own projects \201that is, where you are the
  upstream\202 as well as projects that use languages other than C or C++.)EP(

  )0 P(Most C/C++ pack)HY(ages)YH( that are published to )R1 2 A(cppget.org)EA( are either libraries or executa)HY(bles)YH(
  \201projects that provide both are normally split into several pack)HY(ages)YH(\202 with
  libraries being in the strong major)HY(ity)YH(. Libraries are also gener)HY(ally)YH( more
  diffi)HY(cult)YH( to build correctly. As a result, this guide uses libraries as a
  base)HY(line)YH(. In most cases, a library-specific step is easily distin)HY(guished)YH( as
  such and can be skipped when dealing with executa)HY(bles)YH(. And in cases where a
  more nuanced change is required, a note will be provided.)EP(

  )0 P(At the high-level, pack)HY(ag)HY(ing)YH( a third-party project involves the follow)HY(ing)YH(
  steps:)EP(

  )4 OL(  )-1 LI(Create the )SM(git)ES( repos)HY(i)HY(tory)YH( and import upstream source
  code.

  )-1 LI(Gener)HY(ate)YH( )SM(build)HY(file)YH()ES( templates that match upstream
  layout.

  )-1 LI(Tweak the gener)HY(ated)YH( )SM(build)HY(files)YH()ES( to match upstream
  build.

  )-1 LI(Test locally and using the )R6 2 A()SM(build2)ES( CI service)EA(.

  )-1 LI(Release and publish the package to )R1 2 A(cppget.org)EA(.
  )LO(

  )0 P(Once this process is completed and the package is published, new releases
  normally require a small amount of work provided there are no drastic
  changes in the upstream layout or build. The sequence of steps for a new
  release would typical look like this:)EP(

  )4 OL(  )-1 LI(Add new and/or remove old upstream source code, if any.

  )-1 LI(Tweak )SM(build)HY(files)YH()ES( to match changes to upstream build, if
  any.

  )-1 LI(Test locally and using the )R6 2 A()SM(build2)ES( CI service)EA(.

  )-1 LI(Release and publish the package to )R1 2 A(cppget.org)EA(.
  )LO(

  )0 P(While pack)HY(ag)HY(ing)YH( a simple library or executable is rela)HY(tively)YH(
  straight)HY(for)HY(ward)YH(, the C and C++ languages and their ecosys)HY(tems)YH( are infa)HY(mous)YH(
  for a large amount of vari)HY(abil)HY(ity)YH( in the plat)HY(forms)YH(, compil)HY(ers)YH(, source code
  layouts, and build systems used. This leads to what looks like an endless
  list of special consid)HY(er)HY(a)HY(tions)YH( that are only appli)HY(ca)HY(ble)YH( in certain, more
  complex cases.)EP(

  )0 P(As result, the presented guide)HY(lines)YH( are divided into four chap)HY(ters)YH(: )0 5 1 A(Common Guide)HY(lines)YH()5 0 TN TL()Ec /AF f D( cover steps that are appli)HY(ca)HY(ble)YH( to most
  pack)HY(ag)HY(ing)YH( efforts. As mentioned earlier, these steps will assume pack)HY(ag)HY(ing)YH( a
  library but they should be easy to adapt to executa)HY(bles)YH(. This chapter is
  followed by )0 84 1 A(What Not to Do)84 0 TN TL()Ec /AF f D( which covers the common
  pack)HY(ag)HY(ing)YH( mistakes and omis)HY(sions)YH(. These are unfor)HY(tu)HY(nately)YH( rela)HY(tively)YH( common
  because expe)HY(ri)HY(ence)YH( with other build systems often does not trans)HY(late)YH(
  directly to )SM(build2)ES( and some tech)HY(niques)YH( \201such as header-only
  libraries\202 are discour)HY(aged)YH(. The last two chap)HY(ters)YH( are )0 92 1 A(HOWTO)92 0 TN TL()Ec /AF f D( and )0 101 1 A(FAQ)101 0 TN TL()Ec /AF f D(. The former covers the
  above-mentioned long list of special consid)HY(er)HY(a)HY(tions)YH( that are only appli)HY(ca)HY(ble)YH(
  in certain cases while the latter answer frequent pack)HY(ag)HY(ing)YH(-related
  ques)HY(tions)YH(.)EP(

  )0 P(Besides the presented guide)HY(lines)YH(, you may also find the exist)HY(ing)YH( pack)HY(ages)YH(
  found in )R5 2 A(github.com/build2-pack)HY(ag)HY(ing)YH()EA( a
  good source of example mate)HY(rial)YH(. The repos)HY(i)HY(to)HY(ries)YH( pinned to the front page
  are the recom)HY(mended)YH( start)HY(ing)YH( point.)EP(

  )0 P(This guide assumes famil)HY(iar)HY(ity)YH( with the )SM(build2)ES( toolchain. At
  the minimum you should have read through )0 2 A(The )SM(build2)ES( Toolchain
  Intro)HY(duc)HY(tion)YH()EA( and the )0 2 A(Intro)HY(duc)HY(tion)YH()EA(
  chapter in the build system manual. Ideally, you should also have some
  expe)HY(ri)HY(ence)YH( using )SM(build2)ES( in your own projects.)EP(

  )0 P(In this guide we will only show the UNIX version of the commands. In most
  cases making a Windows version is a simple matter of adjust)HY(ing)YH( paths and, if
  used, line contin)HY(u)HY(a)HY(tions)YH(. And where this is not the case a note will be
  provided showing the equiv)HY(a)HY(lent)YH( Windows command.)EP(

  )0 2 2 H(1.1)WB 108 Sn()WB 4 Sn( Termi)HY(nol)HY(ogy)YH()EH(

  )0 P(We use the term )I(upstream)ES( to refer collec)HY(tively)YH( to the third-party
  project as well as to its authors. For example, we may say, "upstream does
  not use semver" meaning that the upstream project does not use semver for
  version)HY(ing)YH(. Or we may say, "upstream released a new version" meaning that
  the upstream project's authors released a new version.)EP(

  )0 P(We will often use )I(upstream)ES( as a qual)HY(i)HY(fier)YH( to refer to a specific
  part of the upstream project. Commonly used qual)HY(i)HY(fied)YH( terms like this
  include:)EP(

  )0 DL(  )0 DT()I(upstream repos)HY(i)HY(tory)YH()ES(
  )DD(The version control \201normally )SM(git)ES(\202 repos)HY(i)HY(tory)YH( of the
  third-party project.

  )0 DT()I(upstream source code)ES(
  )DD(The C/C++ source code that consti)HY(tutes)YH( the third-party project.

  )0 DT()I(upstream layout)ES(
  )DD(The direc)HY(tory)YH( struc)HY(ture)YH( and loca)HY(tion)YH( of source code in the third-party
  project.

  )0 DT()I(upstream build system)ES(
  )DD(The equiv)HY(a)HY(lents)YH( of )SM(build)HY(files)YH()ES( that are used by the
  third-party project to build its source code, run tests, etc. For example,
  if upstream uses CMake, then all the )SM(CMake)HY(Lists)YH(.txt)ES(,
  )SM(*.cmake)ES(, etc., files will consti)HY(tute)YH( its build system.
  )LD(

  )0 P(To avoid confu)HY(sion)YH(, in this guide we will always use the term
  )I(project)ES( to refer to upstream and )I(package)ES( to refer to its
  )SM(build2)ES( conver)HY(sion)YH(, even though we would normally call our own
  )SM(build2)ES(-based work a project, not a package \201see )0 2 A(Project
  Struc)HY(ture)YH()EA( for details on the )SM(build2)ES( termi)HY(nol)HY(ogy)YH( in this
  area\202. Some commonly used )SM(build2)ES(-side terms in this guide
  include:)EP(

  )0 DL(  )0 DT()I(package )SM(git)ES( repos)HY(i)HY(tory)YH()ES(
  )DD(The )SM(git)ES( repos)HY(i)HY(tory)YH( that hosts the package of the upstream
  project.

  )0 DT()I(multi-package repos)HY(i)HY(tory)YH()ES(
  )DD(Some)HY(times)YH( it makes sense to split the upstream project into multi)HY(ple)YH(
  )SM(build2)ES( pack)HY(ages)YH( \201for example, a library and an executable\202. In
  this case the package repos)HY(i)HY(tory)YH( struc)HY(ture)YH( must become multi-package.
  )LD(

  )0 1 3 H(2)WB 109 Sn()WB 5 Sn( Common Guide)HY(lines)YH()EH(

  )0 P(This chapter describes the recom)HY(mended)YH( sequence of steps for pack)HY(ag)HY(ing)YH( a
  third-party project for )SM(build2)ES( with the end-goal of publish)HY(ing)YH(
  it to the )R1 2 A(cppget.org)EA( package
  repos)HY(i)HY(tory)YH(.)EP(

  )0 2 4 H(2.1)WB 110 Sn()WB 6 Sn( Setup the package repos)HY(i)HY(tory)YH()EH(

  )0 P(This section covers the creation of the package )SM(git)ES(
  repos)HY(i)HY(tory)YH( and the impor)HY(ta)HY(tion)YH( of the upstream source code.)EP(

  )0 3 5 H(2.1.1)WB 111 Sn()WB 7 Sn( Check if package repos)HY(i)HY(tory)YH( already
  exists)EH(

  )0 P(Before decid)HY(ing)YH( to package a third-party project you have presum)HY(ably)YH(
  checked on )R1 2 A(cppget.org)EA( if someone has
  already pack)HY(aged)YH( it. There are several other places that make sense to check
  as well:)EP(

  )UL(  )-1 LI()R7 2 A(queue.cppget.org)EA( contains
  pack)HY(ages)YH( that have been submit)HY(ted)YH( but not yet published.

  )-1 LI()R8 2 A(queue.stage.build2.org)EA(
  contains pack)HY(ages)YH( that have been submit)HY(ted)YH( but can only be published after
  the next release of the )SM(build2)ES( toolchain \201see )0 104 1 A(Where to publish if package requires staged
  toolchain?)104 0 TN TL()Ec /AF f D( for back)HY(ground)YH(\202.

  )-1 LI()R5 2 A(github.com/build2-pack)HY(ag)HY(ing)YH()EA(
  contains all the third-party package repos)HY(i)HY(to)HY(ries)YH(. Someone could already be
  working on the package but haven't yet published it.

  )-1 LI()R9 2 A(github.com/build2-pack)HY(ag)HY(ing)YH(/WISH)HY(LIST)YH()EA(
  contains as issues projects that people wish were pack)HY(aged)YH(. These may
  contain offers to collab)HY(o)HY(rate)YH( or announce)HY(ments)YH( of ongoing work.
  )LU(

  )0 P(In all these cases you should be able to locate the package
  )SM(git)ES( repos)HY(i)HY(tory)YH( and/or connect with others in order to
  collab)HY(o)HY(rate)YH( on the pack)HY(ag)HY(ing)YH( work. If the exist)HY(ing)YH( effort looks aban)HY(doned)YH(
  \201for example, there hasn't been any progress for a while and the exist)HY(ing)YH(
  main)HY(tainer)YH( doesn't respond\202 and you would like to take over the package, )R10 2 A(get in touch)EA(.)EP(

  )0 3 6 H(2.1.2)WB 112 Sn()WB 8 Sn( Use upstream repos)HY(i)HY(tory)YH( name as package
  repos)HY(i)HY(tory)YH( name)EH(

  )0 P(It is almost always best to use the upstream repos)HY(i)HY(tory)YH( name as the
  package repos)HY(i)HY(tory)YH( name. If there is no upstream repos)HY(i)HY(tory)YH( \201for example,
  because the project doesn't use a version control system\202, the name used in
  the source archive distri)HY(bu)HY(tion)YH( would be the natural fall)HY(back)YH( choice.)EP(

  )BR(
  )0 P(See )0 13 1 A(Decide on the package name)13 0 TN TL()Ec /AF f D( for the
  complete picture on choos)HY(ing)YH( names.)EP(
  )BR(

  )0 3 7 H(2.1.3)WB 113 Sn()WB 9 Sn( Create package repos)HY(i)HY(tory)YH( in personal
  workspace)EH(

  )0 P(For a third-party project, the end result that we are aiming for is a
  package repos)HY(i)HY(tory)YH( under the )R5 2 A(github.com/build2-pack)HY(ag)HY(ing)YH()EA(
  orga)HY(ni)HY(za)HY(tion)YH(.)EP(

  )BR(
  )0 P(We require all the third-party projects that are published to )R1 2 A(cppget.org)EA( to be under the )R5 2 A(github.com/build2-pack)HY(ag)HY(ing)YH()EA(
  orga)HY(ni)HY(za)HY(tion)YH( in order to ensure some conti)HY(nu)HY(ity)YH( in case the orig)HY(i)HY(nal)YH(
  main)HY(tainer)YH( loses inter)HY(est)YH(, etc. You will still be the owner of the
  repos)HY(i)HY(tory)YH( and by hosting your pack)HY(ag)HY(ing)YH( efforts under this orga)HY(ni)HY(za)HY(tion)YH( \201as
  opposed to, say, your personal workspace\202 you make it easier for others to
  discover your work and to contribute to the package main)HY(te)HY(nance)YH(.)EP(

  )0 P(Note that this require)HY(ment)YH( does not apply to your own projects \201that is,
  where you are the upstream\202 and where the )SM(build2)ES( support is
  normally part of the upstream repos)HY(i)HY(tory)YH(.)EP(

  )0 P(Finally, a note on the use of )SM(git)ES( and GitHub: if for some
  reason you are unable to use either, )R10 2 A(get in touch)EA( to discuss
  alter)HY(na)HY(tives)YH(.)EP(
  )BR(

  )0 P(However, the recom)HY(mended)YH( approach is to start with a repos)HY(i)HY(tory)YH( in your
  personal workspace and then, when it is ready or in a reason)HY(ably)YH( complete
  state, trans)HY(fer)YH( it to )R5 2 A(github.com/build2-pack)HY(ag)HY(ing)YH()EA(.
  This gives you the freedom to make destruc)HY(tive)YH( changes to the repos)HY(i)HY(tory)YH(
  \201includ)HY(ing)YH( delet)HY(ing)YH( it and start)HY(ing)YH( over\202 during the initial pack)HY(ag)HY(ing)YH( work.
  It also removes the pres)HY(sure)YH( to perform: you can give it a try and if things
  turn out more diffi)HY(cult)YH( than you expected, you can just drop the
  repos)HY(i)HY(tory)YH(.)EP(

  )BR(
  )0 P(For repos)HY(i)HY(to)HY(ries)YH( under )R5 2 A(github.com/build2-pack)HY(ag)HY(ing)YH()EA(
  the )SM(master)ES(/)SM(main)ES( branch is protected: it cannot be
  deleted and its commit history cannot be over)HY(writ)HY(ten)YH( with a forced push.)EP(
  )BR(

  )BR(
  )0 P(While you can use any name for a repos)HY(i)HY(tory)YH( under the personal workspace,
  under )R5 2 A(github.com/build2-pack)HY(ag)HY(ing)YH()EA(
  it should follow the )0 8 1 A(Use upstream repos)HY(i)HY(tory)YH( name
  as package repos)HY(i)HY(tory)YH( name)8 0 TN TL()Ec /AF f D( guide)HY(line)YH(. In partic)HY(u)HY(lar)YH(, there should be no
  prefixes like )SM(build2-)ES( or suffixes like )SM(-package)ES(.
  If the repos)HY(i)HY(tory)YH( under your personal workspace does not follow this
  guide)HY(line)YH(, you will need to rename it before trans)HY(fer)HY(ring)YH( it to the )R5 2 A(github.com/build2-pack)HY(ag)HY(ing)YH()EA(
  orga)HY(ni)HY(za)HY(tion)YH(.)EP(
  )BR(

  )0 P(There is one poten)HY(tial)YH( problem with this approach: it is possi)HY(ble)YH( that
  several people will start working on the same third-party project without
  being aware of each other's efforts. If the project you are pack)HY(ag)HY(ing)YH( is
  rela)HY(tively)YH( small and you don't expect it to take more than a day or two,
  then this is prob)HY(a)HY(bly)YH( not worth worry)HY(ing)YH( about. For bigger projects,
  however, it makes sense to announce your work by creat)HY(ing)YH( \201or updat)HY(ing)YH(\202 the
  corre)HY(spond)HY(ing)YH( issue in )R11 2 A(github.com/build2-pack)HY(ag)HY(ing)YH(/WISH)HY(LIST)YH()EA(.)EP(

  )0 P(To put it all together, the recom)HY(mended)YH( sequence of actions for this
  step:)EP(

  )4 OL(  )-1 LI(Create a new empty repos)HY(i)HY(tory)YH( under your personal workspace from the
  GitHub UI.

  )-1 LI(Set the repos)HY(i)HY(tory)YH( descrip)HY(tion)YH( to )SM(build2 package for
  <name>)ES(, where )SM(<name>)ES( is the third-party project
  name.

  )-1 LI(Make the repos)HY(i)HY(tory)YH( public \201other)HY(wise)YH( you won't be able to CI it\202.

  )-1 LI(Don't auto)HY(mat)HY(i)HY(cally)YH( add any files \201)SM(README)ES(,
  )SM(LICENSE)ES(, etc\202.

  )-1 LI(Clone the empty repos)HY(i)HY(tory)YH( to your machine \201using the SSH
  proto)HY(col)YH(\202.
  )LO(

  )BR(
  )0 P(Since this is your personal repos)HY(i)HY(tory)YH(, you can do the initial work
  directly in )SM(master)ES(/)SM(main)ES( or in a sepa)HY(rate)YH( branch,
  it's up to you.)EP(
  )BR(

  )0 P(As a running example, let's assume we want to package a library called
  )SM(foo)ES( whose upstream repos)HY(i)HY(tory)YH( is at
  )SM(https://github.com/<upstream>/foo.git)ES(. We have created its
  package repos)HY(i)HY(tory)YH( at )SM(https://github.com/<personal>/foo.git)ES(
  \201with the )SM(build2 package for foo)ES( descrip)HY(tion)YH(\202 and can now clone
  it:)EP(

  ) 1 45 PR($ git clone git@github.com:<personal>/foo.git)RP(

  )0 3 8 H(2.1.4)WB 114 Sn()WB 10 Sn( Initial)HY(ize)YH( package repos)HY(i)HY(tory)YH( with )SM(bdep
  new)ES()EH(

  )0 P(Change to the root direc)HY(tory)YH( of the package repos)HY(i)HY(tory)YH( that you have
  cloned in the previ)HY(ous)YH( step and run \201contin)HY(u)HY(ing)YH( with our )SM(foo)ES(
  example\202:)EP(

  ) 12 50 PR($ cd foo/ # Change to the package repository root.
$ bdep new --type empty,third-party
$ tree -a .
./
|-- .bdep/
|\302\240\302\240 \267-- ...
|-- .git/
|\302\240\302\240 \267-- ...
|-- .gitattributes
|-- .gitignore
|-- README.md
\267-- repositories.manifest)RP(

  )BR(
  )0 P(We use the special )SM(third-party)ES( sub-option which is meant for
  convert)HY(ing)YH( third-party projects to )SM(build2)ES(. See )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA( for
  details.)EP(
  )BR(

  )0 P(This command creates a number of files in the root of the repos)HY(i)HY(tory)YH(:)EP(

  )0 DL(  )0 DT()SM(README.md)ES(
  )DD(This is the repos)HY(i)HY(tory)YH( )SM(README.md)ES(. We will discuss the
  recom)HY(mended)YH( content for this file later.

  )0 DT()SM(repos)HY(i)HY(to)HY(ries)YH(.mani)HY(fest)YH()ES(
  )DD(This file spec)HY(i)HY(fies)YH( the repos)HY(i)HY(to)HY(ries)YH( from which this project will obtain
  its depen)HY(den)HY(cies)YH( \201see )0 2 A(Adding and
  Remov)HY(ing)YH( Depen)HY(den)HY(cies)YH()EA(\202. If the project you are pack)HY(ag)HY(ing)YH( has no
  depen)HY(den)HY(cies)YH(, then you can safely remove this file \201it's easy to add later
  if this changes\202. And for projects that do have depen)HY(den)HY(cies)YH( we will discuss
  the appro)HY(pri)HY(ate)YH( changes to this file later.

  )0 DT()SM(.gitat)HY(tributes)YH()ES( and
  )SM(.gitig)HY(nore)YH()ES(
  )DD(These are the )SM(git)ES( infras)HY(truc)HY(ture)YH( files for the repos)HY(i)HY(tory)YH(.
  You shouldn't normally need to change anything in them at this stage \201see
  the comments inside for details\202.
  )LD(

  )0 P(Next add and commit these files:)EP(

  ) 4 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Initialize package repository")RP(

  )BR(
  )0 P(In these guide)HY(lines)YH( we will be using the package repos)HY(i)HY(tory)YH( setup that is
  capable of having multi)HY(ple)YH( pack)HY(ages)YH( \201referred to as )I(multi-package
  repos)HY(i)HY(tory)YH()ES(\202. This is recom)HY(mended)YH( even for upstream projects that only
  provides a single package because it gives us the flex)HY(i)HY(bil)HY(ity)YH( of adding new
  pack)HY(ages)YH( at a later stage without having to perform a major restruc)HY(tur)HY(ing)YH( of
  our repos)HY(i)HY(tory)YH(.)EP(

  )0 P(Note also that upstream provid)HY(ing)YH( multi)HY(ple)YH( pack)HY(ages)YH( is not the only
  reason we may end up having multi)HY(ple)YH( )SM(build2)ES( pack)HY(ages)YH(. Another
  common reason is factor)HY(ing)YH( tests into a sepa)HY(rate)YH( package due to a depen)HY(dency)YH(
  on a testing frame)HY(work)YH( \201see )R12 2 A(How
  do I handle tests that have extra depen)HY(den)HY(cies)YH(?)EA( for back)HY(ground)YH( and
  details\202. While upstream adding new pack)HY(ages)YH( may not be very common,
  upstream decid)HY(ing)YH( to use a testing frame)HY(work)YH( is a lot more plau)HY(si)HY(ble)YH(.)EP(

  )0 P(The only notable draw)HY(back)YH( of using a multi-package setup with a single
  package is the extra subdi)HY(rec)HY(tory)YH( for the package and a few extra files
  \201such as )SM(pack)HY(ages)YH(.mani)HY(fest)YH()ES( that lists the pack)HY(ages)YH(\202 in the root
  of the repos)HY(i)HY(tory)YH(. If you are certain that the project that you are
  convert)HY(ing)YH( is unlikely to have multi)HY(ple)YH( pack)HY(ages)YH( \201for example, because you
  are the upstream\202 and won't need extra depen)HY(den)HY(cies)YH( for its tests \201a
  reason)HY(able)YH( assump)HY(tion)YH( for a C project\202, then you could instead go with the
  single-package repos)HY(i)HY(tory)YH( where the repos)HY(i)HY(tory)YH( root is the package root. See
  )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  for details on how to initial)HY(ize)YH( such a repos)HY(i)HY(tory)YH(. In this guide, however,
  we will continue to assume a multi-package repos)HY(i)HY(tory)YH( setup.)EP(
  )BR(

  )0 3 9 H(2.1.5)WB 115 Sn()WB 11 Sn( Add upstream repos)HY(i)HY(tory)YH( as
  )SM(git)ES( submod)HY(ule)YH()EH(

  )0 P(If the third-party project is avail)HY(able)YH( from a )SM(git)ES(
  repos)HY(i)HY(tory)YH(, then the recom)HY(mended)YH( approach is to use the )SM(git)ES(
  submod)HY(ule)YH( mech)HY(a)HY(nism)YH( to make the upstream source code avail)HY(able)YH( inside the
  package repos)HY(i)HY(tory)YH(, custom)HY(ar)HY(ily)YH( in a subdi)HY(rec)HY(tory)YH( called
  )SM(upstream/)ES(.)EP(

  )BR(
  )0 P(While )SM(git)ES( submod)HY(ules)YH( receive much crit)HY(i)HY(cism)YH(, in our case we
  use them exactly as intended: to select and track specific \201release\202 commits
  of an exter)HY(nal)YH( project. As a result, there is nothing tricky about their use
  for our purpose and all the rele)HY(vant)YH( commands will be provided and
  explained, in case you are not famil)HY(iar)YH( with this )SM(git)ES(
  mech)HY(a)HY(nism)YH(.)EP(
  )BR(

  )0 P(Given the upstream repos)HY(i)HY(tory)YH( URL, to add it as a submod)HY(ule)YH(, run the
  follow)HY(ing)YH( command from the package repos)HY(i)HY(tory)YH( root \201contin)HY(u)HY(ing)YH( with our
  )SM(foo)ES( example\202:)EP(

  ) 2 66 PR($ cd foo/ # Change to the package repository root.
$ git submodule add https://github.com/<upstream>/foo.git upstream)RP(

  )BR(
  )0 P(You should prefer )SM(https://)ES( over )SM(git://)ES( for the
  upstream repos)HY(i)HY(tory)YH( URL since the )SM(git://)ES( proto)HY(col)YH( may not be
  acces)HY(si)HY(ble)YH( from all networks. Natu)HY(rally)YH(, never use a URL that requires
  authen)HY(ti)HY(ca)HY(tion)YH(, for example, SSH \201SSH URLs start with
  )SM(git@github.com)ES( for GitHub\202.)EP(
  )BR(

  )0 P(Besides the repos)HY(i)HY(tory)YH( URL, you also need the commit of the upstream
  release which you will be pack)HY(ag)HY(ing)YH(. It is common prac)HY(tice)YH( to tag releases
  so the upstream tags would be the first place to check. Failing that, you
  can always use the commit id.)EP(

  )0 P(Assum)HY(ing)YH( the upstream release tag you are inter)HY(ested)YH( in is called
  )SM(vX.Y.Z)ES(, to update the )SM(upstream)ES( submod)HY(ule)YH( to point
  to this release commit, run the follow)HY(ing)YH( commands:)EP(

  ) 3 21 PR($ cd upstream/
$ git checkout vX.Y.Z
$ cd ../)RP(

  )0 P(Then add and commit these changes:)EP(

  ) 3 48 PR($ git add .
$ git status
$ git commit -m "Add upstream submodule, vX.Y.Z")RP(

  )0 P(Now we have all the upstream source code for the version that we are
  pack)HY(ag)HY(ing)YH( avail)HY(able)YH( in the )SM(upstream/)ES( subdi)HY(rec)HY(tory)YH( of our
  repos)HY(i)HY(tory)YH(.)EP(

  )0 P(The plan is to then use symbolic links \201symlinks\202 to non-inva)HY(sively)YH(
  overlay the )SM(build2)ES(-related files \201)SM(build)HY(file)YH()ES(,
  )SM(mani)HY(fest)YH()ES(, etc\202 with the upstream source code, if neces)HY(sary)YH(
  adjust)HY(ing)YH( upstream struc)HY(ture)YH( to split it into multi)HY(ple)YH( pack)HY(ages)YH( and/or to
  better align with the source/output layouts recom)HY(mended)YH( by
  )SM(build2)ES( \201see )R13 2 A(Using Symlinks in
  )SM(build2)ES( Projects)EA( for back)HY(ground)YH( and ratio)HY(nale)YH(\202. But before
  we can start adding symlinks to the upstream source \201and other files like
  )SM(README)ES(, )SM(LICENSE)ES(, etc\202, we need to gener)HY(ate)YH( the
  )SM(build)HY(file)YH()ES( templates that match the upstream source code layout.
  This is the subject of the next section.)EP(

  )BR(
  )0 P(While on UNIX-like oper)HY(at)HY(ing)YH( systems symlinks are in widespread use, on
  Windows it's a niche feature that unfor)HY(tu)HY(nately)YH( could be cumber)HY(some)YH( to use
  \201see )R14 2 A(Symlinks
  and Windows)EA( for details\202. However, the flex)HY(i)HY(bil)HY(ity)YH( afforded by symlinks
  when pack)HY(ag)HY(ing)YH( third-party projects is unmatched by any other mech)HY(a)HY(nism)YH( and
  we there)HY(fore)YH( use them despite poten)HY(tially)YH( sub-optimal pack)HY(ag)HY(ing)YH( expe)HY(ri)HY(ence)YH(
  on Windows.)EP(
  )BR(

  )0 2 10 H(2.2)WB 116 Sn()WB 12 Sn( Create package and gener)HY(ate)YH( )SM(build)HY(file)YH()ES(
  templates)EH(

  )0 P(This section covers the addi)HY(tion)YH( of the package to the repos)HY(i)HY(tory)YH( we have
  prepared in the previ)HY(ous)YH( steps and the gener)HY(a)HY(tion)YH( of the
  )SM(build)HY(file)YH()ES( templates that match the upstream source code
  layout.)EP(

  )0 3 11 H(2.2.1)WB 117 Sn()WB 13 Sn( Decide on the package name)EH(

  )0 P(While choos)HY(ing)YH( the package repos)HY(i)HY(tory)YH( name was pretty straight)HY(for)HY(ward)YH(,
  things get less clear cut when it comes to the package name.)EP(

  )BR(
  )0 P(If you need a refresher on the distinc)HY(tion)YH( between projects and pack)HY(ages)YH(,
  see )0 4 1 A(Termi)HY(nol)HY(ogy)YH()4 0 TN TL()Ec /AF f D(.)EP(
  )BR(

  )0 P(Picking a name for a package that provides an executable is still
  rela)HY(tively)YH( straight)HY(for)HY(ward)YH(: you should use the upstream name \201which is
  usually the same as the upstream project name\202 unless there is a good reason
  to deviate. One recom)HY(mended)YH( place to check before decid)HY(ing)YH( on a name is the
  )R15 2 A(Debian package repos)HY(i)HY(tory)YH()EA(. If
  their package name differs from upstream, then there is likely a good reason
  for that and it is worth trying to under)HY(stand)YH( what it is.)EP(

  )BR(
  )0 P(Tip: when trying to find the corre)HY(spond)HY(ing)YH( Debian package, search for the
  executable file name in the package contents if you cannot find the package
  by its upstream name. Also consider search)HY(ing)YH( in the )SM(unsta)HY(ble)YH()ES(
  distri)HY(bu)HY(tion)YH( in addi)HY(tion)YH( to )SM(stable)ES( for newer pack)HY(ages)YH(.)EP(
  )BR(

  )0 P(Picking a name for a package that provides a library is where things can
  get more compli)HY(cated)YH(. While all the recom)HY(men)HY(da)HY(tions)YH( that have been listed
  for executa)HY(bles)YH( apply equally to libraries, there are addi)HY(tional)YH(
  consid)HY(er)HY(a)HY(tions)YH(.)EP(

  )0 P(In )SM(build2)ES( we recom)HY(mend)YH( \201but not require\202 that new library
  projects use a name that starts with )SM(lib)ES( in order to easily
  distin)HY(guish)YH( them from executa)HY(bles)YH( and avoid any clashes, poten)HY(tial)YH( in the
  future \201see )0 2 A(Canon)HY(i)HY(cal)YH(
  Project Struc)HY(ture)YH()EA( for details\202. To illus)HY(trate)YH( the problem, consider the
  )SM(zstd)ES( project which provides a library and an executable. In
  upstream repos)HY(i)HY(tory)YH( both are part of the same code)HY(base)YH( that doesn't try to
  sepa)HY(rate)YH( them into pack)HY(ages)YH( so that, for example, library could be used
  without down)HY(load)HY(ing)YH( and build)HY(ing)YH( the executable. In )SM(build2)ES(,
  however, we do need to split them into two sepa)HY(rate)YH( pack)HY(ages)YH( and both
  pack)HY(ages)YH( cannot be called )SM(zstd)ES(. So we call them
  )SM(zstd)ES( and )SM(libzstd)ES(.)EP(

  )BR(
  )0 P(If you are famil)HY(iar)YH( with the Debian package naming policy, you will
  undoubt)HY(edly)YH( recog)HY(nize)YH( this approach. In Debian all the library pack)HY(ages)YH(
  \201with very few excep)HY(tions)YH(\202 start with the )SM(lib)ES( prefix. So when
  search)HY(ing)YH( for an upstream name in the )R15 2 A(Debian package repos)HY(i)HY(tory)YH()EA( make sure
  to prefix it with )SM(lib)ES( \201unless it already starts with this
  prefix, of course\202.)EP(
  )BR(

  )0 P(This brings the ques)HY(tion)YH( of what to do about third-party libraries:
  should we add the )SM(lib)ES( prefix to the package name if it's not
  already there? Unfor)HY(tu)HY(nately)YH(, there is no clear cut answer and whichever
  deci)HY(sion)YH( you make, there will be draw)HY(backs)YH(. Specif)HY(i)HY(cally)YH(, if you add the
  )SM(lib)ES( prefix, the main draw)HY(back)YH( is that the package name now
  devi)HY(ates)YH( from the upstream name and if the project main)HY(tainer)YH( ever decides
  to add )SM(build2)ES( support to the upstream repos)HY(i)HY(tory)YH(, there could
  be substan)HY(tial)YH( fric)HY(tion)YH(. On the other hand, if you don't add the
  )SM(lib)ES( prefix, then you will always run the risk of a future clash
  with an executable name. And, as was illus)HY(trated)YH( with the )SM(zstd)ES(
  example, a late addi)HY(tion)YH( of an executable won't neces)HY(sar)HY(ily)YH( cause any issues
  to upstream. As a result, we don't have a hard require)HY(ment)YH( for the
  )SM(lib)ES( prefix unless there is already an executable that would
  cause the clash \201this applies even if it's not being pack)HY(aged)YH( yet or is
  provided by an unre)HY(lated)YH( project\202. If you don't have a strong pref)HY(er)HY(ence)YH(, we
  recom)HY(mend)YH( that you add the )SM(lib)ES( prefix \201unless it is already
  there\202. In partic)HY(u)HY(lar)YH(, this will free you from having to check for any
  poten)HY(tial)YH( clashes. See )R16 2 A(How
  should I name pack)HY(ages)YH( when pack)HY(ag)HY(ing)YH( third-party projects?)EA( for
  addi)HY(tional)YH( back)HY(ground)YH( and details.)EP(

  )0 P(To build some intu)HY(ition)YH( for choos)HY(ing)YH( package names, let's consider
  several real exam)HY(ples)YH(. We start with executa)HY(bles)YH(:)EP(

  ) 11 70 PR(  upstream  |   upstream    |   Debian   | build2 package|   build2
project name|executable name|package name|repository name|package name
------------+---------------+------------+---------------+------------
byacc        byacc           byacc        byacc           byacc
sqlite       sqlite3         sqlite3      sqlite          sqlite3
vim          xxd             xxd          xxd             xxd
OpenBSD      m4              -            openbsd-m4      openbsd-m4
qtbase 5     moc             qtbase5-\200    Qt5             Qt5Moc
                             dev-tools
qtbase 6     moc             qt6-base-\200   Qt6             Qt6Moc
                             dev-tools)RP(

  )0 P(The exam)HY(ples)YH( are arranged from the most straight)HY(for)HY(ward)YH( naming to the
  least. The last two exam)HY(ples)YH( show that some)HY(times)YH(, after care)HY(fully)YH(
  consid)HY(er)HY(ing)YH( upstream naming, you never)HY(the)HY(less)YH( have no choice but to ignore
  it and forge your own path.)EP(

  )0 P(Next let's look at library exam)HY(ples)YH(. Notice that some use the same
  )SM(build2)ES( package repos)HY(i)HY(tory)YH( name as the executa)HY(bles)YH( above. This
  means they are part of the same multi-package repos)HY(i)HY(tory)YH(.)EP(

  ) 11 70 PR(  upstream  |  upstream     |   Debian   | build2 package|   build2
project name|library name   |package name|repository name|package name
------------+---------------+------------+---------------+------------
libevent     libevent        libevent     libevent        libevent
brotli       brotli          libbrotli    brotli          libbrotli
zlib         zlib            zlib         zlib            libz
sqlite       libsqlite3      libsqlite3   sqlite          libsqlite3
libsig\200      libsigc++       libsigc++    libsig\200         libsigc++
cplusplus                                 cplusplus
qtbase 5     QtCore          qtbase5-dev  Qt5             libQt5Core
qtbase 6     QtCore          qt6-base-dev Qt6             libQt6Core)RP(

  )0 P(If an upstream project is just a single library, then the project name is
  normally the same as the library name \201but there are excep)HY(tions)YH(, like
  )SM(libsigc)HY(plus)HY(plus)YH()ES( in the above table\202. However, when looking at
  the upstream repos)HY(i)HY(tory)YH( that contains multi)HY(ple)YH( compo)HY(nents)YH( \201libraries and/or
  executa)HY(bles)YH(, like )SM(qtcore)ES( in the above example\202, it may not be
  imme)HY(di)HY(ately)YH( obvious what the upstream's library names are. In such cases,
  the corre)HY(spond)HY(ing)YH( Debian pack)HY(ages)YH( can really help clarify the situ)HY(a)HY(tion)YH(.
  Failing that, look into the exist)HY(ing)YH( build system. In partic)HY(u)HY(lar)YH(, if it
  gener)HY(ates)YH( the )SM(pkg-config)ES( file, then the name of this file is
  usually the upstream library name.)EP(

  )BR(
  )0 P(Looking at the names of the library bina)HY(ries)YH( is less helpful because on
  UNIX-like systems they must start with the )SM(lib)ES( prefix. And on
  Windows the names of library bina)HY(ries)YH( often embed extra infor)HY(ma)HY(tion)YH(
  \201static/import, debug/release, etc\202 and may not corre)HY(spond)YH( directly to the
  library name.)EP(
  )BR(

  )0 P(And, speak)HY(ing)YH( of multi)HY(ple)YH( compo)HY(nents)YH(, if you realize the upstream project
  provides multi)HY(ple)YH( libraries and/or executa)HY(bles)YH(, then you need to decide
  whether to split them into sepa)HY(rate)YH( )SM(build2)ES( pack)HY(ages)YH( and if so,
  how. Here, again, the corre)HY(spond)HY(ing)YH( Debian pack)HY(ages)YH( can be a good refer)HY(ence)YH(
  point. Note, however, that we often deviate from Debian's splits, espe)HY(cially)YH(
  when it comes to libraries. Such differ)HY(ences)YH( are usually due to Debian
  focus)HY(ing)YH( on binary pack)HY(ages)YH( while in )SM(build2)ES( we are focus)HY(ing)YH( on
  source pack)HY(ages)YH(.)EP(

  )0 P(To give a few exam)HY(ples)YH(, )SM(libevent)ES( shown in the above table
  provides several libraries \201)SM(libevent-core)ES(,
  )SM(libevent-extra)ES(, etc\202 and in Debian it is actu)HY(ally)YH( split into
  several binary pack)HY(ages)YH( along these lines. In )SM(build2)ES(, however,
  there is a single source package that provides all these libraries with
  every)HY(thing)YH( except )SM(libevent-core)ES( being optional. An example
  which shows the deci)HY(sion)YH( made in a differ)HY(ent)YH( direc)HY(tion)YH( would be the Boost
  libraries: in Debian all the header-only Boost libraries are bundled into a
  single package while in )SM(build2)ES( they are all sepa)HY(rate)YH(
  pack)HY(ages)YH(.)EP(

  )0 P(The overall crite)HY(ria)YH( here can be stated as follows: if a small family of
  libraries provide compli)HY(men)HY(tary)YH( func)HY(tion)HY(al)HY(ity)YH( \201like )SM(libevent)ES(\202,
  then we put them all into a single package, usually making the addi)HY(tional)YH(
  func)HY(tion)HY(al)HY(ity)YH( optional. However, if the libraries are inde)HY(pen)HY(dent)YH( \201like
  Boost\202 or provide alter)HY(na)HY(tive)YH( rather than compli)HY(men)HY(tary)YH( func)HY(tion)HY(al)HY(ity)YH( \201for
  example, like differ)HY(ent)YH( back)HY(ends)YH( in )SM(imgui)ES(\202, then we make them
  sepa)HY(rate)YH( pack)HY(ages)YH(. Note that we never bundle an executable and a \201public\202
  library in a single package \201because, when consumed, they usually require
  differ)HY(ent)YH( )0 2 A(depen)HY(dency)YH(
  types)EA(: build-time vs run-time\202.)EP(

  )0 P(Note also that while it's a good idea to decide on the package split and
  all the package names upfront to avoid surprises later, you don't have to
  actu)HY(ally)YH( provide all the pack)HY(ages)YH( right away. For example, if upstream
  provides a library and an executable \201like )SM(zstd)ES(\202, you can start
  with the library and the executable package can be added later \201poten)HY(tially)YH(
  by someone else\202.)EP(

  )BR(
  )0 P(In the "library and executable" case, if you plan to package both, the
  sensi)HY(ble)YH( strat)HY(egy)YH( is to first completely package the library stop)HY(ping)YH( short
  of releas)HY(ing)YH( and publish)HY(ing)YH(, then repeat the same process to package the
  executable, and finally release and publish both.)EP(
  )BR(

  )0 P(Admit)HY(tedly)YH(, the recom)HY(men)HY(da)HY(tions)YH( in this section are all a bit fuzzy and
  one can choose differ)HY(ent)YH( names or differ)HY(ent)YH( package splits that could all
  seem reason)HY(able)YH(. If you are unsure how to split the upstream project or what
  names to use, )R10 2 A(get in
  touch)EA( to discuss the alter)HY(na)HY(tives)YH(. It can be quite painful to change
  these things after you have completed the remain)HY(ing)YH( pack)HY(ag)HY(ing)YH( steps.)EP(

  )0 P(Contin)HY(u)HY(ing)YH( with our )SM(foo)ES( example, we will follow the above
  recom)HY(men)HY(da)HY(tion)YH( and call the library package )SM(libfoo)ES(.)EP(

  )0 3 12 H(2.2.2)WB 118 Sn()WB 14 Sn( Decide on the package source code
  layout)EH(

  )0 P(Another aspect we need to decide on is the source code layout inside the
  package. Here we want to stay as close to the upstream layout as possi)HY(ble)YH(
  unless there are valid reasons to deviate. Staying close has the best chance
  of giving us a build without any compile errors since the header inclu)HY(sion)YH(
  in the project can be sensi)HY(tive)YH( to this layout. This also makes it easier
  for upstream to adopt the )SM(build2)ES( build.)EP(

  )0 P(Some)HY(times)YH(, however, there are good reasons for devi)HY(at)HY(ing)YH( from upstream,
  espe)HY(cially)YH( in cases where upstream is clearly follow)HY(ing)YH( bad prac)HY(tices)YH(, for
  example includ)HY(ing)YH( gener)HY(i)HY(cally)YH(-named public headers without the library name
  as a subdi)HY(rec)HY(tory)YH( prefix. If you do decide to change the layout, it's
  usually less disrup)HY(tive)YH( \201to the build\202 to rear)HY(range)YH( things at the outer
  levels than at the inner. For example, it should normally be possi)HY(ble)YH( to
  move/rename the top-level )SM(tests/)ES( direc)HY(tory)YH( or to place the
  library source files into a subdi)HY(rec)HY(tory)YH(.)EP(

  )0 P(Our overall plan is to create the initial layout and
  )SM(build)HY(file)YH()ES( templates auto)HY(mat)HY(i)HY(cally)YH( using )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA( in
  the )SM(--package)ES( mode, then "fill" the package with upstream
  source code using symlinks, and finish off with tweak)HY(ing)YH( the gener)HY(ated)YH(
  )SM(build)HY(files)YH()ES( to match the upstream build.)EP(

  )0 P(The main ratio)HY(nale)YH( for using )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  instead of doing every)HY(thing)YH( by hand is that there are many nuances in
  getting the build right and auto-gener)HY(ated)YH( )SM(build)HY(files)YH()ES( had years
  of refine)HY(ment)YH( and fine-tuning. The famil)HY(iar)YH( struc)HY(ture)YH( also makes it easier
  for others to under)HY(stand)YH( your build, for example while review)HY(ing)YH( your
  package submis)HY(sion)YH( or helping out with main)HY(te)HY(nance)YH(.)EP(

  )0 P(The )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  command supports a wide variety of )0 2 A(source layouts)EA(. While it
  may take a bit of time to under)HY(stand)YH( the customiza)HY(tion)YH( points neces)HY(sary)YH( to
  achieve the desired layout for your first package, this expe)HY(ri)HY(ence)YH( will pay
  off in spades when you work on convert)HY(ing)YH( subse)HY(quent)YH( pack)HY(ages)YH(.)EP(

  )0 P(And so the focus of the follow)HY(ing)YH( several steps is to iter)HY(a)HY(tively)YH(
  discover the )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  command line that best approx)HY(i)HY(mates)YH( the upstream layout. The recom)HY(mended)YH(
  proce)HY(dure)YH( is as follows:)EP(

  )4 OL(  )-1 LI(Study the upstream source layout and exist)HY(ing)YH(
  build system.

  )-1 LI(Craft and execute the )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  command line neces)HY(sary)YH( to achieve the upstream layout.

  )-1 LI(Study the auto-gener)HY(ated)YH( )SM(build)HY(files)YH()ES(
  for things that don't fit and need to change. But don't rush to start
  manu)HY(ally)YH( editing the result. First get an overview of the required changes
  and then check if it's possi)HY(ble)YH( to achieve these changes auto)HY(mat)HY(i)HY(cally)YH( using
  one of )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  sub-options. If that's the case, delete the package, and restart from step
  2.
  )LO(

  )0 P(This and the follow)HY(ing)YH( two sections discuss each of these steps in more
  detail and also look at some exam)HY(ples)YH(.)EP(

  )0 P(The first step above is to study the upstream project in order to
  under)HY(stand)YH( where the various parts are \201headers, sources, etc\202 and how they
  are built. Things that can help here include:)EP(

  )UL(  )-1 LI(Read through the exist)HY(ing)YH( build system defi)HY(ni)HY(tions)YH(.

  )-1 LI(Try to build the project using the exist)HY(ing)YH( build system.

  )-1 LI(Try to install the project using the exist)HY(ing)YH( build system.

  )-1 LI(Look into the Debian package contents to see if there are any
  differ)HY(ences)YH( with regards to the instal)HY(la)HY(tion)YH( loca)HY(tions)YH(.
  )LU(

  )BR(
  )0 P(If while study)HY(ing)YH( the upstream build system you notice other
  require)HY(ments)YH(, for example, the need to compile source files other than C/C++
  \201such as Objec)HY(tive)YH(-C/C++, assem)HY(bler)YH(, etc\202 or the need to gener)HY(ate)YH( files from
  )SM(.in)ES( templates \201or their )SM(.cmake)ES(/)SM(.meson)ES(
  equiv)HY(a)HY(lents)YH(\202, and are wonder)HY(ing)YH( how they would be handled in the
  )SM(build2)ES( build, see the )0 36 1 A(Adjust source
  )SM(build)HY(file)YH()ES(: extra require)HY(ments)YH()36 0 TN TL()Ec /AF f D( step for a collec)HY(tion)YH( of
  point)HY(ers)YH(.)EP(
  )BR(

  )0 P(For libraries, the first key pieces of infor)HY(ma)HY(tion)YH( we need to find is how
  the public headers are included and where they are installed. The two common
  )I(good)ES( prac)HY(tices)YH( is to either include the public headers with a library
  name as a subdi)HY(rec)HY(tory)YH(, for example,
  )SM(#include\240<foo/util.h>)ES(, or to include the library name
  into each public header name, for example,
  )SM(#include\240<foo-util.h>)ES( or
  )SM(#include\240<foo.h>)ES( \201in the last example the header name
  is the library name itself, which is also fairly common\202. Unfor)HY(tu)HY(nately)YH(,
  there is also a fairly common )I(bad)ES( prac)HY(tice)YH(: having gener)HY(i)HY(cally)YH( named
  headers \201such as )SM(util.h)ES(\202 included without the library name as a
  subdi)HY(rec)HY(tory)YH(.)EP(

  )BR(
  )0 P(The reason this is a bad prac)HY(tice)YH( is that libraries that have such
  headers cannot coexist, neither in the same build nor when installed. See )0 97 1 A(How do I deal with bad header inclu)HY(sion)YH(
  prac)HY(tice)YH(?)97 0 TN TL()Ec /AF f D( if you encounter such a case. See )0 2 A(Canon)HY(i)HY(cal)YH( Project
  Struc)HY(ture)YH()EA( for addi)HY(tional)YH( back)HY(ground)YH( and details.)EP(
  )BR(

  )0 P(Where should we look to get this infor)HY(ma)HY(tion)YH(? While the library source
  files sound like a natural place, often)HY(times)YH( they include own headers with
  the )SM("")ES( style inclu)HY(sion)YH(, either because the headers are in the
  same direc)HY(tory)YH( or because the library build arranges for them to be found
  this way with addi)HY(tional)YH( header search paths. As a result, a better place to
  look could be the library's exam)HY(ples)YH( and/or tests. Some libraries also
  describe which headers they provide and how to include them in their
  docu)HY(men)HY(ta)HY(tion)YH(.)EP(

  )0 P(The way public headers are included normally deter)HY(mines)YH( where they are
  installed. If they are included with a subdi)HY(rec)HY(tory)YH(, then they are normally
  installed into the same subdi)HY(rec)HY(tory)YH( in, say, )SM(/usr/include/)ES(.
  Contin)HY(u)HY(ing)YH( with the above example, a header that is included as
  )SM(<foo/util.h>)ES( would normally be installed as
  )SM(/usr/include/foo/util.h)ES(. On the other hand, if the library name
  is part of the header name, then the headers are usually \201but not always\202
  installed directly into, say, )SM(/usr/include/)ES(, for example as
  )SM(/usr/include/foo-util.h)ES(.)EP(

  )BR(
  )0 P(While these are the commonly used instal)HY(la)HY(tion)YH( schemes, there are
  devi)HY(a)HY(tions)YH(. In partic)HY(u)HY(lar)YH(, in both cases upstream may choose to add an
  addi)HY(tional)YH( subdi)HY(rec)HY(tory)YH( when installing \201so the above exam)HY(ples)YH( will instead
  end up with, say, )SM(/usr/include/foo-v1/foo/util.h)ES( and
  )SM(/usr/include/foo-v1/sub/foo-util.h)ES(\202. See )0 98 1 A(How do I handle extra header
  instal)HY(la)HY(tion)YH( subdi)HY(rec)HY(tory)YH(?)98 0 TN TL()Ec /AF f D( if you encounter such a case.)EP(
  )BR(

  )0 P(The inclu)HY(sion)YH( scheme would normally also be recre)HY(ated)YH( in the upstream
  source code layout. In partic)HY(u)HY(lar)YH(, if upstream includes public headers with
  a subdi)HY(rec)HY(tory)YH( prefix, then this subdi)HY(rec)HY(tory)YH( would normally also be present
  in the upstream layout so that such a header can be included from the
  upstream code)HY(base)YH( directly. As an example, let's say we deter)HY(mined)YH( that
  public headers of )SM(libfoo)ES( are included with the
  )SM(foo/)ES( subdi)HY(rec)HY(tory)YH(, such as )SM(<foo/util.hpp>)ES(. One
  of the typical upstream layouts for such a library would look like this:)EP(

  ) 8 22 PR($ tree upstream/
upstream/
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     \267-- util.hpp
\267-- src/
    |-- priv.hpp
    \267-- util.cpp)RP(

  )0 P(Notice how the )SM(util.hpp)ES( header is in the )SM(foo/)ES(
  subdi)HY(rec)HY(tory)YH( rather than in )SM(include/)ES( directly.)EP(

  )0 P(The second key piece of infor)HY(ma)HY(tion)YH( we need to find is whether and, if
  so, how the public headers and sources are split. For instance, in the above
  example, we can see that public headers go into )SM(include/)ES( while
  sources and private headers go into )SM(src/)ES(. But they could also
  be combined in the same direc)HY(tory)YH(, for example, as in the follow)HY(ing)YH(
  layout:)EP(

  ) 5 16 PR(upstream/
\267-- foo/
    |-- priv.hpp
    |-- util.cpp
    \267-- util.hpp)RP(

  )BR(
  )0 P(In multi-package projects, for example, those that provide both a library
  and an executable, you would also want to under)HY(stand)YH( how the sources are
  split between the pack)HY(ages)YH(.)EP(
  )BR(

  )0 P(If the headers and sources are split into differ)HY(ent)YH( direc)HY(to)HY(ries)YH(, then the
  source direc)HY(tory)YH( may or may not have the inclu)HY(sion)YH( subdi)HY(rec)HY(tory)YH(, similar to
  the header direc)HY(tory)YH(. In the above split layout the )SM(src/)ES(
  direc)HY(tory)YH( doesn't contain the inclu)HY(sion)YH( subdi)HY(rec)HY(tory)YH( \201)SM(foo/)ES(\202
  while the follow)HY(ing)YH( layout does:)EP(

  ) 8 22 PR(upstream/
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     \267-- util.hpp
\267-- src/
    \267-- foo/
        |-- priv.hpp
        \267-- util.cpp)RP(

  )0 P(With the under)HY(stand)HY(ing)YH( of these key prop)HY(er)HY(ties)YH( of upstream layout you
  should be in a good posi)HY(tion)YH( to start craft)HY(ing)YH( the )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  command line that recre)HY(ates)YH( it.)EP(

  )BR(
  )0 P(The )SM(bdep-new)ES( docu)HY(men)HY(ta)HY(tion)YH( uses slightly more general
  termi)HY(nol)HY(ogy)YH( compared to what we used in the previ)HY(ous)YH( section in order to
  also be appli)HY(ca)HY(ble)YH( to projects that use modules instead of headers.)EP(

  )0 P(Specif)HY(i)HY(cally)YH(, the inclu)HY(sion)YH( subdi)HY(rec)HY(tory)YH( \201)SM(foo/)ES(\202 is called
  )I(source subdi)HY(rec)HY(tory)YH()ES( while the header direc)HY(tory)YH(
  \201)SM(include/)ES(\202 and source direc)HY(tory)YH( \201)SM(src/)ES(\202 are called
  )I(header prefix)ES( and )I(source prefix)ES(, respec)HY(tively)YH(.)EP(
  )BR(

  )0 3 13 H(2.2.3)WB 119 Sn()WB 15 Sn( Craft )SM(bdep new)ES( command
  line to create package)EH(

  )0 P(The recom)HY(mended)YH( proce)HY(dure)YH( for this step is to read through the
  )SM(bdep-new)ES('s )0 2 A(SOURCE LAYOUT)EA( section
  \201which contains a large number of exam)HY(ples)YH(\202 while exper)HY(i)HY(ment)HY(ing)YH( with various
  options in an attempt to create the desired layout. If the layout you've got
  isn't quite right yet, simply remove the package direc)HY(tory)YH( along with the
  )SM(pack)HY(ages)YH(.mani)HY(fest)YH()ES( file and try again.)EP(

  )BR(
  )0 P(Next to )SM(pack)HY(ages)YH(.mani)HY(fest)YH()ES(, )SM(bdep-new)ES( will also
  create the "glue" )SM(build)HY(file)YH()ES( that allows build)HY(ing)YH( all the
  pack)HY(ages)YH( from the repos)HY(i)HY(tory)YH( root. You don't need to remove it when
  re-creat)HY(ing)YH( the package.)EP(
  )BR(

  )0 P(Let's illus)HY(trate)YH( this approach on the first split layout from the
  previ)HY(ous)YH( section:)EP(

  ) 7 22 PR(upstream/
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     \267-- util.hpp
\267-- src/
    |-- priv.hpp
    \267-- util.cpp)RP(

  )0 P(We know it's split, so let's start with that and see what we get.
  Remem)HY(ber)YH(, our )SM(foo)ES( package repos)HY(i)HY(tory)YH( that we have cloned and
  initial)HY(ized)YH( earlier looks like this:)EP(

  ) 7 25 PR($ tree foo/
foo/
|-- upstream/
|-- .gitattributes
|-- .gitignore
|-- README.md
\267-- repositories.manifest)RP(

  )0 P(Now we create the )SM(libfoo)ES( package inside:)EP(

  ) 10 55 PR($ cd foo/
$ bdep new --package --lang c++ --type lib,split libfoo
$ tree libfoo/
libfoo/
|-- include/
|\302\240\302\240 \267-- libfoo/
|\302\240\302\240     \267-- foo.hxx
\267-- src/
    \267-- libfoo/
        \267-- foo.cxx)RP(

  )0 P(The outer struc)HY(ture)YH( looks right, but inside )SM(include/)ES( and
  )SM(src/)ES( things are a bit off. Specif)HY(i)HY(cally)YH(, the source
  subdi)HY(rec)HY(tory)YH( should be )SM(foo/)ES(, not )SM(libfoo/)ES(, there
  shouldn't be one inside )SM(src/)ES(, and the file exten)HY(sions)YH( don't
  match upstream. All this can be easily tweaked, however:)EP(

  ) 12 48 PR($ rm -r libfoo/ packages.manifest
$ bdep new --package \200
  --lang c++,cpp     \200
  --type lib,split,subdir=foo,no-subdir-source \200
  libfoo
$ tree libfoo/
libfoo/
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     \267-- foo.hpp
\267-- src/
    \267-- foo.cpp)RP(

  )0 P(The other )SM(bdep-new)ES( sub-options \201see the )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA( man
  page for the complete list\202 that you will likely want to use when pack)HY(ag)HY(ing)YH(
  a third-party project include:)EP(

  )0 DL(  )0 DT()SM()BD(no-version)ES()ES(
  )DD(Omit the auto-gener)HY(ated)YH( version header. Usually upstream will provide
  its own equiv)HY(a)HY(lent)YH( of this func)HY(tion)HY(al)HY(ity)YH(.

  )BR(
  )0 P(Note that even if upstream doesn't provide any version infor)HY(ma)HY(tion)YH(, it's
  not a good idea to try to rectify this by provid)HY(ing)YH( your own version header
  since upstream may add it in a future version and you may end up with a
  conflict. Instead, work with the project authors to rectify this
  upstream.)EP(
  )BR(

  )0 DT()SM()BD(no-symex)HY(port)YH()ES()ES(
  )BR(  )SM()BD(auto-symex)HY(port)YH()ES()ES(
  )DD(The )SM(no-symex)HY(port)YH()ES( sub-option suppresses the gener)HY(a)HY(tion)YH( of
  the DLL symbol export)HY(ing)YH( header. This is an appro)HY(pri)HY(ate)YH( option if upstream
  provides its own symbol export)HY(ing)YH( arrange)HY(ments)YH(.

  )0 P(The )SM(auto-symex)HY(port)YH()ES( sub-option enables auto)HY(matic)YH( DLL symbol
  export)HY(ing)YH( support \201see )0 2 A(Auto)HY(matic)YH(
  DLL Symbol Export)HY(ing)YH()EA( for back)HY(ground)YH(\202. This is an appro)HY(pri)HY(ate)YH( option if
  upstream relies on similar support in the exist)HY(ing)YH( build system. It is also
  recom)HY(mended)YH( that you give this func)HY(tion)HY(al)HY(ity)YH( a try even if upstream does not
  support build)HY(ing)YH( shared libraries on Windows.)EP(

  )0 DT()SM()BD(binless)ES()ES(
  )DD(Create a header-only library. See )0 88 1 A(Don't make
  library header-only if it can be compiled)88 0 TN TL()Ec /AF f D( and )R17 2 A(How
  do I make a header-only C/C++ library?)EA(

  )0 DT()SM()BD(build)HY(file)YH(-in-prefix)ES()ES(
  )DD(Place header/source )SM(build)HY(files)YH()ES( into the header/source
  prefix direc)HY(tory)YH( instead of source subdi)HY(rec)HY(tory)YH(. To illus)HY(trate)YH( the
  differ)HY(ence)YH(, compare these two auto-gener)HY(ated)YH( layouts paying atten)HY(tion)YH( to the
  loca)HY(tion)YH( of )SM(build)HY(files)YH()ES(:

  ) 11 49 PR($ bdep new ... --type lib,split,subdir=foo libfoo
$ tree libfoo/
libfoo/
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     |-- buildfile
|\302\240\302\240     \267-- foo.hpp
\267-- src/
    \267-- foo/
        |-- buildfile
        \267-- foo.cpp)RP(

  ) 11 69 PR($ bdep new ... --type lib,split,subdir=foo,buildfile-in-prefix libfoo
$ tree libfoo/
libfoo/
|-- include/
|\302\240\302\240 |-- foo/
|\302\240\302\240 |\302\240\302\240 \267-- foo.hpp
|\302\240\302\240 \267-- buildfile
\267-- src/
    |-- foo/
    |\302\240\302\240 \267-- foo.cpp
    \267-- buildfile)RP(

  )0 P(Note that this sub-option only makes sense if we have the header and/or
  source prefixes \201)SM(include/)ES( and )SM(src/)ES( in our case\202 as
  well as the source subdi)HY(rec)HY(tory)YH( \201)SM(foo/)ES( in our case\202.)EP(

  )0 P(Why would we want to do this? The main reason is to be able to symlink
  the entire upstream direc)HY(to)HY(ries)YH( rather than indi)HY(vid)HY(ual)YH( files. In the first
  listing, the gener)HY(ated)YH( )SM(build)HY(files)YH()ES( are inside the
  )SM(foo/)ES( subdi)HY(rec)HY(to)HY(ries)YH( which mean we cannot just symlink
  )SM(foo/)ES( from upstream.)EP(

  )0 P(With a large number of files to symlink, this can be such a strong
  moti)HY(va)HY(tion)YH( that it may make sense to invent a source subdi)HY(rec)HY(tory)YH( in the
  source prefix even if upstream doesn't have one. See )0 90 1 A(Don't build your main targets in the
  root )SM(build)HY(file)YH()ES()90 0 TN TL()Ec /AF f D( for details on this tech)HY(nique)YH(.)EP(

  )0 P(Another reason we may want to move )SM(build)HY(files)YH()ES( to prefix is
  to be able to handle upstream projects that have multi)HY(ple)YH( source
  subdi)HY(rec)HY(to)HY(ries)YH(. While this situ)HY(a)HY(tion)YH( is not very common in the header
  prefix, it can be encoun)HY(tered)YH( in the source prefix of more complex projects,
  where upstream wishes to orga)HY(nize)YH( the source files into compo)HY(nents)YH(.)EP(
  )LD(

  )BR(
  )0 P(If upstream uses a mixture of C and C++, then it's recom)HY(mended)YH( to set
  this up using the )SM(--lang)ES( sub-option of )SM(bdep-new)ES(.
  For example:)EP(

  ) 1 27 PR($ bdep new --lang c++,c ...)RP(
  )BR(

  )0 P(Contin)HY(u)HY(ing)YH( with our )SM(libfoo)ES( example, assum)HY(ing)YH( upstream
  provides its own symbol export)HY(ing)YH(, the final )SM(bdep-new)ES( command
  line would be:)EP(

  ) 4 72 PR($ bdep new --package \200
  --lang c++,cpp     \200
  --type lib,split,subdir=foo,no-subdir-source,no-version,no-symexport \200
  libfoo)RP(

  )0 P(When pack)HY(ag)HY(ing)YH( an executable, things are usually quite a bit simpler:
  there is no version header, symbol export)HY(ing)YH(, and the layout is normally
  combined \201since there are no public headers\202. Typi)HY(cally)YH( the only poten)HY(tially)YH(
  tricky deci)HY(sion)YH( you will need to make is whether to use )I(prefix)ES( or
  )I(source subdi)HY(rec)HY(tory)YH()ES(. Most likely it will be )I(prefix)ES( since most
  executable projects will use the )SM("")ES( style inclu)HY(sion)YH( for own
  headers. For example:)EP(

  ) 4 47 PR($ bdep new --package \200
  --lang c++         \200
  --type exe,no-subdir,prefix=foo,export-stub \200
  foo)RP(

  )BR(
  )0 P(The )SM(export-stub)ES( sub-option causes the gener)HY(a)HY(tion)YH( of
  )SM(build/export.build)ES(, an export stub that facil)HY(i)HY(tates)YH( the
  impor)HY(ta)HY(tion)YH( of targets from our package \201see )0 2 A(Target
  Impor)HY(ta)HY(tion)YH()EA( for details\202. The gener)HY(a)HY(tion)YH( of this file for a library is
  the default since it will normally be used by other projects and thus
  imported. An executable, however, will only need an export stub if it can
  plau)HY(si)HY(bly)YH( be used during the build \201see )0 2 A(Build-Time
  Depen)HY(den)HY(cies)YH( and Linked Config)HY(u)HY(ra)HY(tions)YH()EA( for back)HY(ground)YH(\202. Source code
  gener)HY(a)HY(tors)YH( are an obvious example of such executa)HY(bles)YH(. A less obvious
  example would be compres)HY(sion)YH( util)HY(i)HY(ties)YH( such as )SM(gzip)ES( or
  )SM(zstd)ES(. If you are unsure, it's best to provide an export
  stub.)EP(
  )BR(

  )0 3 14 H(2.2.4)WB 120 Sn()WB 16 Sn( Review and test auto-gener)HY(ated)YH(
  )SM(build)HY(file)YH()ES( templates)EH(

  )0 P(Let's get a more complete view of what got gener)HY(ated)YH( by the final
  )SM(bdep-new)ES( command line from the previ)HY(ous)YH( section:)EP(

  ) 21 26 PR($ tree libfoo/
libfoo/
|-- build/
|\302\240\302\240 \267-- ...
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     |-- buildfile
|\302\240\302\240     \267-- foo.hpp
|-- src/
|\302\240\302\240 |-- buildfile
|\302\240\302\240 \267-- foo.cpp
|-- tests/
|\302\240\302\240 |-- build/
|\302\240\302\240 |\302\240\302\240 \267-- ...
|\302\240\302\240 |-- basics/
|\302\240\302\240 |\302\240\302\240 |-- buildfile
|\302\240\302\240 |\302\240\302\240 \267-- driver.cpp
|\302\240\302\240 \267-- buildfile
|-- buildfile
|-- manifest
\267-- README.md)RP(

  )0 P(Once the overall layout looks right, the next step is to take a closer
  look at the gener)HY(ated)YH( )SM(build)HY(files)YH()ES( to make sure that overall they
  match the upstream build. Of partic)HY(u)HY(lar)YH( inter)HY(est)YH( are the header and source
  direc)HY(tory)YH( )SM(build)HY(files)YH()ES( \201)SM(libfoo/include/foo/build)HY(file)YH()ES(
  and )SM(libfoo/src/build)HY(file)YH()ES( in the above listing\202 which define how
  the library is built and installed.)EP(

  )0 P(Here we are focus)HY(ing)YH( on the macro-level differ)HY(ences)YH( that are easier to
  change by tweak)HY(ing)YH( the )SM(bdep-new)ES( command line rather than
  manu)HY(ally)YH(. For example, if we look at the gener)HY(ated)YH( source direc)HY(tory)YH(
  )SM(build)HY(file)YH()ES( and realize it builds a )I(binful)ES( library \201that
  is, a library that includes source files and there)HY(fore)YH( produces library
  bina)HY(ries)YH(\202 while the upstream library is header-only, it is much easier to
  fix this by re-running )SM(bdep-new)ES( with the )SM(binless)ES(
  sub-option than by chang)HY(ing)YH( the )SM(build)HY(files)YH()ES( manu)HY(ally)YH(.)EP(

  )BR(
  )0 P(Don't be tempted to start making manual changes at this stage even if you
  cannot see anything else that can be fixed with a )SM(bdep-new)ES(
  re-run. This is still a dry-run and we will recre)HY(ate)YH( the package one more
  time in the follow)HY(ing)YH( section before start)HY(ing)YH( manual adjust)HY(ments)YH(.)EP(
  )BR(

  )0 P(Besides exam)HY(in)HY(ing)YH( the gener)HY(ated)YH( )SM(build)HY(files)YH()ES(, it's also a good
  idea to build, test, and install the gener)HY(ated)YH( package to make sure
  every)HY(thing)YH( ends up where you expected and matches upstream where neces)HY(sary)YH(.
  In partic)HY(u)HY(lar)YH(, make sure public headers are installed into the same loca)HY(tion)YH(
  as upstream \201unless you have decided to deviate, of course\202 or at least it's
  clear how to tweak the gener)HY(ated)YH( )SM(build)HY(files)YH()ES( to achieve
  this.)EP(

  )BR(
  )0 P(The )SM(bdep-new)ES(-gener)HY(ated)YH( library is a simple "Hello, World!"
  example that can never)HY(the)HY(less)YH( be built, tested, and installed. The idea here
  is to verify it matches upstream using the gener)HY(ated)YH( source files before
  replac)HY(ing)YH( them with the upstream source file symlinks.)EP(

  )0 P(If you are using Windows, then you will need to temporar)HY(ily)YH( replace the
  )SM(no-symex)HY(port)YH()ES( sub-option with )SM(auto-symex)HY(port)YH()ES( in
  order to make the gener)HY(ated)YH( library build)HY(able)YH(. But do not forget to drop
  this sub-option in the next step.)EP(
  )BR(

  )0 P(Note that at this stage it's easiest to build, test, and install in the
  source direc)HY(tory)YH(, skip)HY(ping)YH( the )SM(bdep)ES( initial)HY(iza)HY(tion)YH( of the
  package \201which we would have to de-initial)HY(ize)YH( before we can re-run
  )SM(bdep-new)ES(\202. Continue with the above example, the recom)HY(mended)YH(
  sequence of commands would be:)EP(

  ) 6 44 PR($ cd libfoo/
$ b update
$ b test
$ rm -rf /tmp/install
$ b install config.install.root=/tmp/install
$ b clean)RP(

  )BR(
  )0 P(One rela)HY(tively)YH( common case where the instal)HY(la)HY(tion)YH( loca)HY(tion)YH( may not match
  upstream are libraries that include their headers without the subdi)HY(rec)HY(tory)YH(
  prefix \201for example, )SM(<foo_util.h>)ES( instead of
  )SM(<foo/util.h>)ES(\202. In such cases, in the )SM(bdep-new)ES(
  command, you may want to use )I(prefix)ES( rather than )I(source
  subdi)HY(rec)HY(tory)YH()ES( \201with the latter being the default\202. For example:)EP(

  ) 1 41 PR($ bdep new --lib,no-subdir,prefix=foo ...)RP(

  )0 P(See )0 2 A(SOURCE LAYOUT)EA(
  for details.)EP(
  )BR(

  )0 P(Let's also briefly discuss other subdi)HY(rec)HY(to)HY(ries)YH( and files found in the
  )SM(bdep-new)ES(-gener)HY(ated)YH( )SM(libfoo)ES( package.)EP(

  )0 P(The )SM(build/)ES( subdi)HY(rec)HY(tory)YH( is the stan)HY(dard)YH( )SM(build2)ES(
  place for project-wide build system infor)HY(ma)HY(tion)YH( \201see )0 2 A(Project
  Struc)HY(ture)YH()EA( for details\202. We will look closer at its contents in the
  follow)HY(ing)YH( sections.)EP(

  )0 P(In the root direc)HY(tory)YH( of our package we find the root
  )SM(build)HY(file)YH()ES( and package )SM(mani)HY(fest)YH()ES(. We will be
  tweak)HY(ing)YH( both in the follow)HY(ing)YH( steps. There is also )SM(README.md)ES(
  which we will replace with the upstream symlink.)EP(

  )0 P(The )SM(tests/)ES( subdi)HY(rec)HY(tory)YH( is the stan)HY(dard)YH( )SM(build2)ES(
  tests subpro)HY(ject)YH( \201see )0 2 A(Testing)EA(
  for back)HY(ground)YH( and details\202. While you can suppress its gener)HY(a)HY(tion)YH( with the
  )SM(no-tests)ES( )SM(bdep-new)ES( sub-option, we recom)HY(mend)YH( that
  you keep it and use it as a start)HY(ing)YH( point for porting upstream tests or, if
  upstream doesn't provide any, for a basic "smoke test".)EP(

  )BR(
  )0 P(You can easily add/remove/rename this )SM(tests/)ES( subpro)HY(ject)YH(. The
  only place where it is mentioned explic)HY(itly)YH( and where you will need to make
  changes is the root )SM(build)HY(file)YH()ES(. In partic)HY(u)HY(lar)YH(, if upstream
  provides exam)HY(ples)YH( that you wish to port, it is recom)HY(mended)YH( that you use a
  copy of the gener)HY(ated)YH( )SM(tests/)ES( subpro)HY(ject)YH( as a start)HY(ing)YH( point
  \201not forget)HY(ting)YH( to add the corre)HY(spond)HY(ing)YH( entry in the root
  )SM(build)HY(file)YH()ES(\202.)EP(
  )BR(

  )0 3 15 H(2.2.5)WB 121 Sn()WB 17 Sn( Create final package)EH(

  )0 P(If you are satis)HY(fied)YH( with the )SM(bdep-new)ES( command line and
  there are no more auto)HY(matic)YH( adjust)HY(ments)YH( you can squeeze out of it, then it's
  time to re-run )SM(bdep-new)ES( one last time to create the final
  package.)EP(

  )BR(
  )0 P(While redoing this step later will require more effort, espe)HY(cially)YH( if
  you've made manual modi)HY(fi)HY(ca)HY(tions)YH( to )SM(build)HY(file)YH()ES( and
  )SM(mani)HY(fest)YH()ES(, nothing is set in stone and it can be done again by
  simply remov)HY(ing)YH( the package direc)HY(tory)YH(, remov)HY(ing)YH( \201or editing, if you have
  multi)HY(ple)YH( pack)HY(ages)YH( and only want to redo some of them\202
  )SM(pack)HY(ages)YH(.mani)HY(fest)YH()ES(, and start)HY(ing)YH( over.)EP(
  )BR(

  )0 P(This time, however, we will do things a bit differ)HY(ently)YH( in order to take
  advan)HY(tage)YH( of some addi)HY(tional)YH( automa)HY(tion)YH( offered by
  )SM(bdep-new)ES(.)EP(

  )0 P(Firstly, we will use the special )SM(third-party)ES( sub-option
  which is meant for convert)HY(ing)YH( third-party projects to )SM(build2)ES(.
  Specif)HY(i)HY(cally)YH(, this sub-option auto)HY(mat)HY(i)HY(cally)YH( enables )SM(no-version)ES(
  and )SM(no-symex)HY(port)YH()ES( \201unless )SM(auto-symex)HY(port)YH()ES( is
  spec)HY(i)HY(fied)YH(\202. It also adds a number of values to )SM(mani)HY(fest)YH()ES( that
  makes sense to specify in a package of a third-party project. Finally, it
  gener)HY(ates)YH( the )SM(PACKAGE-README.md)ES( template which describes how to
  use the package from a )SM(build2)ES(-based project \201see the )0 2 A()SM(package-descrip)HY(tion)YH()ES()EA(
  )SM(mani)HY(fest)YH()ES( value for back)HY(ground)YH(\202.)EP(

  )0 P(Secondly, if the package direc)HY(tory)YH( already exists and contains certain
  files, )SM(bdep-new)ES( can take this into account when gener)HY(at)HY(ing)YH( the
  root )SM(build)HY(file)YH()ES( and package )SM(mani)HY(fest)YH()ES(. In
  partic)HY(u)HY(lar)YH(, it will try to guess the license from the )SM(LICENSE)ES(
  file and extract the summary from )SM(README.md)ES( and use this
  infor)HY(ma)HY(tion)YH( in )SM(mani)HY(fest)YH()ES( as well as gener)HY(ated)YH(
  )SM(PACKAGE-README.md)ES(.)EP(

  )BR(
  )0 P(If the file names or formats used by upstream don't match those
  recog)HY(nized)YH( by )SM(bdep-new)ES(, then for now simply omit the
  corre)HY(spond)HY(ing)YH( files from the package direc)HY(tory)YH( and add them later manu)HY(ally)YH(.
  Simi)HY(larly)YH(, if an attempt to extract the infor)HY(ma)HY(tion)YH( is unsuc)HY(cess)HY(ful)YH(, we will
  have a chance to adjust it in )SM(mani)HY(fest)YH()ES( later.)EP(

  )0 P(Specif)HY(i)HY(cally)YH(, for )SM(README)ES(, )SM(bdep-new)ES( recog)HY(nizes)YH(
  )SM(README.md)ES(, )SM(README.txt)ES( and )SM(README)ES( but
  will only attempt to extract the summary from )SM(README.md)ES(.)EP(

  )0 P(For license files, )SM(bdep-new)ES( recog)HY(nizes)YH( )SM(LICENSE)ES(,
  )SM(LICENSE.txt)ES( )SM(LICENSE.md)ES(, )SM(COPYING)ES(, and
  )SM(UNLI)HY(CENSE)YH()ES(.)EP(

  )0 P(For changes-related files, )SM(bdep-new)ES( recog)HY(nizes)YH(
  )SM(NEWS)ES(, )SM(CHANGES)ES(, and )SM(CHANGELOG)ES( in
  various cases as well as with the )SM(.md)ES(, )SM(.txt)ES(
  exten)HY(sions)YH(.)EP(
  )BR(

  )0 P(Contin)HY(u)HY(ing)YH( with our )SM(libfoo)ES( example and assum)HY(ing)YH( upstream
  provides the )SM(README.md)ES(, )SM(LICENSE)ES(, and
  )SM(NEWS)ES( files, we first manu)HY(ally)YH( create the package direc)HY(tory)YH(,
  then add the symlinks, and finally run )SM(bdep-new)ES( \201notice that we
  have replaced )SM(no-version)ES( and )SM(no-symex)HY(port)YH()ES( with
  )SM(third-party)ES( and omitted the package name from the
  )SM(bdep-new)ES( command line since we are running from inside the
  package direc)HY(tory)YH(\202:)EP(

  ) 13 58 PR($ cd foo/ # Change to the package repository root.

$ rm -r libfoo/ packages.manifest
$ mkdir libfoo/

$ cd libfoo/ # Change to the package root.
$ ln -s ../upstream/README.md ./
$ ln -s ../upstream/LICENSE   ./
$ ln -s ../upstream/NEWS      ./

$ bdep new --package \200
  --lang c++,cpp     \200
  --type lib,split,subdir=foo,no-subdir-source,third-party)RP(

  )0 P(The final contents of our package will look like this \201)SM(->)ES(
  denotes a symlink\202:)EP(

  ) 25 39 PR($ cd ../
$ tree libfoo/
libfoo/
|-- build/
|\302\240\302\240 \267-- ...
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     |-- buildfile
|\302\240\302\240     \267-- foo.hpp
|-- src/
|\302\240\302\240 |-- buildfile
|\302\240\302\240 \267-- foo.cpp
|-- tests/
|\302\240\302\240 |-- build/
|\302\240\302\240 |\302\240\302\240 \267-- ...
|\302\240\302\240 |-- basics/
|\302\240\302\240 |\302\240\302\240 |-- buildfile
|\302\240\302\240 |\302\240\302\240 \267-- driver.cpp
|\302\240\302\240 \267-- buildfile
|-- buildfile
|-- manifest
|-- NEWS       -> ../upstream/NEWS
|-- LICENSE    -> ../upstream/LICENSE
|-- README.md  -> ../upstream/README.md
\267-- PACKAGE-README.md)RP(

  )0 P(If auto-detec)HY(tion)YH( of )SM(README)ES(, )SM(LICENSE)ES(, and
  )SM(NEWS)ES( succeeds, then you should see the )SM(summary)ES( and
  )SM(license)ES( values auto)HY(mat)HY(i)HY(cally)YH( popu)HY(lated)YH( in )SM(mani)HY(fest)YH()ES(
  and the symlinked files listed in the root )SM(build)HY(file)YH()ES(.)EP(

  )0 3 16 H(2.2.6)WB 122 Sn()WB 18 Sn( Adjust package version)EH(

  )0 P(While adjust)HY(ing)YH( the )SM(bdep-new)ES(-gener)HY(ated)YH( code is the subject
  of the follow)HY(ing)YH( sections, one tweak that we want to make right away is to
  change the package version in the )SM(mani)HY(fest)YH()ES( file.)EP(

  )0 P(In this guide we will assume the upstream package uses semver \201seman)HY(tic)YH(
  version\202 or semver-like \201that is, has three version compo)HY(nents)YH(\202 and will
  rely on the )I(contin)HY(u)HY(ous)YH( version)HY(ing)YH()ES( feature of )SM(build2)ES( to
  make sure that each commit in our package repos)HY(i)HY(tory)YH( has a distinct version
  \201see )0 2 A(Version)HY(ing)YH(
  and Release Manage)HY(ment)YH()EA( for back)HY(ground)YH(\202.)EP(

  )BR(
  )0 P(If upstream does not use semver, then see )R18 2 A(How
  do I handle projects that don't use seman)HY(tic)YH( version)HY(ing)YH(?)EA( and )R19 2 A(How
  do I handle projects that don't use versions at all?)EA( for avail)HY(able)YH(
  options. If you decide to use the non-semver upstream version as is, then
  you will have to forgo )I(contin)HY(u)HY(ous)YH( version)HY(ing)YH()ES( as well as the use of )0 2 A()SM()BD(bdep-release\2011\202)ES()ES()EA(
  for release manage)HY(ment)YH(. The rest of the guide, however, will still apply. In
  partic)HY(u)HY(lar)YH(, you will still be able to use )0 2 A()SM()BD(bdep-ci\2011\202)ES()ES()EA( and
  )0 2 A()SM()BD(bdep-publish\2011\202)ES()ES()EA(
  with a bit of extra effort.)EP(
  )BR(

  )0 P(The overall plan to imple)HY(ment)YH( contin)HY(u)HY(ous)YH( version)HY(ing)YH( is to start with a
  pre-release snap)HY(shot)YH( of the upstream version, keep it like that while we are
  adjust)HY(ing)YH( the )SM(bdep-new)ES(-gener)HY(ated)YH( package and commit)HY(ting)YH( our
  changes \201at which point we get distinct snap)HY(shot)YH( versions\202, and finally,
  when the package is ready to publish, change to the final upstream version
  with the help of )0 2 A()SM()BD(bdep-release\2011\202)ES()ES()EA(.
  Specif)HY(i)HY(cally)YH(, if the upstream version is
  )SM()I(X)ES(.)I(Y)ES(.)I(Z)ES()ES(, then we start with the
  )SM()I(X)ES(.)I(Y)ES(.)I(Z)ES(-a.0.z)ES( pre-release snap)HY(shot)YH(.)EP(

  )BR(
  )0 P(In contin)HY(u)HY(ous)YH( version)HY(ing)YH( )SM()I(X)ES(.)I(Y)ES(.)I(Z)ES(-a.0.z)ES(
  means a snap)HY(shot)YH( after the \201non-exis)HY(tent)YH(\202 )SM(0)ES(th alpha pre-release
  of the )SM()I(X)ES(.)I(Y)ES(.)I(Z)ES()ES( version. See )0 2 A(Version)HY(ing)YH(
  and Release Manage)HY(ment)YH()EA( for a more detailed expla)HY(na)HY(tion)YH( and exam)HY(ples)YH(.)EP(
  )BR(

  )0 P(Let's see how this works for our )SM(libfoo)ES( example. Say, the
  upstream version that we are pack)HY(ag)HY(ing)YH( is )SM(2.1.0)ES(. This means we
  start with )SM(2.1.0-a.0.z)ES(.)EP(

  )BR(
  )0 P(Natu)HY(rally)YH(, the upstream version that we are using should corre)HY(spond)YH( to
  the commit of the )SM(upstream)ES( submod)HY(ule)YH( we have added in the )0 11 1 A(Add upstream repos)HY(i)HY(tory)YH( as )SM(git)ES(
  submod)HY(ule)YH()11 0 TN TL()Ec /AF f D( step.)EP(
  )BR(

  )0 P(Next we edit the )SM(mani)HY(fest)YH()ES( file in the )SM(libfoo)ES(
  package and change the )SM(version)ES( value to read:)EP(

  ) 1 20 PR(version: 2.1.0-a.0.z)RP(

  )0 P(Let's also commit this initial state of the package for easier
  roll)HY(backs)YH(:)EP(

  ) 4 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Initialize package")RP(

  )0 2 17 H(2.3)WB 123 Sn()WB 19 Sn( Fill package with source code and add
  depen)HY(den)HY(cies)YH()EH(

  )0 P(With the package skele)HY(ton)YH( ready, the next steps are to fill it with
  upstream source code, add depen)HY(den)HY(cies)YH(, and make any neces)HY(sary)YH( manual
  adjust)HY(ments)YH( to the gener)HY(ated)YH( )SM(build)HY(files)YH()ES(, )SM(mani)HY(fest)YH()ES(,
  etc. If we do this all at once, however, it can be hard to pin-point the
  cause of build fail)HY(ures)YH(. For example, if we convert both the library and its
  tests right away and some)HY(thing)YH( doesn't work, it can be hard to deter)HY(mine)YH(
  whether the mistake is in the library or in the tests.  As a result, we are
  going to split this work into a sequence or smaller steps that incre)HY(men)HY(tally)YH(
  replace the )SM(bdep-new)ES(-gener)HY(ated)YH( code with upstream while
  allow)HY(ing)YH( us to test each change indi)HY(vid)HY(u)HY(ally)YH(. We will also commit the
  changes on each step for easy roll)HY(backs)YH(. Specif)HY(i)HY(cally)YH(, the overall plan is
  as follows:)EP(

  )4 OL(  )-1 LI(Initial)HY(ize)YH( \201)SM(bdep-init)ES(\202 the package in one or more build
  config)HY(u)HY(ra)HY(tions)YH(.

  )-1 LI(Add depen)HY(den)HY(cies)YH(, if any.

  )-1 LI(Fill the library with upstream source code.

  )-1 LI(Adjust project-wide and source subdi)HY(rec)HY(tory)YH(
  )SM(build)HY(files)YH()ES(.

  )-1 LI(Make a smoke test for the library.

  )-1 LI(Replace the smoke test with upstream tests.

  )-1 LI(Tweak root )SM(build)HY(file)YH()ES( and )SM(mani)HY(fest)YH()ES(.
  )LO(

  )0 P(The first three steps are the subject of this section with the follow)HY(ing)YH(
  sections cover)HY(ing)YH( the rest of the plan.)EP(

  )BR(
  )0 P(As you become more expe)HY(ri)HY(enced)YH( with pack)HY(ag)HY(ing)YH( third-party projects for
  )SM(build2)ES(, it may make sense to start combin)HY(ing)YH( or omit)HY(ting)YH( some
  steps, espe)HY(cially)YH( for simpler libraries. For example, if you see that a
  library comes with a simple test that shouldn't cause any compli)HY(ca)HY(tions)YH(,
  then you could omit the smoke test.)EP(
  )BR(

  )0 3 18 H(2.3.1)WB 124 Sn()WB 20 Sn( Initial)HY(ize)YH( package in build
  config)HY(u)HY(ra)HY(tions)YH()EH(

  )0 P(Before we start making any changes to the )SM(bdep-new)ES(-gener)HY(ated)YH(
  files, let's initial)HY(ize)YH( the package in at least one build config)HY(u)HY(ra)HY(tion)YH( so
  that we are able to build and test our changes \201see )0 2 A(Getting Started Guide)EA( for
  back)HY(ground)YH( on )SM(bdep)ES(-based devel)HY(op)HY(ment)YH( work)HY(flow)YH(\202. Contin)HY(u)HY(ing)YH( with
  our )SM(libfoo)ES( example from the earlier steps:)EP(

  ) 2 50 PR($ cd foo/ # Change to the package repository root.
$ bdep init -C ../foo-gcc @gcc cc config.cxx=g++)RP(

  )BR(
  )0 P(If you are initial)HY(iz)HY(ing)YH( subse)HY(quent)YH( pack)HY(ages)YH( in the already created
  config)HY(u)HY(ra)HY(tion)YH(, then the command line will be just:)EP(

  ) 1 16 PR($ bdep init @gcc)RP(
  )BR(

  )0 P(Let's build and test the )SM(bdep-new)ES(-gener)HY(ated)YH( package to make
  sure every)HY(thing)YH( is in order:)EP(

  ) 3 13 PR($ bdep update
$ bdep test
$ bdep clean)RP(

  )0 P(You can create addi)HY(tional)YH( config)HY(u)HY(ra)HY(tions)YH(, for example, if you have access
  to several compil)HY(ers)YH(. For instance, to create a build config)HY(u)HY(ra)HY(tion)YH( for
  Clang:)EP(

  ) 1 56 PR($ bdep init -C ../foo-clang @clang cc config.cxx=clang++)RP(

  )0 P(If you would like to perform a certain oper)HY(a)HY(tion)YH( on all the build
  config)HY(u)HY(ra)HY(tions)YH(, pass the )SM(-a|--all)ES( flag to
  )SM(bdep)ES(:)EP(

  ) 3 16 PR($ bdep update -a
$ bdep test -a
$ bdep clean -a)RP(

  )0 P(Let's also verify that the result)HY(ing)YH( package repos)HY(i)HY(tory)YH( is clean \201doesn't
  have any uncom)HY(mit)HY(ted)YH( or untracked files\202:)EP(

  ) 1 12 PR($ git status)RP(

  )0 3 19 H(2.3.2)WB 125 Sn()WB 21 Sn( Add depen)HY(den)HY(cies)YH()EH(

  )0 P(If the upstream project has any depen)HY(den)HY(cies)YH(, now is a good time to
  specify them so that when we attempt to build the upstream source code, they
  are already present.)EP(

  )0 P(Iden)HY(ti)HY(fy)HY(ing)YH( whether the upstream project has depen)HY(den)HY(cies)YH( is not always
  easy. The natural first places to check are the docu)HY(men)HY(ta)HY(tion)YH( and the
  exist)HY(ing)YH( build system. Some)HY(times)YH( projects also bundle their depen)HY(den)HY(cies)YH(
  with the project source code \201also called vendor)HY(ing)YH(\202. So it makes sense to
  look around the upstream repos)HY(i)HY(tory)YH( for anything that looks like bundled
  depen)HY(den)HY(cies)YH(. Normally we would need to "unbun)HY(dle)YH(" such depen)HY(den)HY(cies)YH( when
  convert)HY(ing)YH( to )SM(build2)ES( by instead spec)HY(i)HY(fy)HY(ing)YH( a depen)HY(dency)YH( on an
  exter)HY(nal)YH( package \201see )0 89 1 A(Don't bundle depen)HY(den)HY(cies)YH()89 0 TN TL()Ec /AF f D(
  for back)HY(ground)YH(\202.)EP(

  )BR(
  )0 P(While there are several reasons we insist on unbundling of depen)HY(den)HY(cies)YH(,
  the main one is that bundling can cause multi)HY(ple)YH(, poten)HY(tially)YH( conflict)HY(ing)YH(
  copies of the same depen)HY(dency)YH( to exist in the build. This can cause subtle
  build fail)HY(ures)YH( that are hard to under)HY(stand)YH( and track down.)EP(
  )BR(

  )0 P(One partic)HY(u)HY(larly)YH( common case to check for is bundling of the testing
  frame)HY(work)YH(, such as )R20 2 A()SM(catch2)ES()EA(, by C++ projects.
  If you have iden)HY(ti)HY(fied)YH( that the upstream tests depend on a testing frame)HY(work)YH(
  \201whether bundled or not\202, see )R12 2 A(How
  do I handle tests that have extra depen)HY(den)HY(cies)YH(?)EA( for the recom)HY(mended)YH( way
  to deal with that.)EP(

  )BR(
  )0 P(One special type of depen)HY(dency)YH( which is easy to over)HY(look)YH( is between
  pack)HY(ages)YH( in the same package repos)HY(i)HY(tory)YH(. For example, if we were pack)HY(ag)HY(ing)YH(
  both )SM(libfoo)ES( as well as the )SM(foo)ES( executable that
  depends on it, then the )SM(foo)ES( package has a depen)HY(dency)YH( on
  )SM(libfoo)ES( and it must be spec)HY(i)HY(fied)YH(. In this case we don't need to
  add anything to )SM(repos)HY(i)HY(to)HY(ries)YH(.mani)HY(fest)YH()ES( and in the
  )SM(depends)ES( entry \201see below\202 in )SM(foo)ES('s
  )SM(mani)HY(fest)YH()ES( we will normally use the special
  )SM(==\240$)ES( version constraint, meaning )SM(libfoo)ES(
  should have the same version as )SM(foo)ES( \201see the )0 2 A()SM(depends)ES(
  package )SM(mani)HY(fest)YH()ES( value)EA( for details\202. For example:)EP(

  ) 1 20 PR(depends: libfoo == $)RP(
  )BR(

  )0 P(If you have concluded that the upstream project doesn't have any
  depen)HY(den)HY(cies)YH(, then you can remove )SM(repos)HY(i)HY(to)HY(ries)YH(.mani)HY(fest)YH()ES( from
  the package repos)HY(i)HY(tory)YH( root \201unless you have already done so\202, commit this
  change, and skip the rest of this section.)EP(

  )0 P(And if you are still reading, then we assume you have a list of
  depen)HY(den)HY(cies)YH( you need to add, prefer)HY(ably)YH( with their minimum required
  versions. If you could not iden)HY(tify)YH( the minimum required version for a
  depen)HY(dency)YH(, then you can fall)HY(back)YH( to the latest avail)HY(able)YH( version, as will
  be described in a moment.)EP(

  )0 P(With the list of depen)HY(den)HY(cies)YH( in hand, the next step is to deter)HY(mine)YH(
  whether they are already avail)HY(able)YH( as )SM(build2)ES( pack)HY(ages)YH(. For
  that, head over to )R1 2 A(cppget.org)EA( and search
  for each depen)HY(dency)YH(.)EP(

  )0 P(If you are unable to find a package for a depen)HY(dency)YH(, then it means it
  hasn't been pack)HY(aged)YH( for )SM(build2)ES( yet. Check the places mentioned
  in the )0 7 1 A(Check if package repos)HY(i)HY(tory)YH( already
  exists)7 0 TN TL()Ec /AF f D( step to see if perhaps someone is already working on the package.
  If not and the depen)HY(dency)YH( is not optional, then the only way forward is to
  first package the depen)HY(dency)YH(.)EP(

  )0 P(If you do find a package for a depen)HY(dency)YH(, then note the section of the
  repos)HY(i)HY(tory)YH( \201)SM(stable)ES(, )SM(testing)ES(, etc; see )0 2 A(Package
  Repos)HY(i)HY(to)HY(ries)YH()EA( for back)HY(ground)YH(\202 from which the minimum required version of
  the package is avail)HY(able)YH(. If you were unable to iden)HY(tify)YH( the minimum
  required version, then note the latest version avail)HY(able)YH( from the
  )SM(stable)ES( section.)EP(

  )0 P(Given the list of repos)HY(i)HY(tory)YH( sections, edit the
  )SM(repos)HY(i)HY(to)HY(ries)YH(.mani)HY(fest)YH()ES( file in the package repos)HY(i)HY(tory)YH( root and
  uncom)HY(ment)YH( the entry for )SM(cppget.org)ES(:)EP(

  ) 4 41 PR(:
role: prerequisite
location: https://pkg.cppget.org/1/stable
#trust: ...)RP(

  )0 P(Next, replace )SM(stable)ES( at the end of the )SM(loca)HY(tion)YH()ES(
  value with the least stable section from your list. For example, if your
  list contains )SM(stable)ES(, )SM(testing)ES(, and
  )SM(beta)ES(, then you need )SM(beta)ES( \201the sections form a
  hier)HY(ar)HY(chy)YH( and so )SM(beta)ES( includes )SM(testing)ES( which in
  turn includes )SM(stable)ES(\202.)EP(

  )BR(
  )0 P(If you wish, you can also uncom)HY(ment)YH( the )SM(trust)ES( value and
  replace )SM(...)ES( with the )R21 2 A(repos)HY(i)HY(tory)YH( finger)HY(print)YH()EA(. This way you
  won't be prompted to confirm the repos)HY(i)HY(tory)YH( authen)HY(tic)HY(ity)YH( on the first fetch.
  See )0 2 A(Adding and
  Remov)HY(ing)YH( Depen)HY(den)HY(cies)YH()EA( for details.)EP(
  )BR(

  )0 P(Once this is done, edit )SM(mani)HY(fest)YH()ES( in package root and add the
  )SM(depends)ES( value for each depen)HY(dency)YH(. See )0 2 A(Adding and
  Remov)HY(ing)YH( Depen)HY(den)HY(cies)YH()EA( for back)HY(ground)YH(. In partic)HY(u)HY(lar)YH(, here you will use
  the minimum required version \201or the latest avail)HY(able)YH(\202 to form a version
  constraint. Which constraint oper)HY(a)HY(tor)YH( to use will depend on the depen)HY(dency)YH('s
  version)HY(ing)YH( poli)HY(cies)YH(. If the depen)HY(dency)YH( uses semver, then a
  )SM(^)ES(-based constraint is a sensi)HY(ble)YH( default.)EP(

  )0 P(As an example, let's say our )SM(libfoo)ES( depends on
  )SM(libz)ES(, )SM(libasio)ES(, and )SM(libsqlite3)ES(. To
  specify these depen)HY(den)HY(cies)YH( we would add the follow)HY(ing)YH( entries to its
  )SM(mani)HY(fest)YH()ES(:)EP(

  ) 3 27 PR(depends: libz ^1.2.0
depends: libasio ^1.28.0
depends: libsqlite3 ^3.39.4)RP(

  )0 P(With all the depen)HY(den)HY(cies)YH( spec)HY(i)HY(fied)YH(, let's now synchro)HY(nize)YH( the state of
  the build config)HY(u)HY(ra)HY(tions)YH( with our changes by running )0 2 A()SM()BD(bdep-sync\2011\202)ES()ES()EA(
  from the package repos)HY(i)HY(tory)YH( root:)EP(

  ) 1 14 PR($ bdep sync -a)RP(

  )0 P(This command should first fetch the meta)HY(data)YH( for the repos)HY(i)HY(tory)YH( we
  spec)HY(i)HY(fied)YH( in )SM(repos)HY(i)HY(to)HY(ries)YH(.mani)HY(fest)YH()ES( and then fetch, unpack and
  config)HY(ure)YH( each depen)HY(dency)YH( that we spec)HY(i)HY(fied)YH( in )SM(mani)HY(fest)YH()ES(.)EP(

  )BR(
  )0 P(If you have any build-time depen)HY(den)HY(cies)YH( \201see )0 2 A(Build-Time
  Depen)HY(den)HY(cies)YH( and Linked Config)HY(u)HY(ra)HY(tions)YH()EA( for back)HY(ground)YH(\202, then you will
  get a warning about the corre)HY(spond)HY(ing)YH( )SM(config.import.*)ES( vari)HY(able)YH(
  being unused and there)HY(fore)YH( dropped. This is because we haven't yet added the
  corre)HY(spond)HY(ing)YH( )SM(import)ES( direc)HY(tives)YH( to our )SM(build)HY(files)YH()ES(.
  For now you can ignore this warning, which we will fix later, when we adjust
  the gener)HY(ated)YH( )SM(build)HY(files)YH()ES(.)EP(
  )BR(

  )0 P(We can examine the result)HY(ing)YH( state, includ)HY(ing)YH( the version of each
  depen)HY(dency)YH(, with )0 2 A()SM()BD(bdep-status\2011\202)ES()ES()EA(:)EP(

  ) 1 17 PR($ bdep status -ai)RP(

  )0 P(The last step for this section is to commit our changes:)EP(

  ) 4 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Add dependencies")RP(

  )0 3 20 H(2.3.3)WB 126 Sn()WB 22 Sn( Fill with upstream source code)EH(

  )0 P(Now we are ready to begin replac)HY(ing)YH( the )SM(bdep-new)ES(-gener)HY(ated)YH(
  files with upstream source code symlinks. We start with the library's header
  and source files. Contin)HY(u)HY(ing)YH( with our )SM(libfoo)ES( example, this is
  what we currently have \201notice that )SM(LICENSE)ES(,
  )SM(README.md)ES(, and )SM(NEWS)ES( are already symlinks to
  upstream\202:)EP(

  ) 21 50 PR($ cd foo/ # Change to the package repository root.

$ tree libfoo/
libfoo/
|-- build/
|\302\240\302\240 \267-- ...
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     |-- buildfile
|\302\240\302\240     \267-- foo.hpp
|-- src/
|\302\240\302\240 |-- buildfile
|\302\240\302\240 \267-- foo.cpp
|-- tests/
|\302\240\302\240 \267-- ...
|-- buildfile
|-- manifest
|-- NEWS       -> ../upstream/NEWS
|-- LICENSE    -> ../upstream/LICENSE
|-- README.md  -> ../upstream/README.md
\267-- PACKAGE-README.md)RP(

  )0 P(Now we replace gener)HY(ated)YH( )SM(include/foo/foo.hpp)ES( with the
  library's real headers and )SM(src/foo.cpp)ES( with its real source
  files:)EP(

  ) 30 64 PR($ cd libfoo/ # Change to the package root.

$ cd include/foo/
$ rm foo.hpp
$ ln -s ../../../upstream/include/foo/*.hpp ./
$ cd -

$ cd src/
$ rm foo.cpp
$ ln -s ../../upstream/src/*.hpp ./
$ ln -s ../../upstream/src/*.cpp ./
$ cd -

$ tree libfoo/
libfoo/
|-- build/
|\302\240\302\240 \267-- ...
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     |-- buildfile
|\302\240\302\240     |-- core.hpp -> ../../../upstream/include/foo/core.hpp
|\302\240\302\240     \267-- util.hpp -> ../../../upstream/include/foo/util.hpp
|-- src/
|\302\240\302\240 |-- buildfile
|\302\240\302\240 |-- impl.hpp -> ../../upstream/src/impl.hpp
|\302\240\302\240 |-- core.cpp -> ../../upstream/src/core.cpp
|\302\240\302\240 \267-- util.cpp -> ../../upstream/src/util.cpp
|-- tests/
|\302\240\302\240 \267-- ...
\267-- ...)RP(

  )0 P(Note that the wild)HY(cards)YH( used above may not be enough in all situ)HY(a)HY(tions)YH(
  and it's a good idea to manu)HY(ally)YH( examine the rele)HY(vant)YH( upstream direc)HY(to)HY(ries)YH(
  and make sure nothing is missing. Specif)HY(i)HY(cally)YH(, look out for:)EP(

  )UL(  )-1 LI(Header/sources with other exten)HY(sions)YH(, for example, C, Objec)HY(tive)YH(-C,
  etc.

  )-1 LI(Other files that may be needed, for example, )SM(.def)ES(,
  )SM(config.h.in)ES(, etc.

  )-1 LI(Subdi)HY(rec)HY(to)HY(ries)YH( that contain more header/source files.
  )LU(

  )0 P(If upstream contains subdi)HY(rec)HY(to)HY(ries)YH( with addi)HY(tional)YH( header/source files,
  then you can symlink entire subdi)HY(rec)HY(to)HY(ries)YH( instead of doing it file by file.
  For example, let's say )SM(libfoo)ES('s upstream source direc)HY(tory)YH(
  contains the )SM(impl/)ES( subdi)HY(rec)HY(tory)YH( with addi)HY(tional)YH( source
  files:)EP(

  ) 21 49 PR($ cd src/
$ ln -s ../../upstream/impl ./
$ cd -

$ tree libfoo/
libfoo/
|-- build/
|\302\240\302\240 \267-- ...
|-- include/
|\302\240\302\240 \267-- ...
|-- src/
|\302\240\302\240 |-- impl/ -> ../../upstream/src/impl/
|\302\240\302\240 |\302\240\302\240 |-- bar.cpp
|\302\240\302\240 |\302\240\302\240 \267-- baz.cpp
|\302\240\302\240 |-- buildfile
|\302\240\302\240 |-- impl.hpp -> ../../upstream/src/impl.hpp
|\302\240\302\240 |-- core.cpp -> ../../upstream/src/core.cpp
|\302\240\302\240 \267-- util.cpp -> ../../upstream/src/util.cpp
|-- tests/
|\302\240\302\240 \267-- ...
\267-- ...)RP(

  )0 P(Wouldn't it be nice if we could symlink the entire top-level
  subdi)HY(rec)HY(to)HY(ries)YH( \201)SM(include/foo/)ES( and )SM(src/)ES( in our case\202
  instead of symlink)HY(ing)YH( indi)HY(vid)HY(ual)YH( files? As discussed in )0 15 1 A(Craft )SM(bdep new)ES( command line to
  create package)15 0 TN TL()Ec /AF f D(, we can, but we will need to change the package layout.
  Specif)HY(i)HY(cally)YH(, we will need to move the )SM(build)HY(files)YH()ES( out of the
  source subdi)HY(rec)HY(to)HY(ries)YH( with the help of the )SM(build)HY(file)YH(-in-prefix)ES(
  sub-option of )SM(bdep-new)ES(. In the above case, we will also need to
  invent a source subdi)HY(rec)HY(tory)YH( in )SM(src/)ES(. Whether this is a
  worth)HY(while)YH( change largely depends on how many files you have to symlink
  indi)HY(vid)HY(u)HY(ally)YH(. If it's just a handful, then it's prob)HY(a)HY(bly)YH( not worth the
  compli)HY(ca)HY(tion)YH(, espe)HY(cially)YH( if you have to invent source subdi)HY(rec)HY(to)HY(ries)YH(. On the
  other hand, if you are looking at symlink)HY(ing)YH( hundreds of files, chang)HY(ing)YH( the
  layout makes perfect sense.)EP(

  )BR(
  )0 P(One minor draw)HY(back)YH( of symlink)HY(ing)YH( entire direc)HY(to)HY(ries)YH( is that you cannot
  easily patch indi)HY(vid)HY(ual)YH( upstream files \201see )0 93 1 A(How do I patch upstream source
  code?)93 0 TN TL()Ec /AF f D(\202.)EP(

  )0 P(You will also need to explic)HY(itly)YH( list such direc)HY(to)HY(ries)YH( as symlinks in
  )SM(.gitat)HY(tributes)YH()ES( if you want your package to be usable from the
  )SM(git)ES( repos)HY(i)HY(tory)YH( directly on Windows. See )R14 2 A(Symlinks and
  Windows)EA( for details.)EP(
  )BR(

  )0 P(We won't be able to test this change yet because to make things build we
  will most likely also need to tweak the gener)HY(ated)YH( )SM(build)HY(files)YH()ES(,
  which is the subject of the next section. However, it still makes sense to
  commit our changes to make roll)HY(backs)YH( easier:)EP(

  ) 4 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Add upstream source symlinks")RP(

  )0 2 21 H(2.4)WB 127 Sn()WB 23 Sn( Adjust project-wide and source
  )SM(build)HY(files)YH()ES()EH(

  )0 P(With source code and depen)HY(den)HY(cies)YH( added, the next step is to adjust the
  regen)HY(er)HY(ated)YH( )SM(build)HY(files)YH()ES( that build the library. This involves
  two places: the project-wide build system files in )SM(build/)ES( and
  the source subdi)HY(rec)HY(tory)YH( )SM(build)HY(files)YH()ES( \201in )SM(include/)ES(
  and )SM(src/)ES( for our )SM(libfoo)ES( example\202.)EP(

  )0 3 22 H(2.4.1)WB 128 Sn()WB 24 Sn( Adjust project-wide build system files
  in )SM(build/)ES()EH(

  )0 P(We start with review)HY(ing)YH( and adjust)HY(ing)YH( the files in the
  )SM(build/)ES( subdi)HY(rec)HY(tory)YH( of our package, where you will find three
  files:)EP(

  ) 8 50 PR($ cd foo/ # Change to the package repository root.
$ tree libfoo/
libfoo/
|-- build/
|\302\240\302\240 |-- bootstrap.build
|\302\240\302\240 |-- root.build
|\302\240\302\240 \267-- export.build
\267-- ...)RP(

  )0 P(To recap, the first two contain the project-wide build system setup \201see
  )0 2 A(Project
  Struc)HY(ture)YH()EA( for details\202 while the last is an export stub that facil)HY(i)HY(tates)YH(
  the impor)HY(ta)HY(tion)YH( of targets from our package \201see )0 2 A(Target
  Impor)HY(ta)HY(tion)YH()EA( for details\202.)EP(

  )0 P(Normally you don't need to change anything in
  )SM(boot)HY(strap)YH(.build)ES( \235 all it does is specify the build system
  project name and load a stan)HY(dard)YH( set of core build system modules. Like)HY(wise)YH(,
  )SM(export.build)ES( is ok as gener)HY(ated)YH( unless you need to do some)HY(thing)YH(
  special, like export)HY(ing)YH( targets from differ)HY(ent)YH( subdi)HY(rec)HY(to)HY(ries)YH( of your
  package.)EP(

  )0 P(While )SM(root.build)ES( is also often good as is, situ)HY(a)HY(tions)YH( where
  you may need to tweak it are not uncom)HY(mon)YH( and include:)EP(

  )UL(  )-1 LI(Loading an addi)HY(tional)YH( build system module.

  )0 P(For example, if your package makes use of Objec)HY(tive)YH(-C/C++ \201see )0 2 A(Objec)HY(tive)YH(-C
  Compi)HY(la)HY(tion)YH()EA( and )0 2 A(Objec)HY(tive)YH(-C++
  Compi)HY(la)HY(tion)YH()EA(\202 or Assem)HY(bler)YH( \201see )0 2 A(Assem)HY(bler)YH(
  with C Prepro)HY(ces)HY(sor)YH( Compi)HY(la)HY(tion)YH()EA(\202, then )SM(root.build)ES( would be
  the natural place to load the corre)HY(spond)HY(ing)YH( modules.)EP(

  )BR(
  )0 P(If your package uses a mixture of C and C++, then it's recom)HY(mended)YH( to set
  this up using the )SM(--lang)ES( sub-option of )SM(bdep-new)ES(
  rather than manu)HY(ally)YH(. For example:)EP(

  ) 1 27 PR($ bdep new --lang c++,c ...)RP(
  )BR(

  )-1 LI(Spec)HY(i)HY(fy)HY(ing)YH( package config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH(.

  )0 P(If upstream provides the ability to config)HY(ure)YH( their code, for example to
  enable optional features, then you may want to trans)HY(late)YH( this to
  )SM(build2)ES( config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH(, which are spec)HY(i)HY(fied)YH( in
  )SM(root.build)ES( \201see )0 2 A(Project
  Config)HY(u)HY(ra)HY(tion)YH()EA( for back)HY(ground)YH( and details\202.)EP(

  )0 P(Note that you don't need to add all the config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( right
  away. Instead, you could first handle the "core" func)HY(tion)HY(al)HY(ity)YH( which doesn't
  require any config)HY(u)HY(ra)HY(tion)YH( and then add the config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( one by
  one while also making the corre)HY(spond)HY(ing)YH( changes in
  )SM(build)HY(files)YH()ES(.)EP(

  )BR(
  )0 P(One type of config)HY(u)HY(ra)HY(tion)YH( that you should normally not expose when
  pack)HY(ag)HY(ing)YH( for )SM(build2)ES( is support for both header-only and
  compiled modes. See )0 88 1 A(Don't make library
  header-only if it can be compiled)88 0 TN TL()Ec /AF f D( for details.)EP(
  )BR(
  )LU(

  )0 P(Also, in C++ projects, if you don't have any inline or template files,
  then you can drop the assign)HY(ment)YH( of the file exten)HY(sion)YH( for the
  )SM(ixx{})ES( and )SM(txx{})ES( target types, respec)HY(tively)YH(.)EP(

  )0 P(If you have added any config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( and would like to use
  non-default values for some of them in your build, then you will need to
  recon)HY(fig)HY(ure)YH( the package. For example, let's say we have added the
  )SM(config.libfoo.debug)ES( vari)HY(able)YH( to our )SM(libfoo)ES( package
  which enables addi)HY(tional)YH( debug)HY(ging)YH( facil)HY(i)HY(ties)YH( in the library. This is how we
  can recon)HY(fig)HY(ure)YH( all our builds to enable this func)HY(tion)HY(al)HY(ity)YH(:)EP(

  ) 1 39 PR($ bdep sync -a config.libfoo.debug=true)RP(

  )0 P(If you have made any changes, commit them \201similar to the previ)HY(ous)YH( step,
  we cannot test things just yet\202:)EP(

  ) 4 56 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Adjust project-wide build system files")RP(

  )0 3 23 H(2.4.2)WB 129 Sn()WB 25 Sn( Adjust source subdi)HY(rec)HY(tory)YH(
  )SM(build)HY(files)YH()ES()EH(

  )0 P(The last step we need to perform before we can try to build our library
  is to adjust its )SM(build)HY(files)YH()ES(. These )SM(build)HY(files)YH()ES( are
  found in the source subdi)HY(rec)HY(tory)YH( or, if we used the
  )SM(build)HY(file)YH(-in-prefix)ES( )SM(bdep-new)ES( sub-option, in the
  prefix direc)HY(tory)YH(. There will be two )SM(build)HY(files)YH()ES( if we use the
  split layout \201)SM(split)ES( sub-option\202 or a single
  )SM(build)HY(file)YH()ES( in the combined layout. The single
  )SM(build)HY(file)YH()ES( in the combined layout contains essen)HY(tially)YH( the same
  defi)HY(ni)HY(tions)YH( as the split )SM(build)HY(files)YH()ES( but combined into one and
  with some minor simpli)HY(fi)HY(ca)HY(tions)YH( that this allows. Here we will assume the
  split layout and continue with our )SM(libfoo)ES( from the previ)HY(ous)YH(
  sections. To recap, here is the layout we've got with the
  )SM(build)HY(files)YH()ES( of inter)HY(est)YH( found in )SM(include/foo/)ES( and
  in )SM(src/)ES(:)EP(

  ) 16 64 PR(libfoo/
|-- build/
|\302\240\302\240 \267-- ...
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     |-- buildfile
|\302\240\302\240     |-- core.hpp -> ../../../upstream/include/foo/core.hpp
|\302\240\302\240     \267-- util.hpp -> ../../../upstream/include/foo/util.hpp
|-- src/
|\302\240\302\240 |-- buildfile
|\302\240\302\240 |-- impl.hpp -> ../../upstream/src/impl.hpp
|\302\240\302\240 |-- core.cpp -> ../../upstream/src/core.cpp
|\302\240\302\240 \267-- util.cpp -> ../../upstream/src/util.cpp
|-- tests/
|\302\240\302\240 \267-- ...
\267-- ...)RP(

  )BR(
  )0 P(If instead of a library you are pack)HY(ag)HY(ing)YH( an executable, you can skip
  directly to )0 35 1 A(Adjust source
  )SM(build)HY(file)YH()ES(: executa)HY(bles)YH()35 0 TN TL()Ec /AF f D(.)EP(
  )BR(

  )0 3 24 H(2.4.3)WB 130 Sn()WB 26 Sn( Adjust header
  )SM(build)HY(file)YH()ES()EH(

  )0 P(The )SM(build)HY(file)YH()ES( in )SM(include/foo/)ES( is pretty
  simple:)EP(

  )BR(
  )0 P(The )SM(build)HY(file)YH()ES( in your package may look slightly differ)HY(ent)YH(,
  depend)HY(ing)YH( on the exact )SM(bdep-new)ES( sub-options used. However, all
  the rele)HY(vant)YH( defi)HY(ni)HY(tions)YH( discussed below should still be easily
  recog)HY(niz)HY(able)YH(.)EP(
  )BR(

  ) 12 59 PR(pub_hdrs = {hxx ixx txx}{**}

./: $pub_hdrs

# Install into the foo/ subdirectory of, say, /usr/include/
# recreating subdirectories.
#
{hxx ixx txx}{*}:
{
  install         = include/foo/
  install.subdirs = true
})RP(

  )0 P(Normally, the only change that you would make to this
  )SM(build)HY(file)YH()ES( is to adjust the instal)HY(la)HY(tion)YH( loca)HY(tion)YH( of headers
  \201see )0 2 A(Installing)EA(
  for back)HY(ground)YH(\202. In partic)HY(u)HY(lar)YH(, if our headers were included without the
  )SM(<foo/...>)ES( prefix but instead contained the library name in
  their names \201for example, )SM(foo-util.hpp)ES(\202, then the instal)HY(la)HY(tion)YH(
  setup would instead look like this:)EP(

  ) 7 69 PR(# Install directly into say, /usr/include/ recreating subdirectories.
#
{hxx ixx txx}{*}:
{
  install         = include/
  install.subdirs = true
})RP(

  )0 P(If the library doesn't have any headers in nested subdi)HY(rec)HY(to)HY(ries)YH( \201for
  example, )SM(<foo/util/string.hpp>)ES(\202, you can drop the
  )SM(install.subdirs)ES( vari)HY(able)YH(:)EP(

  ) 3 60 PR(# Install into the foo/ subdirectory of, say, /usr/include/.
#
{hxx ixx txx}{*}: install = include/foo/)RP(

  )BR(
  )0 P(In the combined layout, the instal)HY(la)HY(tion)YH(-related defi)HY(ni)HY(tions)YH( are at the
  end of the combined )SM(build)HY(file)YH()ES(.)EP(

  )0 P(Compared to the split layout where the public and private headers are
  sepa)HY(rated)YH( phys)HY(i)HY(cally)YH(, in the combined layout you may need to achieve the
  same result \201that is, avoid installing private headers\202 at the build system
  level. If the library provides only a handful of public headers and this set
  is unlikely to change often, then listing them explic)HY(itly)YH( is the most
  straight)HY(for)HY(ward)YH( approach. For example \201the )SM(@./)ES( qual)HY(i)HY(fier)YH( tells
  )SM(build2)ES( they are in the source direc)HY(tory)YH(\202:)EP(

  ) 4 55 PR(# Only install public headers into, say, /usr/include/.
#
h{foo}@./ h{foo_version}@./: install = include/
h{*}: install = false)RP(
  )BR(

  )0 P(See also )0 98 1 A(How do I handle
  extra header instal)HY(la)HY(tion)YH( subdi)HY(rec)HY(tory)YH(?)98 0 TN TL()Ec /AF f D()EP(

  )0 3 25 H(2.4.4)WB 131 Sn()WB 27 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: overview)EH(

  )0 P(Next is the )SM(build)HY(file)YH()ES( in )SM(src/)ES(:)EP(

  )BR(
  )0 P(Again, the )SM(build)HY(file)YH()ES( in your package may look slightly
  differ)HY(ent)YH(, depend)HY(ing)YH( on the exact )SM(bdep-new)ES( sub-options used.
  However, all the rele)HY(vant)YH( defi)HY(ni)HY(tions)YH( discussed below should still be easily
  recog)HY(niz)HY(able)YH(.)EP(

  )0 P(For a binless \201header-only\202 library, this )SM(build)HY(file)YH()ES( will
  contain only a small subset of the defi)HY(ni)HY(tions)YH( shown below. See )R17 2 A(How
  do I make a header-only C/C++ library?)EA( for addi)HY(tional)YH( consid)HY(er)HY(a)HY(tions)YH(
  when pack)HY(ag)HY(ing)YH( header-only libraries.)EP(
  )BR(

  ) 54 68 PR(intf_libs = # Interface dependencies.
impl_libs = # Implementation dependencies.
#import xxxx_libs += libhello%lib{hello}

# Public headers.
#
pub = [dir_path] ../include/foo/

include $pub

pub_hdrs = $\201$pub/ pub_hdrs\202

lib{foo}: $pub/{$pub_hdrs}

# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx ixx txx cxx}{**} $impl_libs $intf_libs

# Build options.
#
out_pfx_inc = [dir_path] $out_root/include/
src_pfx_inc = [dir_path] $src_root/include/
out_pfx_src = [dir_path] $out_root/src/
src_pfx_src = [dir_path] $src_root/src/

cxx.poptions =+ "-I$out_pfx_src" "-I$src_pfx_src" \200
                "-I$out_pfx_inc" "-I$src_pfx_inc"

#obja{*}: cxx.poptions += -DFOO_STATIC_BUILD
#objs{*}: cxx.poptions += -DFOO_SHARED_BUILD
)WR(
# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$out_pfx_inc" "-I$src_pfx_inc"
  cxx.export.libs = $intf_libs
}

#liba{foo}: cxx.export.poptions += -DFOO_STATIC
#libs{foo}: cxx.export.poptions += -DFOO_SHARED

# For pre-releases use the complete version to make sure they cannot
# be used in place of another pre-release or the final version. See
# the version module for details on the version.* variable values.
#
if $version.pre_release
  lib{foo}: bin.lib.version = "-$version.project_id"
else
  lib{foo}: bin.lib.version = "-$version.major.$version.minor"

# Don't install private headers.
#
{hxx ixx txx}{*}: install = false)RP(

  )0 3 26 H(2.4.5)WB 132 Sn()WB 28 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: cleanup)EH(

  )0 P(As a first step, let's remove all the defi)HY(ni)HY(tions)YH( that we don't need in
  our library. The two common pieces of func)HY(tion)HY(al)HY(ity)YH( that are often not
  needed are support for auto-gener)HY(ated)YH( headers \201such as )SM(config.h)ES(
  gener)HY(ated)YH( from )SM(config.h.in)ES(\202 and depen)HY(den)HY(cies)YH( on other
  libraries.)EP(

  )0 P(If you don't have any auto-gener)HY(ated)YH( headers, then remove all the
  assign)HY(ments)YH( and expan)HY(sions)YH( of the )SM(out_pfx_inc)ES( and
  )SM(out_pfx_src)ES( vari)HY(ables)YH(. Here is what the rele)HY(vant)YH( lines in the
  above )SM(build)HY(file)YH()ES( should look like after this change:)EP(

  ) 13 49 PR(# Build options.
#
src_pfx_inc = [dir_path] $src_root/include/
src_pfx_src = [dir_path] $src_root/src/

cxx.poptions =+ "-I$src_pfx_src" "-I$src_pfx_inc"

# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$src_pfx_inc"
})RP(

  )BR(
  )0 P(If you do have auto-gener)HY(ated)YH( headers, then in the split layout you can
  remove )SM(out_pfx_inc)ES( if you only have private auto-gener)HY(ated)YH(
  headers and )SM(out_pfx_src)ES( if you only have public ones.)EP(
  )BR(

  )BR(
  )0 P(In the combined layout the single )SM(build)HY(file)YH()ES( does not set the
  )SM(*_pfx_*)ES( vari)HY(ables)YH(. Instead it uses the )SM(src_root)ES(
  and )SM(out_root)ES( vari)HY(ables)YH( directly. For example:)EP(

  ) 10 51 PR(# Build options.
#
cxx.poptions =+ "-I$out_root" "-I$src_root"

# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$out_root" "-I$src_root"
})RP(

  )0 P(To remove support for auto-gener)HY(ated)YH( headers in the combined
  )SM(build)HY(file)YH()ES(, simply remove the corre)HY(spond)HY(ing)YH(
  )SM(out_root)ES( expan)HY(sions)YH(:)EP(

  ) 10 37 PR(# Build options.
#
cxx.poptions =+ "-I$src_root"

# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$src_root"
})RP(

  )0 P(If you only have private auto-gener)HY(ated)YH( headers, then only remove the
  expan)HY(sion)YH( from )SM(cxx.export.poptions)ES(.)EP(
  )BR(

  )0 P(If you don't have any depen)HY(den)HY(cies)YH(, then remove all the assign)HY(ments)YH( and
  expan)HY(sions)YH( of the )SM(intf_libs)ES( and )SM(impl_libs)ES(
  vari)HY(ables)YH(. That is, the follow)HY(ing)YH( lines in the orig)HY(i)HY(nal)YH(
  )SM(build)HY(file)YH()ES(:)EP(

  ) 15 57 PR(intf_libs = # Interface dependencies.
impl_libs = # Implementation dependencies.
#import xxxx_libs += libhello%lib{hello}

# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx ixx txx cxx}{**} $impl_libs $intf_libs

# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$out_pfx_inc" "-I$src_pfx_inc"
  cxx.export.libs = $intf_libs
})RP(

  )0 P(Become just these:)EP(

  ) 10 57 PR(# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx ixx txx cxx}{**}

# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$out_pfx_inc" "-I$src_pfx_inc"
})RP(

  )0 3 27 H(2.4.6)WB 133 Sn()WB 29 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: depen)HY(den)HY(cies)YH()EH(

  )0 P(If you do have depen)HY(den)HY(cies)YH(, then let's handle them now.)EP(

  )BR(
  )0 P(Here we will assume depen)HY(den)HY(cies)YH( on other libraries, which is the common
  case. If you have depen)HY(den)HY(cies)YH( on executa)HY(bles)YH(, for example, source code
  gener)HY(a)HY(tors)YH(, see )0 2 A(Build-Time
  Depen)HY(den)HY(cies)YH( and Linked Config)HY(u)HY(ra)HY(tions)YH()EA( on how to handle that. In this
  case you will also need to recon)HY(fig)HY(ure)YH( your package after adding the
  corre)HY(spond)HY(ing)YH( )SM(import)ES( direc)HY(tives)YH( in order to re-acquire the
  previ)HY(ously)YH( dropped )SM(config.import.*)ES( values. Make sure to also
  pass any config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( you spec)HY(i)HY(fied)YH( in )0 24 1 A(Adjust project-wide build system files in
  )SM(build/)ES()24 0 TN TL()Ec /AF f D(. For example:)EP(

  ) 1 51 PR($ bdep sync -a --disfigure config.libfoo.debug=true)RP(
  )BR(

  )0 P(For each library that your package depends on \201and which you have added
  to )SM(mani)HY(fest)YH()ES( in the )0 21 1 A(Add
  depen)HY(den)HY(cies)YH()21 0 TN TL()Ec /AF f D( step\202, you need to first deter)HY(mine)YH( whether it's an
  inter)HY(face)YH( or imple)HY(men)HY(ta)HY(tion)YH( depen)HY(dency)YH( and then import it either into the
  )SM(intf_libs)ES( or )SM(impl_libs)ES( vari)HY(able)YH(, respec)HY(tively)YH(.)EP(

  )0 P(See )0 2 A(Library
  Expor)HY(ta)HY(tion)YH( and Version)HY(ing)YH()EA( for back)HY(ground)YH( on the inter)HY(face)YH( vs
  imple)HY(men)HY(ta)HY(tion)YH( distinc)HY(tion)YH(. But as a quick rule of thumb, if the library you
  are pack)HY(ag)HY(ing)YH( includes a header from the depen)HY(dency)YH( library in one of its
  public headers, then it's an inter)HY(face)YH( depen)HY(dency)YH(. Other)HY(wise)YH(, it's an
  imple)HY(men)HY(ta)HY(tion)YH( depen)HY(dency)YH(.)EP(

  )0 P(Contin)HY(u)HY(ing)YH( with our )SM(libfoo)ES( example, as we have estab)HY(lished)YH(
  in )0 21 1 A(Add depen)HY(den)HY(cies)YH()21 0 TN TL()Ec /AF f D(, it depends on
  )SM(libasio)ES(, )SM(libz)ES(, and )SM(libsqlite3)ES( and
  let's say we've deter)HY(mined)YH( that )SM(libasio)ES( is an inter)HY(face)YH(
  depen)HY(dency)YH( because it's included from )SM(include/foo/core.hpp)ES(
  while the other two are imple)HY(men)HY(ta)HY(tion)YH( depen)HY(den)HY(cies)YH( because they are only
  included from )SM(src/)ES(. Here is how we would change our
  )SM(build)HY(file)YH()ES( to import them:)EP(

  ) 5 43 PR(intf_libs = # Interface dependencies.
impl_libs = # Implementation dependencies.
import intf_libs += libasio%lib{asio}
import impl_libs += libz%lib{z}
import impl_libs += libsqlite3%lib{sqlite3})RP(

  )0 P(You can tidy this a bit further if you would like:)EP(

  ) 3 43 PR(import intf_libs = libasio%lib{asio}
import impl_libs = libz%lib{z}
import impl_libs += libsqlite3%lib{sqlite3})RP(

  )BR(
  )0 P(If you don't have any imple)HY(men)HY(ta)HY(tion)YH( or inter)HY(face)YH( depen)HY(den)HY(cies)YH(, you can
  remove the assign)HY(ment)YH( and all the expan)HY(sions)YH( of the corre)HY(spond)HY(ing)YH(
  )SM(*_libs)ES( vari)HY(able)YH(.)EP(
  )BR(

  )0 P(Note also that system libraries like )SM(-lm)ES(, )SM(-ldl)ES(
  on UNIX or )SM(advapi32.lib)ES(, )SM(ws2_32.lib)ES( on Windows
  should not be imported. Instead, they should be listed in the
  )SM(c.libs)ES( or )SM(cxx.libs)ES( vari)HY(ables)YH(. See )R22 2 A(How
  do I link a system library)EA( for details.)EP(

  )0 3 28 H(2.4.7)WB 134 Sn()WB 30 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: public headers)EH(

  )0 P(With the unnec)HY(es)HY(sary)YH( parts of the )SM(build)HY(file)YH()ES( cleaned up and
  depen)HY(den)HY(cies)YH( handled, let's discuss the common changes to the remain)HY(ing)YH(
  defi)HY(ni)HY(tions)YH(, going from top to bottom. We start with the public headers
  block:)EP(

  ) 9 32 PR(# Public headers.
#
pub = [dir_path] ../include/foo/

include $pub

pub_hdrs = $\201$pub/ pub_hdrs\202

lib{foo}: $pub/{$pub_hdrs})RP(

  )0 P(This block gets hold of the list of public headers and makes them
  prereq)HY(ui)HY(sites)YH( of the library. Normally you shouldn't need to make any
  changes here. If you need to exclude some headers, it should be done in the
  header )SM(build)HY(file)YH()ES( in the )SM(include/)ES( direc)HY(tory)YH(.)EP(

  )BR(
  )0 P(In the combined layout the single )SM(build)HY(file)YH()ES( does not have
  such code. Instead, all the headers are covered by the wild)HY(card)YH( pattern in
  the follow)HY(ing)YH( block.)EP(
  )BR(

  )0 3 29 H(2.4.8)WB 135 Sn()WB 31 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: sources, private headers)EH(

  )0 P(The next block deals with sources, private headers, and depen)HY(den)HY(cies)YH(, if
  any:)EP(

  ) 3 54 PR(# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx ixx txx cxx}{**} $impl_libs $intf_libs)RP(

  )0 P(By default it will list all the rele)HY(vant)YH( files as prereq)HY(ui)HY(sites)YH( of the
  library, start)HY(ing)YH( from the direc)HY(tory)YH( of the )SM(build)HY(file)YH()ES( and
  includ)HY(ing)YH( all the subdi)HY(rec)HY(to)HY(ries)YH(, recur)HY(sively)YH( \201see )0 2 A(Name
  Patterns)EA( for back)HY(ground)YH( on wild)HY(card)YH( patterns\202.)EP(

  )0 P(If your C++ package doesn't have any inline or template files, then you
  can remove the )SM(ixx)ES( and )SM(txx)ES( target types,
  respec)HY(tively)YH( \201which would be paral)HY(lel)YH( to the change made in
  )SM(root.build)ES(; see )0 24 1 A(Adjust
  project-wide build system files in )SM(build/)ES()24 0 TN TL()Ec /AF f D(\202. For
  example:)EP(

  ) 3 54 PR(# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx cxx}{**} $impl_libs $intf_libs)RP(

  )BR(
  )0 P(Source files other than C/C++ \201for example, Assem)HY(bler)YH(, Objec)HY(tive)YH(-C/C++\202
  are dealt with in )0 36 1 A(Adjust source
  )SM(build)HY(file)YH()ES(: extra require)HY(ments)YH()36 0 TN TL()Ec /AF f D( below.)EP(
  )BR(

  )0 P(The other common change to this block is the exclu)HY(sion)YH( of certain files
  or making them condi)HY(tion)HY(ally)YH( included. As an example, let's say in our
  )SM(libfoo)ES( the source subdi)HY(rec)HY(tory)YH( contains a bunch of
  )SM(*-test.cpp)ES( files which are unit tests and should not be listed
  as prereq)HY(ui)HY(sites)YH( of a library. Here is how we can exclude them:)EP(

  ) 3 54 PR(# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx cxx}{** -**-test} $impl_libs $intf_libs)RP(

  )0 P(Let's also assume our )SM(libfoo)ES( contains
  )SM(impl-win32.cpp)ES( and )SM(impl-posix.cpp)ES( which provide
  alter)HY(na)HY(tive)YH( imple)HY(men)HY(ta)HY(tions)YH( of the same func)HY(tion)HY(al)HY(ity)YH( for Windows and POSIX
  and there)HY(fore)YH( should only be included as prereq)HY(ui)HY(sites)YH( on the respec)HY(tive)YH(
  plat)HY(forms)YH(. Here is how we can handle that:)EP(

  ) 6 69 PR(# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx cxx}{** -impl-win32 -impl-posix -**-test}
lib{foo}: cxx{impl-win32}: include = \201$cxx.target.class == 'windows'\202
lib{foo}: cxx{impl-posix}: include = \201$cxx.target.class != 'windows'\202
lib{foo}: $impl_libs $intf_libs)RP(

  )0 P(There are two nuances in the above example worth high)HY(light)HY(ing)YH(. Firstly,
  we have to exclude the files from the wild)HY(card)YH( pattern before we can
  condi)HY(tion)HY(ally)YH( include them. Secondly, we have to always link libraries last.
  In partic)HY(u)HY(lar)YH(, the follow)HY(ing)YH( is a shorter but an incor)HY(rect)YH( version of the
  above:)EP(

  ) 4 69 PR(lib{foo}: {hxx cxx}{** -impl-win32 -impl-posix -**-test} \200
          $impl_libs $intf_libs
lib{foo}: cxx{impl-win32}: include = \201$cxx.target.class == 'windows'\202
lib{foo}: cxx{impl-posix}: include = \201$cxx.target.class != 'windows'\202)RP(

  )BR(
  )0 P(You may also be tempted to use the )SM(if)ES( direc)HY(tive)YH( instead of
  the )SM(include)ES( vari)HY(able)YH( for condi)HY(tional)YH( prereq)HY(ui)HY(sites)YH(. For
  example:)EP(

  ) 4 35 PR(if \201$cxx.target.class == 'windows'\202
  lib{foo}: cxx{impl-win32}
else
  lib{foo}: cxx{impl-posix})RP(

  )0 P(This would also be incor)HY(rect)YH(. For back)HY(ground)YH( and details, see )R23 2 A(How
  do I keep the build graph config)HY(u)HY(ra)HY(tion)YH(-inde)HY(pen)HY(dent)YH(?)EA()EP(
  )BR(

  )0 3 30 H(2.4.9)WB 136 Sn()WB 32 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: build and export options)EH(

  )0 P(The next two blocks are the build and export options, which we will
  discuss together:)EP(

  ) 23 57 PR(# Build options.
#
out_pfx_inc = [dir_path] $out_root/include/
src_pfx_inc = [dir_path] $src_root/include/
out_pfx_src = [dir_path] $out_root/src/
src_pfx_src = [dir_path] $src_root/src/

cxx.poptions =+ "-I$out_pfx_src" "-I$src_pfx_src" \200
                "-I$out_pfx_inc" "-I$src_pfx_inc"

#obja{*}: cxx.poptions += -DFOO_STATIC_BUILD
#objs{*}: cxx.poptions += -DFOO_SHARED_BUILD

# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$out_pfx_inc" "-I$src_pfx_inc"
  cxx.export.libs = $intf_libs
}

#liba{foo}: cxx.export.poptions += -DFOO_STATIC
#libs{foo}: cxx.export.poptions += -DFOO_SHARED)RP(

  )0 P(The build options are in effect when the library itself is being built
  and the exported options are prop)HY(a)HY(gated)YH( to the library consumers \201see )0 2 A(Library
  Expor)HY(ta)HY(tion)YH( and Version)HY(ing)YH()EA( for back)HY(ground)YH( on exported options\202. For now
  we will ignore the commented out lines that add )SM(-DFOO_STATIC*)ES(
  and )SM(-DFOO_SHARED*)ES( macros \235 they are for symbol export)HY(ing)YH(
  and we will discuss this topic sepa)HY(rately)YH(.)EP(

  )0 P(If the library you are pack)HY(ag)HY(ing)YH( only relied on plat)HY(form)YH(-inde)HY(pen)HY(dent)YH(
  APIs, then chances are you won't need to change anything here. On the other
  hand, if it does anything plat)HY(form)YH(-specific, then you will most likely need
  to add some options.)EP(

  )0 P(As discussed in the )0 2 A(Output
  Direc)HY(to)HY(ries)YH( and Scopes)EA( section of the build system intro)HY(duc)HY(tion)YH(, there
  is a number of vari)HY(ables)YH( that are used to specify compi)HY(la)HY(tion)YH( and linking
  options, such as )SM(*.poptions)ES( \201)SM(cxx.poptions)ES( in the
  above example\202, )SM(*.coptions)ES(, etc. The below table shows all of
  them with their rough )SM(make)ES( equiv)HY(a)HY(lents)YH( in the third column:)EP(

  ) 5 46 PR(*.poptions   preprocess        CPPFLAGS
*.coptions   compile           CFLAGS/CXXFLAGS
*.loptions   link              LDFLAGS
*.aoptions   archive           ARFLAGS
*.libs       system libraries  LIBS/LDLIBS)RP(

  )0 P(The recom)HY(mended)YH( approach here is to study the upstream build system and
  copy custom compile/link options to the appro)HY(pri)HY(ate)YH( )SM(build2)ES(
  vari)HY(ables)YH(. Note, however, that doing it thought)HY(lessly)YH(/faith)HY(fully)YH( by copying
  all the options may not always be a good idea. See )R24 2 A(Which
  C/C++ compile/link options are OK to specify in a project's build)HY(file)YH(?)EA(
  for the guide)HY(lines)YH(.)EP(

  )BR(
  )0 P(If you are pack)HY(ag)HY(ing)YH( a library that includes a large number of optional
  features, it may be unclear which of them would make sense to enable by
  default. The noto)HY(ri)HY(ous)YH( example of this situ)HY(a)HY(tion)YH( is )R25 2 A()SM(libsqlite3)ES()EA(
  which provides hundreds of prepro)HY(ces)HY(sor)YH( macros to enable or tune various
  aspects of its func)HY(tion)HY(al)HY(ity)YH(.)EP(

  )0 P(The recom)HY(mended)YH( approach in cases like this is to study the config)HY(u)HY(ra)HY(tion)YH(
  of such a library in distri)HY(bu)HY(tions)YH( like Debian and Fedora and use the same
  defaults. In partic)HY(u)HY(lar)YH(, this will allow us to substi)HY(tute)YH( the
  )SM(build2)ES( package with the system-installed version.)EP(
  )BR(

  )0 P(Often)HY(times)YH(, custom options must only be spec)HY(i)HY(fied)YH( for certain target
  plat)HY(forms)YH( or when using a certain compiler. While )SM(build2)ES(
  provides a large amount of infor)HY(ma)HY(tion)YH( to iden)HY(tify)YH( the build config)HY(u)HY(ra)HY(tion)YH(
  as well as more advanced )SM(build)HY(file)YH()ES( language mech)HY(a)HY(nisms)YH( \201such as
  )0 2 A(Pattern
  Match)HY(ing)YH()EA(\202 to make sense of it, this is a large topic for which we refer
  you to )0 2 A(The
  )SM(build2)ES( Build System)EA( manual. Addi)HY(tion)HY(ally)YH(, )R5 2 A(github.com/build2-pack)HY(ag)HY(ing)YH()EA(
  now contains a large number of pack)HY(ages)YH( that you can study and search for
  exam)HY(ples)YH(.)EP(

  )BR(
  )0 P(While export)HY(ing)YH( prepro)HY(ces)HY(sor)YH( macros to commu)HY(ni)HY(cate)YH( config)HY(u)HY(ra)HY(tion)YH( is a
  fairly common tech)HY(nique)YH(, it has a number of draw)HY(backs)YH( and limi)HY(ta)HY(tions)YH(.
  Specif)HY(i)HY(cally)YH(, a large number of such macros will add a lot of noise to the
  consumer's compi)HY(la)HY(tion)YH( command lines \201espe)HY(cially)YH( if multi)HY(ple)YH( libraries
  indulge in this\202. Plus, the infor)HY(ma)HY(tion)YH( conveyed by such macros is limited
  to simple values and is not easily acces)HY(si)HY(ble)YH( in consumer
  )SM(build)HY(files)YH()ES(.)EP(

  )0 P(To over)HY(come)YH( these draw)HY(backs)YH( and limi)HY(ta)HY(tions)YH(, )SM(build2)ES( provides
  a mech)HY(a)HY(nism)YH( for convey)HY(ing)YH( meta)HY(data)YH( with C/C++ libraries \201and executa)HY(bles)YH(\202.
  See, )R26 2 A(How
  do I convey addi)HY(tional)YH( infor)HY(ma)HY(tion)YH( \201meta)HY(data)YH(\202 with executa)HY(bles)YH( and C/C++
  libraries?)EA( for details.)EP(

  )0 P(Note that outright replac)HY(ing)YH( the prepro)HY(ces)HY(sor)YH( macros with meta)HY(data)YH( can be
  done if this infor)HY(ma)HY(tion)YH( is only used by the library consumers. In other
  words, if the library's public headers rely on the pres)HY(ence)YH( of such macros,
  then we have no choice but to export them, poten)HY(tially)YH( also provid)HY(ing)YH( the
  meta)HY(data)YH( so that this infor)HY(ma)HY(tion)YH( is easily acces)HY(si)HY(ble)YH( from
  )SM(build)HY(files)YH()ES(.)EP(
  )BR(

  )0 P(Let's consider a repre)HY(sen)HY(ta)HY(tive)YH( example based on our )SM(libfoo)ES(
  to get a sense of what this normally looks like as well as to high)HY(light)YH( a
  few nuances. We will assume our )SM(libfoo)ES( requires either the
  )SM(FOO_POSIX)ES( or )SM(FOO_WIN32)ES( macro to be defined during
  the build in order to iden)HY(tify)YH( the target plat)HY(form)YH(. Addi)HY(tion)HY(ally)YH(, extra
  features can be enabled by defin)HY(ing)YH( )SM(FOO_EXTRAS)ES(, which should be
  done both during the build and for consump)HY(tion)YH( \201so this macro must also be
  exported\202. Next, this library requires the )SM(-fno-strict-alias)HY(ing)YH()ES(
  compile option for the GCC-class compil)HY(ers)YH( \201GCC, Clang, etc\202. Finally, we
  need to link )SM(pthread)ES( on POSIX and )SM(ws2_32.lib)ES( on
  Windows. This is how we would work all this into the above frag)HY(ment)YH(:)EP(

  ) 43 70 PR(# Build options.
#
out_pfx_inc = [dir_path] $out_root/include/
src_pfx_inc = [dir_path] $src_root/include/
out_pfx_src = [dir_path] $out_root/src/
src_pfx_src = [dir_path] $src_root/src/

cxx.poptions =+ "-I$out_pfx_src" "-I$src_pfx_src" \200
                "-I$out_pfx_inc" "-I$src_pfx_inc"

cxx.poptions += -DFOO_EXTRAS

if \201$cxx.target.class == 'windows'\202
  cxx.poptions += -DFOO_WIN32
else
  cxx.poptions += -DFOO_POSIX

#obja{*}: cxx.poptions += -DFOO_STATIC_BUILD
#objs{*}: cxx.poptions += -DFOO_SHARED_BUILD

if \201$cxx.class == 'gcc'\202
  cxx.coptions += -fno-strict-aliasing

switch $cxx.target.class, $cxx.target.system
{
  case 'windows', 'mingw32'
    cxx.libs += -lws2_32
  case 'windows'
    cxx.libs += ws2_32.lib
  default
    cxx.libs += -pthread)WR(
}

# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$out_pfx_inc" "-I$src_pfx_inc" -DFOO_EXTRAS
  cxx.export.libs = $intf_libs
}

#liba{foo}: cxx.export.poptions += -DFOO_STATIC
#libs{foo}: cxx.export.poptions += -DFOO_SHARED)RP(

  )0 P(There are a few nuances in the above code worth keeping in mind. Firstly,
  notice that we append \201rather than assign\202 to all the non-export vari)HY(ables)YH(
  \201)SM(*.poptions)ES(, )SM(*.coptions)ES(, )SM(*.libs)ES(\202.
  This is because they may already contain some values spec)HY(i)HY(fied)YH( by the user
  with their )SM(config.*.*)ES( coun)HY(ter)HY(parts)YH(. On the other hand, the
  )SM(*.export.*)ES( vari)HY(ables)YH( are assigned.)EP(

  )0 P(Secondly, the order in which we append to the vari)HY(ables)YH( is impor)HY(tant)YH( for
  the value to accu)HY(mu)HY(late)YH( correctly. You want to first append all the
  scope-level values, then target type/pattern-specific, and finally any
  target-specific; that is, from more general to more specific \201see )0 2 A(Build)HY(file)YH(
  Language)EA( for back)HY(ground)YH(\202. To illus)HY(trate)YH( this point, let's say in our
  )SM(libfoo)ES(, the )SM(FOO_POSIX)ES( or )SM(FOO_WIN32)ES(
  macro are only neces)HY(sary)YH( when compil)HY(ing)YH( )SM(util.cpp)ES(. Below would
  be the correct order of assign)HY(ing)YH( to )SM(cxx.poptions)ES(:)EP(

  ) 12 51 PR(cxx.poptions =+ "-I$out_pfx_src" "-I$src_pfx_src" \200
                "-I$out_pfx_inc" "-I$src_pfx_inc"

cxx.poptions += -DFOO_EXTRAS

#obja{*}: cxx.poptions += -DFOO_STATIC_BUILD
#objs{*}: cxx.poptions += -DFOO_SHARED_BUILD

if \201$cxx.target.class == 'windows'\202
  {obja objs}{util}: cxx.poptions += -DFOO_WIN32
else
  {obja objs}{util}: cxx.poptions += -DFOO_POSIX)RP(

  )BR(
  )0 P(Note that target-specific )SM(*.poptions)ES( and
  )SM(*.coptions)ES( must be spec)HY(i)HY(fied)YH( on the object file targets while
  )SM(*.loptions)ES( and )SM(*.libs)ES( \235 on the library or
  executable targets.)EP(
  )BR(

  )0 3 31 H(2.4.10)WB 137 Sn()WB 33 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: symbol export)HY(ing)YH()EH(

  )0 P(Let's now turn to a special sub-topic of the build and export options
  that relates to the shared library symbol export)HY(ing)YH(. To recap, a shared
  library on Windows must explic)HY(itly)YH( specify the symbols \201func)HY(tions)YH( and global
  data\202 that it wishes to make acces)HY(si)HY(ble)YH( by its consumers \201executa)HY(bles)YH( and
  other shared libraries\202. This can be achieved in three differ)HY(ent)YH( ways: The
  library can explic)HY(itly)YH( mark in its source code the names whose symbols
  should be exported. Alter)HY(na)HY(tively)YH(, the library can provide a
  )SM(.def)ES( file to the linker that lists the symbols to be exported.
  Finally, the library can request the auto)HY(matic)YH( export)HY(ing)YH( of all symbols,
  which is the default seman)HY(tics)YH( on non-Windows plat)HY(forms)YH(. Note that the last
  two approaches only work for export)HY(ing)YH( func)HY(tions)YH(, not data, unless special
  extra steps are taken by the library consumers. Let's discuss each of these
  approaches in the reverse order, that is, start)HY(ing)YH( with the auto)HY(matic)YH( symbol
  export)HY(ing)YH(.)EP(

  )0 P(The auto)HY(matic)YH( symbol export)HY(ing)YH( is imple)HY(mented)YH( in )SM(build2)ES( by
  gener)HY(at)HY(ing)YH( a )SM(.def)ES( file that exports all the rele)HY(vant)YH( symbols.
  It requires a few addi)HY(tional)YH( defi)HY(ni)HY(tions)YH( in our )SM(build)HY(file)YH()ES( as
  described in )0 2 A(Auto)HY(matic)YH(
  DLL Symbol Export)HY(ing)YH()EA(. You can auto)HY(mat)HY(i)HY(cally)YH( gener)HY(ate)YH( the neces)HY(sary)YH( setup
  with the )SM(auto-symex)HY(port)YH()ES( )SM(bdep-new)ES( sub-option.)EP(

  )0 P(Using a custom )SM(.def)ES( file to export symbols is fairly
  straight)HY(for)HY(ward)YH(: simply list it as a prereq)HY(ui)HY(site)YH( of the library and it will
  be auto)HY(mat)HY(i)HY(cally)YH( passed to the linker when neces)HY(sary)YH(. For example:)EP(

  ) 3 54 PR(# Private headers and sources as well as dependencies.
#
lib{foo}: {hxx cxx}{**} $impl_libs $intf_libs def{foo})RP(

  )BR(
  )0 P(Some third-party projects auto)HY(mat)HY(i)HY(cally)YH( gener)HY(ate)YH( their )SM(.def)ES(
  file. In this case you can try to re-create the same gener)HY(a)HY(tion)YH( in the
  )SM(build)HY(file)YH()ES( using an ad hoc recipe \201or the )0 2 A()SM(in)ES()EA(
  or )R27 2 A()SM(auto)HY(conf)YH()ES()EA(
  build system modules\202. If that doesn't look possi)HY(ble)YH( \201for example, if the
  gener)HY(a)HY(tion)YH( logic is complex and is imple)HY(mented)YH( in some)HY(thing)YH( like Perl or
  Python\202, then you can try your luck with auto)HY(matic)YH( symbol export)HY(ing)YH(. Failing
  that, the only remain)HY(ing)YH( option is to use a pre-gener)HY(ated)YH( )SM(.def)ES(
  file in the )SM(build2)ES( build.)EP(
  )BR(

  )0 P(The last approach is to explic)HY(itly)YH( specify in the source code which
  symbols must be exported by marking the corre)HY(spond)HY(ing)YH( decla)HY(ra)HY(tions)YH( with
  )SM(__declspec\201dllex)HY(port)YH(\202)ES( during the library build and
  )SM(__declspec\201dllimport\202)ES( during the library use. This is commonly
  achieved with a macro, custom)HY(ar)HY(ily)YH( called )SM(*_EXPORT)ES( or
  )SM(*_API)ES(, which is defined to one of the above spec)HY(i)HY(fiers)YH( based on
  whether static or shared library is being built or is being consumed, which,
  in turn, is also normally signaled with a few more macros, such as
  )SM(*_BUILD_DLL)ES( and )SM(*_USE_STATIC)ES(.)EP(

  )BR(
  )0 P(Because this approach requires exten)HY(sive)YH( changes to the source code, you
  will normally only use it in your )SM(build2)ES( build if it is already
  used in the upstream build.)EP(
  )BR(

  )0 P(In )SM(build2)ES( you can explic)HY(itly)YH( signal any of the four
  situ)HY(a)HY(tions)YH( \201shared/static, built/consumed\202 by uncom)HY(ment)HY(ing)YH( and adjust)HY(ing)YH( the
  follow)HY(ing)YH( four lines in the build and export options blocks:)EP(

  ) 15 47 PR(# Build options.
#

...

#obja{*}: cxx.poptions += -DFOO_STATIC_BUILD
#objs{*}: cxx.poptions += -DFOO_SHARED_BUILD

# Export options.
#

...

#liba{foo}: cxx.export.poptions += -DFOO_STATIC
#libs{foo}: cxx.export.poptions += -DFOO_SHARED)RP(

  )0 P(As an example, let's assume our )SM(libfoo)ES( defines in one of its
  headers the )SM(FOO_EXPORT)ES( macro based on the
  )SM(FOO_BUILD_DLL)ES( \201shared library is being build\202 and
  )SM(FOO_USE_STATIC)ES( \201static library is being used\202 macros that it
  expects to be appro)HY(pri)HY(ately)YH( defined by the build system. This is how we
  would modify the above frag)HY(ment)YH( to handle this setup:)EP(

  ) 13 50 PR(# Build options.
#

...

objs{*}: cxx.poptions += -DFOO_BUILD_DLL

# Export options.
#

...

liba{foo}: cxx.export.poptions += -DFOO_USE_STATIC)RP(

  )0 3 32 H(2.4.11)WB 138 Sn()WB 34 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: shared library version)EH(

  )0 P(The final few lines in the above )SM(build)HY(file)YH()ES( deal with shared
  library binary \201ABI\202 version)HY(ing)YH(:)EP(

  ) 8 68 PR(# For pre-releases use the complete version to make sure they cannot
# be used in place of another pre-release or the final version. See
# the version module for details on the version.* variable values.
#
if $version.pre_release
  lib{foo}: bin.lib.version = "-$version.project_id"
else
  lib{foo}: bin.lib.version = "-$version.major.$version.minor")RP(

  )0 P(The )SM(bdep-new)ES(-gener)HY(ated)YH( setup arranges for the
  plat)HY(form)YH(-inde)HY(pen)HY(dent)YH( version)HY(ing)YH( where the package's major and minor version
  compo)HY(nents)YH( are embed)HY(ded)YH( into the shared library binary name \201and
  )SM(soname)ES(\202 under the assump)HY(tion)YH( that only patch versions are
  ABI-compat)HY(i)HY(ble)YH(.)EP(

  )0 P(The two situ)HY(a)HY(tions)YH( where you would want to change this are when the above
  assump)HY(tion)YH( does not hold and/or when upstream provides plat)HY(form)YH(-specific
  shared library versions which you would like to re-create in your
  )SM(build2)ES( build. See )0 2 A(Library
  Expor)HY(ta)HY(tion)YH( and Version)HY(ing)YH()EA( for back)HY(ground)YH( and details.)EP(

  )0 3 33 H(2.4.12)WB 139 Sn()WB 35 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: executa)HY(bles)YH()EH(

  )0 P(If instead of a library you are pack)HY(ag)HY(ing)YH( an executable, then, as
  mentioned earlier, it will most likely be a combined layout with a single
  )SM(build)HY(file)YH()ES(. This )SM(build)HY(file)YH()ES( will also be much
  simpler compared to the library's. For example, give the follow)HY(ing)YH(
  )SM(bdep-new)ES( command:)EP(

  ) 4 47 PR($ bdep new --package \200
  --lang c++         \200
  --type exe,no-subdir,prefix=foo,export-stub \200
  foo)RP(

  )0 P(The result)HY(ing)YH( source )SM(build)HY(file)YH()ES( will look like this:)EP(

  ) 9 48 PR(libs =
#import libs += libhello%lib{hello}

exe{foo}: {hxx ixx txx cxx}{**} $libs testscript

out_pfx = [dir_path] $out_root/foo/
src_pfx = [dir_path] $src_root/foo/

cxx.poptions =+ "-I$out_pfx" "-I$src_pfx")RP(

  )0 P(If the executable doesn't have any inline/template/header files, then you
  can remove the )SM(ixx)ES(/)SM(txx)ES(/)SM(hxx)ES( target
  types, respec)HY(tively)YH( \201which would be paral)HY(lel)YH( to the change made in
  )SM(root.build)ES(; see )0 24 1 A(Adjust
  project-wide build system files in )SM(build/)ES()24 0 TN TL()Ec /AF f D(\202. For
  example:)EP(

  ) 1 40 PR(exe{foo}: {hxx cxx}{**} $libs testscript)RP(

  )0 P(If the source code includes its own headers with the )SM("")ES(
  style inclu)HY(sion)YH( \201or doesn't have any headers\202, then we can also get rid of
  )SM(out_pfx)ES( and )SM(src_pfx)ES(. For example:)EP(

  ) 4 48 PR(libs =
#import libs += libhello%lib{hello}

exe{foo}: {hxx ixx txx cxx}{**} $libs testscript)RP(

  )BR(
  )0 P(Unfor)HY(tu)HY(nately)YH(, it's not uncom)HY(mon)YH( for projects that provide both a library
  and an executable, for the executable source code to include public and/or
  private library headers with the rela)HY(tive)YH( )SM("")ES( style inclu)HY(sion)YH(.
  For example:)EP(

  ) 2 44 PR(#include "../../libfoo/include/foo/util.hpp"
#include "../../libfoo/src/impl.hpp")RP(

  )0 P(This approach won't work in )SM(build2)ES( since the two pack)HY(ages)YH(
  may end up in differ)HY(ent)YH( direc)HY(to)HY(ries)YH( or the library could even be installed.
  There are two tech)HY(niques)YH( that can be used to work around this issue \201other
  than patch)HY(ing)YH( the upstream source code\202.)EP(

  )0 P(For public headers we can provide, in the appro)HY(pri)HY(ate)YH( places within the
  executable package, "thunk headers" with the same names as public headers
  that simply include the corre)HY(spond)HY(ing)YH( public header from the library using
  the )SM(<>)ES( style inclu)HY(sion)YH(.)EP(

  )0 P(For private headers we can provide, again in the appro)HY(pri)HY(ate)YH( places
  within the executable package, our own symlinks for a subset of private
  headers. Note that this will only work if the use of private headers within
  the executable does not depend on any symbols that are not exported by the
  library \201failing that, the executable will have to always link to the static
  variant of the library\202.)EP(

  )0 P(For a real example of both of these tech)HY(niques)YH(, see the )R28 2 A()SM(zstd)ES()EA(
  package repos)HY(i)HY(tory)YH(.)EP(
  )BR(

  )0 P(Dealing with depen)HY(den)HY(cies)YH( in executa)HY(bles)YH( is similar to libraries except
  that here we don't have the inter)HY(face)YH(/imple)HY(men)HY(ta)HY(tion)YH( distinc)HY(tion)YH(; see the )0 29 1 A(Adjust source
  )SM(build)HY(file)YH()ES(: depen)HY(den)HY(cies)YH()29 0 TN TL()Ec /AF f D( step. For example:)EP(

  ) 3 48 PR(import libs = libfoo%lib{foo}

exe{foo}: {hxx ixx txx cxx}{**} $libs testscript)RP(

  )0 P(Like)HY(wise)YH(, dealing with build options in executa)HY(bles)YH( is similar to
  libraries except that here we have no export options; see the )0 32 1 A(Adjust source
  )SM(build)HY(file)YH()ES(: build and export options)32 0 TN TL()Ec /AF f D( step.)EP(

  )0 P(If the executable can plau)HY(si)HY(bly)YH( be used in a build, then it's recom)HY(mended)YH(
  to add )SM(build2)ES( meta)HY(data)YH( as describe in )R26 2 A(How
  do I convey addi)HY(tional)YH( infor)HY(ma)HY(tion)YH( \201meta)HY(data)YH(\202 with executa)HY(bles)YH( and C/C++
  libraries?)EA( See also )0 96 1 A(Modi)HY(fy)HY(ing)YH( upstream source code
  with C/C++ prepro)HY(ces)HY(sor)YH()96 0 TN TL()Ec /AF f D( on how to do it without phys)HY(i)HY(cally)YH( modi)HY(fy)HY(ing)YH(
  upstream source code. See the )R28 2 A()SM(zstd)ES()EA(
  package repos)HY(i)HY(tory)YH( for a real example of doing this.)EP(

  )BR(
  )0 P(We will discuss the )SM(testscript)ES( prereq)HY(ui)HY(site)YH( in the )0 41 1 A(Make smoke test: executa)HY(bles)YH()41 0 TN TL()Ec /AF f D( step below.)EP(
  )BR(

  )0 3 34 H(2.4.13)WB 140 Sn()WB 36 Sn( Adjust source
  )SM(build)HY(file)YH()ES(: extra require)HY(ments)YH()EH(

  )0 P(The changes discussed so far should be suffi)HY(cient)YH( to handle a typical
  library or executable that is written in C and/or C++ and is able to handle
  plat)HY(form)YH( differ)HY(ences)YH( with the prepro)HY(ces)HY(sor)YH( and compile/link options.
  However, sooner or later you will run into a more complex library that may
  use addi)HY(tional)YH( languages, require more elab)HY(o)HY(rate)YH( plat)HY(form)YH( detec)HY(tion)YH(, or use
  addi)HY(tional)YH( func)HY(tion)HY(al)HY(ity)YH(, such as support for source code gener)HY(a)HY(tors)YH(. The
  below list provides point)HY(ers)YH( to resources that cover the more commonly
  encoun)HY(tered)YH( addi)HY(tional)YH( require)HY(ments)YH(.)EP(

  )UL(  )-1 LI()0 2 A(The
  )SM(in)ES( build system module)EA(

  )0 P(Use to process )SM(config.h.in)ES( \201or other )SM(.in)ES( files\202
  that don't require Auto)HY(conf)YH(-style plat)HY(form)YH( probing \201)SM(HAVE_*)ES(
  options\202.)EP(

  )-1 LI()R27 2 A(The
  )SM(auto)HY(conf)YH()ES( build system module)EA(

  )0 P(Use to process )SM(config.h.in)ES( \201or their CMake/Meson vari)HY(ants)YH(\202
  that require Auto)HY(conf)YH(-style plat)HY(form)YH( probing \201)SM(HAVE_*)ES( options\202
  or CMake/Meson-specific substi)HY(tu)HY(tion)YH( syntax \201)SM(#cmakede)HY(fine)YH()ES(,
  etc\202.)EP(

  )-1 LI()0 2 A(Objec)HY(tive)YH(-C
  Compi)HY(la)HY(tion)YH()EA( and )0 2 A(Objec)HY(tive)YH(-C++
  Compi)HY(la)HY(tion)YH()EA(

  )0 P(Use to compile Objec)HY(tive)YH(-C \201)SM(.m)ES(\202 or Objec)HY(tive)YH(-C++
  \201)SM(.mm)ES(\202 source files.)EP(

  )-1 LI()0 2 A(Assem)HY(bler)YH(
  with C Prepro)HY(ces)HY(sor)YH( Compi)HY(la)HY(tion)YH()EA(

  )0 P(Use to compile Assem)HY(bler)YH( with C Prepro)HY(ces)HY(sor)YH( \201)SM(.S)ES(\202 source
  files.)EP(

  )-1 LI()0 2 A(Imple)HY(ment)HY(ing)YH(
  Unit Testing)EA(

  )0 P(Use if upstream has tests \201normally unit tests\202 in the source
  subdi)HY(rec)HY(tory)YH(.)EP(

  )-1 LI()0 2 A(Build-Time
  Depen)HY(den)HY(cies)YH( and Linked Config)HY(u)HY(ra)HY(tions)YH()EA(

  )0 P(Use if upstream relies on source code gener)HY(a)HY(tors)YH(, such as )R29 2 A()SM(lex)ES()EA( and )R30 2 A()SM(yacc)ES()EA(.)EP(

  )-1 LI()R31 2 A(The )SM(build2)ES(
  HOWTO)EA(

  )0 P(See the )SM(build2)ES( HOWTO article collec)HY(tion)YH( for more unusual
  require)HY(ments)YH(.)EP(
  )LU(

  )0 3 35 H(2.4.14)WB 141 Sn()WB 37 Sn( Test library build)EH(

  )0 P(At this point our library should be ready to build, at least in theory.
  While we cannot build and test the entire package before adjust)HY(ing)YH( the
  gener)HY(ated)YH( )SM(tests/)ES( subpro)HY(ject)YH( \201the subject of the next step\202, we
  can try to build just the library and, if it has any unit tests in the
  source subdi)HY(rec)HY(tory)YH(, even run some tests.)EP(

  )BR(
  )0 P(If the library is header only, there won't be anything to build unless
  there are unit tests. Still, you may want to continue with this exer)HY(cise)YH( to
  detect any syntac)HY(tic)YH( mistakes in the )SM(build)HY(files)YH()ES(, etc.)EP(
  )BR(

  )0 P(To build only a specific subdi)HY(rec)HY(tory)YH( of our package, we use the build
  system directly \201contin)HY(u)HY(ing)YH( with our )SM(libfoo)ES( example\202:)EP(

  ) 2 53 PR($ cd libfoo/src/ # Change to the source subdirectory.
$ b update)RP(

  )0 P(If there are any issues, try to fix them and then build again. Once the
  library builds and if it has unit tests, you can try to run them:)EP(

  ) 1 8 PR($ b test)RP(

  )0 P(It also makes sense to test the instal)HY(la)HY(tion)YH( and see if anything is off
  \201such as private headers being installed\202:)EP(

  ) 2 44 PR($ rm -rf /tmp/install
$ b install config.install.root=/tmp/install)RP(

  )0 P(Once the library builds, it makes sense to commit our changes for easier
  roll)HY(backs)YH(:)EP(

  ) 4 55 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Adjust source subdirectory buildfiles")RP(

  )0 2 36 H(2.5)WB 142 Sn()WB 38 Sn( Make smoke test)EH(

  )0 P(With the library build sorted, we need tests to make sure the result is
  actu)HY(ally)YH( func)HY(tional)YH(. As )0 19 1 A(discussed earlier)19 0 TN TL()Ec /AF f D(, it is
  recom)HY(mended)YH( to start with a simple "smoke test", make sure that works, and
  then replace it with upstream tests. However, if upstream tests look simple
  enough, you can skip the smoke test. For example, if upstream has all its
  tests in a single source file and the way it is built doesn't look too
  compli)HY(cated)YH(, then you can just use that source file in place of the smoke
  test.)EP(

  )BR(
  )0 P(If upstream has no tests, then the smoke test will have to stay. A
  library can only be published if it has at least one test.)EP(

  )0 P(It is also recom)HY(mended)YH( to have the smoke test if upstream tests are in a
  sepa)HY(rate)YH( package. See )R12 2 A(How
  do I handle tests that have extra depen)HY(den)HY(cies)YH(?)EA( for back)HY(ground)YH( and
  details.)EP(
  )BR(

  )BR(
  )0 P(If instead of a library you are pack)HY(ag)HY(ing)YH( an executable, you can skip
  directly to )0 41 1 A(Make smoke test:
  executa)HY(bles)YH()41 0 TN TL()Ec /AF f D(.)EP(
  )BR(

  )0 P(To recap, the )SM(bdep-new)ES(-gener)HY(ated)YH( )SM(tests/)ES(
  subdi)HY(rec)HY(tory)YH( looks like this \201contin)HY(u)HY(ing)YH( with our )SM(libfoo)ES(
  example\202:)EP(

  ) 10 29 PR(libfoo/
|-- ...
\267-- tests/
    |-- build/
    |\302\240\302\240 |-- bootstrap.build
    |\302\240\302\240 \267-- root.build
    |-- basics/
    |\302\240\302\240 |-- driver.cpp
    |\302\240\302\240 \267-- buildfile
    \267-- buildfile)RP(

  )0 P(The )SM(tests/)ES( subdi)HY(rec)HY(tory)YH( is a build system subpro)HY(ject)YH(,
  meaning that it can be built inde)HY(pen)HY(dently)YH(, for example, to test the
  installed version of the library \201see )0 2 A(Testing)EA(
  for back)HY(ground)YH(\202. In partic)HY(u)HY(lar)YH(, this means it has the )SM(build/)ES(
  subdi)HY(rec)HY(tory)YH( with project-wide build system files, the same as the library.
  The )SM(basics/)ES( subdi)HY(rec)HY(tory)YH( contains the gener)HY(ated)YH( test, which is
  what we will be turning into a smoke test. The subpro)HY(ject)YH( root
  )SM(build)HY(file)YH()ES( rarely needs chang)HY(ing)YH(.)EP(

  )0 3 37 H(2.5.1)WB 143 Sn()WB 39 Sn( Adjust project-wide build system
  files in )SM(tests/build/)ES()EH(

  )0 P(Review and adjust the gener)HY(ated)YH( )SM(boot)HY(strap)YH(.build)ES( and
  )SM(root.build)ES( \201there will be no )SM(export.build)ES(\202 similar
  to the )0 24 1 A(Adjust project-wide build system
  files in )SM(build/)ES()24 0 TN TL()Ec /AF f D( step.)EP(

  )0 P(Here the only change you would normally make is in
  )SM(root.build)ES( and which is to drop the assign)HY(ment)YH( of exten)HY(sions)YH(
  for target types that are not used in tests.)EP(

  )0 3 38 H(2.5.2)WB 144 Sn()WB 40 Sn( Convert gener)HY(ated)YH( test to library
  smoke test)EH(

  )0 P(The )SM(basics/)ES( subdi)HY(rec)HY(tory)YH( contains the
  )SM(driver.cpp)ES( source file that imple)HY(ments)YH( the test and
  )SM(build)HY(file)YH()ES( that builds it. You can rename both the test
  subdi)HY(rec)HY(tory)YH( \201)SM(basics/)ES(\202 and the source file
  )SM(driver.cpp)ES(, for example, if you are going with the upstream
  tests directly. You can also add more tests by simply copying
  )SM(basics/)ES(.)EP(

  )0 P(The purpose of a smoke test is to make sure the library's public headers
  can be included \201includ)HY(ing)YH( in the installed case, no pun intended\202, it can
  be linked, and its basic func)HY(tion)HY(al)HY(ity)YH( works.)EP(

  )0 P(To achieve this, we modify )SM(driver.cpp)ES( to include the
  library's main headers and call a few func)HY(tions)YH(. For example, if the library
  has the initial)HY(ize)YH(/deini)HY(tial)HY(ize)YH( type of func)HY(tions)YH(, those are good candi)HY(dates)YH(
  to call. If the library is not header-only, make sure that the smoke test
  calls at least one non-inline/template func)HY(tion)YH( to test symbol
  export)HY(ing)YH(.)EP(

  )BR(
  )0 P(Make sure that your test includes the library's public headers the same
  way as would be done by the library consumers.)EP(
  )BR(

  )0 P(Contin)HY(u)HY(ing)YH( with our )SM(libfoo)ES( example, this is what its smoke
  test might look like:)EP(

  ) 12 46 PR(#include <foo/core.hpp>
#include <foo/util.hpp>

#undef NDEBUG
#include <cassert>

int main \201\202
{
  foo::context* c \201foo::init \2010 /* flags */\202\202;
  assert \201c != nullptr\202;
  foo::deinit \201c\202;
})RP(

  )BR(
  )0 P(The C/C++ )SM(assert\201\202)ES( macro is often adequate for simple tests
  and does not require extra depen)HY(den)HY(cies)YH(. But see )R32 2 A(How
  do I correctly use C/C++ assert\201\202 in tests?)EA()EP(
  )BR(

  )0 P(The test )SM(build)HY(file)YH()ES( is pretty simple:)EP(

  ) 3 55 PR(import libs = libfoo%lib{foo}

exe{driver}: {hxx ixx txx cxx}{**} $libs testscript{**})RP(

  )0 P(If you have adjusted the library target name \201)SM(lib{foo})ES(\202 in
  the source subdi)HY(rec)HY(tory)YH( )SM(build)HY(file)YH()ES(, then you will need to make
  the corre)HY(spond)HY(ing)YH( change in the )SM(import)ES( direc)HY(tive)YH( here. You may
  also want to tidy it up by remov)HY(ing)YH( unused prereq)HY(ui)HY(site)YH( types. For
  example:)EP(

  ) 3 32 PR(import libs = libfoo%lib{foo}

exe{driver}: {hxx cxx}{**} $libs)RP(

  )0 3 39 H(2.5.3)WB 145 Sn()WB 41 Sn( Make smoke test: executa)HY(bles)YH()EH(

  )0 P(If instead of a library we are pack)HY(ag)HY(ing)YH( an executable, then instead of
  the )SM(tests/)ES( subpro)HY(ject)YH( we get the )SM(testscript)ES( file
  in the source subdi)HY(rec)HY(tory)YH( \201see )0 35 1 A(Adjust source
  )SM(build)HY(file)YH()ES(: executa)HY(bles)YH()35 0 TN TL()Ec /AF f D( for a refresher\202. This file can be
  used to write one or more tests that exer)HY(cise)YH( our executable \201see )0 2 A(Testing)EA(
  for back)HY(ground)YH(\202.)EP(

  )0 P(How exactly to test any given executable depends on its func)HY(tion)HY(al)HY(ity)YH(.
  For instance, for a compres)HY(sion)YH( utility we could write a roundtrip test that
  first compresses some input, then decom)HY(presses)YH( it, and finally compares the
  result to the orig)HY(i)HY(nal)YH(. For example \201taken from the )R28 2 A()SM(zstd)ES()EA(
  package repos)HY(i)HY(tory)YH(\202:)EP(

  ) 3 53 PR(: roundtrip
:
echo 'test content' | $* -zc | $* -dc >'test content')RP(

  )0 P(On the other hand, for an executable that is a source code gener)HY(a)HY(tor)YH(,
  proper testing would involve a sepa)HY(rate)YH( tests package that has a build-time
  depen)HY(dency)YH( on the executable and that exer)HY(cises)YH( the gener)HY(ated)YH( code \201see )R12 2 A(How
  do I handle tests that have extra depen)HY(den)HY(cies)YH(?)EA( for back)HY(ground)YH( and
  details\202. See the )R33 2 A()SM(thrift)ES()EA(
  package repos)HY(i)HY(tory)YH( for an example of this setup.)EP(

  )0 P(If the executable provides a way to query its version, one test that you
  should always be able to write, and which can serve as a last resort smoke
  test, is the version check. For example:)EP(

  ) 5 58 PR(: version
:
$* --version >>~"/EOO/"
/.*$\201version.major\202\200.$\201version.minor\202\200.$\201version.patch\202.*/
EOO)RP(

  )0 P(See also )R34 2 A(How
  do I sani)HY(tize)YH( the execu)HY(tion)YH( of my tests?)EA()EP(

  )0 3 40 H(2.5.4)WB 146 Sn()WB 42 Sn( Test locally)EH(

  )0 P(With the smoke test ready, we can finally do some end-to-end testing of
  our library build. We will start with doing some local testing to catch
  basic mistakes and then do the full CI to detect any
  plat)HY(form)YH(/compiler-specific issues.)EP(

  )0 P(First let's run the test in the default build config)HY(u)HY(ra)HY(tion)YH( by invok)HY(ing)YH(
  the build system directly \201see )0 2 A(Getting Started Guide)EA( for
  back)HY(ground)YH( on default config)HY(u)HY(ra)HY(tions)YH(\202:)EP(

  ) 2 53 PR($ cd libfoo/tests/ # Change to the tests/ subproject.
$ b test)RP(

  )0 P(If there are any issues \201compile/link errors, test fail)HY(ures)YH(\202, try to
  address them and re-run the test.)EP(

  )0 P(Once the library builds in the default config)HY(u)HY(ra)HY(tion)YH( and the result
  passes the tests, you can do the same for all the build config)HY(u)HY(ra)HY(tions)YH(, in
  case you have )0 20 1 A(initial)HY(ized)YH()20 0 TN TL()Ec /AF f D( your library in
  several:)EP(

  ) 1 14 PR($ bdep test -a)RP(

  )0 3 41 H(2.5.5)WB 147 Sn()WB 43 Sn( Test locally:
  instal)HY(la)HY(tion)YH()EH(

  )0 P(Once the devel)HY(op)HY(ment)YH( build works, let's also test the installed version
  of the library. In partic)HY(u)HY(lar)YH(, this makes sure that the public headers are
  installed in a way that is compat)HY(i)HY(ble)YH( with how they are included by our test
  \201and would be included by the library consumers\202. To test this we first
  install the library into a tempo)HY(rary)YH( direc)HY(tory)YH(:)EP(

  ) 3 44 PR($ cd libfoo/ # Change to the package root.
$ rm -rf /tmp/install
$ b install config.install.root=/tmp/install)RP(

  )0 P(Next we build just the )SM(tests/)ES( subpro)HY(ject)YH( out of source and
  arrang)HY(ing)YH( for it to find the installed library \201see )0 2 A(Output
  Direc)HY(to)HY(ries)YH( and Scopes)EA( for back)HY(ground)YH( on the out of source build
  syntax\202:)EP(

  ) 4 42 PR($ cd libfoo/ # Change to the package root.
$ b test: tests/@/tmp/libfoo-tests-out/ \200
  config.cc.loptions=-L/tmp/install/lib \200
  config.bin.rpath=/tmp/install/lib)RP(

  )BR(
  )0 P(The equiv)HY(a)HY(lent)YH( MSVC command line would be:)EP(

  ) 5 48 PR(> b install config.install.root=c:\200tmp\200install

> set "PATH=c:\200tmp\200install\200bin;%PATH%"
> b test: tests\200@c:\200tmp\200libfoo-tests-out\200^
  config.cc.loptions=/LIBPATH:c:\200tmp\200install\200lib)RP(
  )BR(

  )0 P(It is a good idea to look over the installed files manu)HY(ally)YH( and make sure
  there is nothing unex)HY(pected)YH(, for example, missing or extra)HY(ne)HY(ous)YH( files.)EP(

  )0 P(Once done testing the installed case, let's clean things up:)EP(

  ) 1 42 PR($ rm -r /tmp/install /tmp/libfoo-tests-out)RP(

  )0 3 42 H(2.5.6)WB 148 Sn()WB 44 Sn( Test locally: distri)HY(bu)HY(tion)YH()EH(

  )0 P(Another special case worth testing is the prepa)HY(ra)HY(tion)YH( of the source
  distri)HY(bu)HY(tion)YH( \201see )0 2 A(Distribut)HY(ing)YH()EA(
  for back)HY(ground)YH(\202. This, in partic)HY(u)HY(lar)YH(, is how your package will be turned
  into the source archive for publish)HY(ing)YH( to )R1 2 A(cppget.org)EA(. Here we are primar)HY(ily)YH( looking for
  missing files. As a bonus, this will also allow us to test the in source
  build. First we distribute our package to a tempo)HY(rary)YH( direc)HY(tory)YH( \201again using
  the default config)HY(u)HY(ra)HY(tion)YH( and the build system directly\202:)EP(

  ) 2 64 PR($ cd libfoo/ # Change to the package root.
$ b dist config.dist.root=/tmp/dist config.dist.uncommitted=true)RP(

  )0 P(The result will be in the )SM(/tmp/dist/libfoo-<version>/)ES(
  direc)HY(tory)YH( which should resem)HY(ble)YH( our )SM(libfoo/)ES( package but without
  files like )SM(.gitig)HY(nore)YH()ES(. Next we build and test the distri)HY(bu)HY(tion)YH(
  in source:)EP(

  ) 4 32 PR($ cd /tmp/dist/libfoo-<version>/
$ b configure config.cxx=g++
$ b update
$ b test)RP(

  )BR(
  )0 P(If your package has depen)HY(den)HY(cies)YH( that you import in your
  )SM(build)HY(file)YH()ES(, then the above )SM(config)HY(ure)YH()ES( oper)HY(a)HY(tion)YH( will
  most likely fail because such depen)HY(den)HY(cies)YH( cannot be found \201it may succeed
  if they are avail)HY(able)YH( as system-installed\202. The error message will suggest
  spec)HY(i)HY(fy)HY(ing)YH( the loca)HY(tion)YH( of each depen)HY(dency)YH( with the
  )SM(config.import.*)ES( vari)HY(able)YH(. You can fix this by setting each such
  )SM(config.import.*)ES( to the loca)HY(tion)YH( of the default build
  config)HY(u)HY(ra)HY(tion)YH( \201created in the )0 20 1 A(Initial)HY(ize)YH( package
  in build config)HY(u)HY(ra)HY(tions)YH()20 0 TN TL()Ec /AF f D( step\202 which should contain all the neces)HY(sary)YH(
  depen)HY(den)HY(cies)YH(. Simply re-run the )SM(config)HY(ure)YH()ES( oper)HY(a)HY(tion)YH( until you
  have discov)HY(ered)YH( and spec)HY(i)HY(fied)YH( all the neces)HY(sary)YH( )SM(config.import.*)ES(
  vari)HY(ables)YH(, for example:)EP(

  ) 4 38 PR($ b configure config.cxx=g++ \200
  config.import.libz=.../foo-gcc \200
  config.import.libasio=.../foo-gcc \200
  config.import.libsqlite3=.../foo-gcc)RP(
  )BR(

  )0 P(It is a good idea to look over the distributed files manu)HY(ally)YH( and make
  sure there is nothing missing or extra)HY(ne)HY(ous)YH(.)EP(

  )0 P(Once done testing the distri)HY(bu)HY(tion)YH(, let's clean things up:)EP(

  ) 1 17 PR($ rm -r /tmp/dist)RP(

  )0 3 43 H(2.5.7)WB 149 Sn()WB 45 Sn( Commit and test with CI)EH(

  )0 P(With local testing complete, let's commit our changes and submit a remote
  CI job to test our library on all the major plat)HY(forms)YH( and with all the major
  compil)HY(ers)YH(:)EP(

  ) 7 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Add smoke test"
$ git push -u

$ bdep ci)RP(

  )0 P(The result of the )0 2 A()SM()BD(bdep-ci\2011\202)ES()ES()EA(
  command is a link where you can see the status of the builds.)EP(

  )BR(
  )0 P(Make sure to wait until there are no more unbuilt config)HY(u)HY(ra)HY(tions)YH( \201that
  is, the number of entries with the )SM(<unbuilt>)ES( or
  )SM(build)HY(ing)YH()ES( result is )SM(0)ES(\202.)EP(
  )BR(

  )0 P(If any builds fail, view the logs to deter)HY(mine)YH( the cause, try to fix it,
  commit your fix, and CI again.)EP(

  )BR(
  )0 P(It is possi)HY(ble)YH( that upstream does not support some plat)HY(forms)YH( or
  compil)HY(ers)YH(. For example, it's common for smaller projects not to bother with
  support)HY(ing)YH( "secondary" compil)HY(ers)YH(, such as MinGW GCC on Windows or Home)HY(brew)YH(
  GCC on Mac OS.)EP(

  )0 P(If upstream expressly does not support some plat)HY(form)YH( or compiler, it's
  prob)HY(a)HY(bly)YH( not worth spend)HY(ing)YH( time and energy trying to support it in the
  package. Most likely it will require changes to upstream source code and
  that is best done upstream rather than in the package \201see )0 86 1 A(Don't try to fix upstream issues in the
  package)86 0 TN TL()Ec /AF f D( for back)HY(ground)YH(\202. In this case you would want to exclude these
  plat)HY(forms)YH(/compil)HY(ers)YH( from the CI builds using the )0 2 A()SM(builds)ES(
  package )SM(mani)HY(fest)YH()ES( value)EA(.)EP(

  )0 P(The other common cause of a failed build is a newer version of a compiler
  or plat)HY(form)YH( that breaks upstream. In this case there are three options:
  Ideally you would want to fix this in upstream and have a new version
  released. Failing that, you may want to patch the upstream code to fix the
  issues, espe)HY(cially)YH( if this is one of the major plat)HY(forms)YH( and/or primary
  compil)HY(ers)YH( \201see )0 93 1 A(How do I patch
  upstream source code?)93 0 TN TL()Ec /AF f D( for details\202. Finally, you can just leave the
  build failing with the expec)HY(ta)HY(tion)YH( that it will be fixed in the next
  upstream version. Note that in this case you should not exclude the failing
  build from CI.)EP(
  )BR(

  )0 2 44 H(2.6)WB 150 Sn()WB 46 Sn( Replace smoke test with upstream tests)EH(

  )0 P(With the smoke test working we can now proceed with replac)HY(ing)YH( it with the
  upstream tests.)EP(

  )0 3 45 H(2.6.1)WB 151 Sn()WB 47 Sn( Under)HY(stand)YH( how upstream tests
  work)EH(

  )0 P(While there are some common)HY(al)HY(i)HY(ties)YH( in how C/C++ libraries are typi)HY(cally)YH(
  built, when it comes to tests there is unfor)HY(tu)HY(nately)YH( little common ground in
  how they are arranged, built, and executed. As a result, the first step in
  dealing with upstream tests is to study the exist)HY(ing)YH( build system and try to
  under)HY(stand)YH( how they work.)EP(

  )BR(
  )0 P(If upstream tests prove incom)HY(pre)HY(hen)HY(si)HY(ble)YH( \201which is unfor)HY(tu)HY(nately)YH( not
  uncom)HY(mon)YH(\202 and the only options you see are to go with just the smoke test or
  to give up, then go with just the smoke test. In this case it's a good idea
  to create an issue in the package repos)HY(i)HY(tory)YH( mention)HY(ing)YH( that upstream tests
  are still a TODO.)EP(
  )BR(

  )BR(
  )0 P(If instead of a library you are pack)HY(ag)HY(ing)YH( an executable, then whether the
  below steps will apply depends on the func)HY(tion)HY(al)HY(ity)YH( of the executable.)EP(

  )0 P(In partic)HY(u)HY(lar)YH(, testing source code gener)HY(a)HY(tors)YH( would normally involve
  exer)HY(cis)HY(ing)YH( the gener)HY(ated)YH( code, in which case the follow)HY(ing)YH( will largely
  apply, though in this case the tests would need to be placed into a sepa)HY(rate)YH(
  tests package that has a build-time depen)HY(dency)YH( on the executable \201see )R12 2 A(How
  do I handle tests that have extra depen)HY(den)HY(cies)YH(?)EA( for back)HY(ground)YH( and
  details\202. In fact, if a source code gener)HY(a)HY(tor)YH( is accom)HY(pa)HY(nied)YH( by a runtime
  library, then the tests will normally exer)HY(cise)YH( them together \201though a
  runtime library might also have its own tests\202. See the )R33 2 A()SM(thrift)ES()EA(
  package repos)HY(i)HY(tory)YH( for an example of this setup.)EP(
  )BR(

  )0 P(To get you started with analyz)HY(ing)YH( the upstream tests, below are some of
  the ques)HY(tions)YH( you would likely need answered before you can proceed with the
  conver)HY(sion)YH(:)EP(

  )UL(  )-1 LI()BD(Are upstream tests unit tests or inte)HY(gra)HY(tion)YH( tests?)ES(

  )0 P(While the distinc)HY(tion)YH( is often fuzzy, for our purposes the key
  differ)HY(en)HY(tia)HY(tor)YH( between unit and inte)HY(gra)HY(tion)YH( tests is which API they use:
  inte)HY(gra)HY(tion)YH( tests only use the library's public API while unit tests need
  access to the imple)HY(men)HY(ta)HY(tion)YH( details.)EP(

  )0 P(Normally \201but not always\202, unit tests will reside next to the library
  source code since they need access to more than just the public headers and
  the library binary \201private headers, indi)HY(vid)HY(ual)YH( object files, utility
  libraries, etc\202. While inte)HY(gra)HY(tion)YH( tests are normally \201but again not always\202
  placed into a sepa)HY(rate)YH( subdi)HY(rec)HY(tory)YH(, usually called )SM(tests)ES( or
  )SM(test)ES(.)EP(

  )0 P(If the library has unit tests, then refer to )0 2 A(Imple)HY(ment)HY(ing)YH(
  Unit Testing)EA( for back)HY(ground)YH( on how to handle them in
  )SM(build2)ES(.)EP(

  )0 P(If the library has inte)HY(gra)HY(tion)YH( tests, then use them to replace \201or
  comple)HY(ment)YH(\202 the smoke test.)EP(

  )0 P(If the library has unit tests but no inte)HY(gra)HY(tion)YH( tests, then it is
  recom)HY(mended)YH( to keep the smoke test since that's the only way the library
  will be tested via its public API.)EP(

  )-1 LI()BD(Do upstream tests use an exter)HY(nal)YH( testing frame)HY(work)YH(?)ES(

  )0 P(Often)HY(times)YH( a C++ library will use an exter)HY(nal)YH( testing frame)HY(work)YH( to
  imple)HY(ment)YH( tests. Popular choices include )R20 2 A()SM(catch2)ES()EA(, )R35 2 A()SM(gtest)ES()EA(, )R36 2 A()SM(doctest)ES()EA(, and )R37 2 A()SM(libboost-test)ES()EA(.)EP(

  )0 P(If a library uses such an exter)HY(nal)YH( testing frame)HY(work)YH(, then it is
  recom)HY(mended)YH( to factor tests into a sepa)HY(rate)YH( package in order to avoid making
  the library package depend on the testing frame)HY(work)YH( \201which is only required
  during testing\202. See )R12 2 A(How
  do I handle tests that have extra depen)HY(den)HY(cies)YH(?)EA( for details.)EP(

  )BR(
  )0 P(Some)HY(times)YH( you will find that upstream bundles the source code of the
  testing frame)HY(work)YH( with their tests. This is espe)HY(cially)YH( common with
  )SM(catch2)ES(. If that's the case, it is strongly recom)HY(mended)YH( that you
  "unbun)HY(dle)YH(" it by making it a proper exter)HY(nal)YH( depen)HY(dency)YH(. See )0 89 1 A(Don't bundle depen)HY(den)HY(cies)YH()89 0 TN TL()Ec /AF f D( for back)HY(ground)YH(.)EP(
  )BR(

  )-1 LI()BD(Are upstream tests in a single or multi)HY(ple)YH( executa)HY(bles)YH(?)ES(

  )0 P(It's not unusual for libraries to have a single test executable that runs
  all the test cases. This is espe)HY(cially)YH( common if a C++ testing frame)HY(work)YH( is
  used. In this case it is natural to replace the contents of the smoke test
  with the upstream source code, poten)HY(tially)YH( renam)HY(ing)YH( the test subdi)HY(rec)HY(tory)YH(
  \201)SM(basics/)ES(\202 to better match upstream naming.)EP(

  )0 P(If upstream has multi)HY(ple)YH( test executa)HY(bles)YH(, then they could all be in a
  single test subdi)HY(rec)HY(tory)YH( \201poten)HY(tially)YH( reusing some common bits\202 or spread
  over multi)HY(ple)YH( subdi)HY(rec)HY(to)HY(ries)YH(. In both cases it's a good idea to follow the
  upstream struc)HY(ture)YH( unless you have good reasons to deviate. In the former
  case \201all executa)HY(bles)YH( in the same subdi)HY(rec)HY(tory)YH(\202, you can re-purpose the
  smoke test subdi)HY(rec)HY(tory)YH(. In the latter case \201each executable in a sepa)HY(rate)YH(
  subdi)HY(rec)HY(tory)YH(\202 you can make copies of the smoke test subdi)HY(rec)HY(tory)YH(.)EP(

  )-1 LI()BD(Do upstream tests use an inter)HY(nal)YH( utility library?)ES(

  )0 P(If there are multi)HY(ple)YH( test executa)HY(bles)YH( and they need to share some common
  func)HY(tion)HY(al)HY(ity)YH(, then it's not unusual for upstream to place such
  func)HY(tion)HY(al)HY(ity)YH( into a static library and then link it to each test
  executable. In )SM(build2)ES( such an inter)HY(nal)YH( library is best
  repre)HY(sented)YH( with a utility library \201see )0 2 A(Imple)HY(ment)HY(ing)YH(
  Unit Testing)EA( for details\202. See the follow)HY(ing)YH( section for an
  example.)EP(

  )-1 LI()BD(Are upstream tests well behaved?)ES(

  )0 P(Unfor)HY(tu)HY(nately)YH(, it's not uncom)HY(mon)YH( for upstream tests not to behave well,
  such as to write diag)HY(nos)HY(tics)YH( to )SM(stdout)ES( instead of
  )SM(stderr)ES(, create tempo)HY(rary)YH( files without clean)HY(ing)YH( them up, or
  assume pres)HY(ence)YH( of input files in the current working direc)HY(tory)YH(. For details
  on how to deal with such situ)HY(a)HY(tions)YH( see )R34 2 A(How
  do I sani)HY(tize)YH( the execu)HY(tion)YH( of my tests?)EA()EP(
  )LU(

  )0 3 46 H(2.6.2)WB 152 Sn()WB 48 Sn( Convert smoke test to upstream
  tests)EH(

  )0 P(Once you have a good grasp of how upstream tests work, convert or replace
  the smoke test with the upstream tests. If upstream has multi)HY(ple)YH( test
  executa)HY(bles)YH(, you may want to deal with one test at a time, making sure that
  it passes before moving to the next one.)EP(

  )0 P(It's normally a good idea to use the smoke test )SM(build)HY(file)YH()ES( as
  a start)HY(ing)YH( point for upstream tests. To recap, the smoke test
  )SM(build)HY(file)YH()ES( for our )SM(libfoo)ES( example ended up looking
  like this:)EP(

  ) 3 32 PR(import libs = libfoo%lib{foo}

exe{driver}: {hxx cxx}{**} $libs)RP(

  )0 P(At a minimum you will most likely need to change the name of the
  executable to match upstream. If you need to build multi)HY(ple)YH( executa)HY(bles)YH( in
  the same direc)HY(tory)YH(, then it's prob)HY(a)HY(bly)YH( best to get rid of the name pattern
  for the source files and specify the prereq)HY(ui)HY(site)YH( names explic)HY(itly)YH(, for
  example:)EP(

  ) 4 32 PR(import libs = libfoo%lib{foo}

./: exe{test1}: cxx{test1} $libs
./: exe{test2}: cxx{test2} $libs)RP(

  )0 P(If you have a large number of such test executa)HY(bles)YH(, then a )0 2 A()SM(for)ES(-loop)EA(
  might be a more scal)HY(able)YH( option:)EP(

  ) 4 34 PR(import libs = libfoo%lib{foo}

for src: cxx{test*}
  ./: exe{$name\201$src\202}: $src $libs)RP(

  )0 P(If the upstream tests have some common func)HY(tion)HY(al)HY(ity)YH( that is used by all
  the test executa)HY(bles)YH(, then it is best placed into a utility library. For
  example:)EP(

  ) 6 40 PR(import libs = libfoo%lib{foo}

./: exe{test1}: cxx{test1} libue{common}
./: exe{test2}: cxx{test2} libue{common}

libue{common}: {hxx cxx}{common} $libs)RP(

  )0 3 47 H(2.6.3)WB 153 Sn()WB 49 Sn( Test locally)EH(

  )0 P(With the upstream tests ready, we re-do the same end-to-end testing as we
  did with the smoke test:)EP(

  )0 P()0 42 1 A(Test
  locally)42 0 TN TL()Ec /AF f D(
  )BR(  )0 43 1 A(Test locally: instal)HY(la)HY(tion)YH()43 0 TN TL()Ec /AF f D(
  )BR(  )0 44 1 A(Test locally: distri)HY(bu)HY(tion)YH()44 0 TN TL()Ec /AF f D()EP(

  )0 3 48 H(2.6.4)WB 154 Sn()WB 50 Sn( Commit and test with CI)EH(

  )0 P(With local testing complete, we commit our changes and submit a remote CI
  job. This step is similar to what )0 45 1 A(we did for
  the smoke test)45 0 TN TL()Ec /AF f D( but this time we are using the upstream tests:)EP(

  ) 7 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Add upstream tests"
$ git push

$ bdep ci)RP(

  )0 2 49 H(2.7)WB 155 Sn()WB 51 Sn( Add upstream exam)HY(ples)YH(, bench)HY(marks)YH(, if
  any)EH(

  )0 P(If the upstream project provides exam)HY(ples)YH( and/or bench)HY(marks)YH( and you wish
  to add them to the )SM(build2)ES( build \201which is not strictly
  neces)HY(sary)YH( for the )SM(build2)ES( package to be usable\202, then now is a
  good time to do that.)EP(

  )0 P(As was mentioned in )0 16 1 A(Review and test
  auto-gener)HY(ated)YH( )SM(build)HY(file)YH()ES( templates)16 0 TN TL()Ec /AF f D(, the recom)HY(mended)YH(
  approach is to copy the )SM(tests/)ES( subpro)HY(ject)YH( \201poten)HY(tially)YH( from the
  commit history before the smoke test was replaced with the upstream tests\202
  and use that as a start)HY(ing)YH( point for exam)HY(ples)YH( and/or bench)HY(marks)YH(. Do not
  forget to add the corre)HY(spond)HY(ing)YH( entry in the root
  )SM(build)HY(file)YH()ES(.)EP(

  )0 P(Once that is done, follow the same steps as in )0 46 1 A(Replace smoke test with upstream tests)46 0 TN TL()Ec /AF f D( to add
  upstream exam)HY(ples)YH(/bench)HY(marks)YH( and test the result.)EP(

  )0 2 50 H(2.8)WB 156 Sn()WB 52 Sn( Adjust root files \201)SM(build)HY(file)YH()ES(,
  )SM(mani)HY(fest)YH()ES(, etc\202)EH(

  )0 P(The last few files that we need to review and poten)HY(tially)YH( adjust are the
  root )SM(build)HY(file)YH()ES(, package )SM(mani)HY(fest)YH()ES(, and
  )SM(PACKAGE-README.md)ES(.)EP(

  )0 3 51 H(2.8.1)WB 157 Sn()WB 53 Sn( Adjust root )SM(build)HY(file)YH()ES()EH(

  )0 P(The main func)HY(tion)YH( of the root )SM(build)HY(file)YH()ES( is to pull in all
  the subdi)HY(rec)HY(to)HY(ries)YH( that need build)HY(ing)YH( plus list targets that are usually
  found in the root direc)HY(tory)YH( of a project, typi)HY(cally)YH( )SM(README.md)ES(,
  )SM(LICENSE)ES(, etc. This is what the gener)HY(ated)YH( root
  )SM(build)HY(file)YH()ES( looks like for our )SM(libfoo)ES( project
  assum)HY(ing)YH( we have symlinked )SM(README.md)ES(, )SM(LICENSE)ES(, and
  )SM(NEWS)ES( from upstream in the )0 17 1 A(Create
  final package)17 0 TN TL()Ec /AF f D( step:)EP(

  ) 7 43 PR(./: {*/ -build/}                          \200
    doc{README.md PACKAGE-README.md NEWS} \200
    legal{LICENSE} manifest

# Don't install tests.
#
tests/: install = false)RP(

  )0 P(If the upstream project provides any other docu)HY(men)HY(ta)HY(tion)YH( \201detailed change
  logs, contribut)HY(ing)YH( guide)HY(lines)YH(, etc\202 or legal files \201alter)HY(na)HY(tive)YH( licenses,
  list of authors, code of conduct, etc\202, then you may want to symlink and
  list them as the )SM(doc{})ES( and )SM(legal{})ES( prereq)HY(ui)HY(sites)YH(,
  respec)HY(tively)YH(.)EP(

  )BR(
  )0 P(If you are pack)HY(ag)HY(ing)YH( an executable and it provides a man page, then it
  can also be listed in the root )SM(build)HY(file)YH()ES(. For example, if the
  man page file is called )SM(foo.1)ES(:)EP(

  ) 1 17 PR(./: ... man1{foo})RP(
  )BR(

  )BR(
  )0 P(One file you don't need to list is )SM(INSTALL)ES( \201or equiv)HY(a)HY(lent)YH(\202
  which normally contains the instal)HY(la)HY(tion)YH( instruc)HY(tions)YH( for the upstream build
  system. In the )SM(build2)ES( package of a third-party project the
  )SM(PACKAGE-README.md)ES( file serves this purpose \201see )0 60 1 A(Adjust )SM(PACKAGE-README.md)ES()60 0 TN TL()Ec /AF f D(
  for details\202.)EP(
  )BR(

  )0 3 52 H(2.8.2)WB 158 Sn()WB 54 Sn( Adjust root )SM(build)HY(file)YH()ES(:
  other subdi)HY(rec)HY(to)HY(ries)YH()EH(

  )0 P(If the upstream project has other subdi)HY(rec)HY(to)HY(ries)YH( that makes sense to
  include into the )SM(build2)ES( package, then now is a good time to
  take care of that. The most common such case will be extra docu)HY(men)HY(ta)HY(tion)YH(
  \201besides the root )SM(README)ES(\202, typi)HY(cally)YH( in a subdi)HY(rec)HY(tory)YH( called
  )SM(doc/)ES(, )SM(docs/)ES(, or )SM(docu)HY(men)HY(ta)HY(tion)YH(/)ES(.)EP(

  )0 P(The stan)HY(dard)YH( proce)HY(dure)YH( for handling such subdi)HY(rec)HY(to)HY(ries)YH( will be to
  symlink the rele)HY(vant)YH( files \201or the entire subdi)HY(rec)HY(tory)YH(\202 and then list the
  files as prereq)HY(ui)HY(sites)YH(. For this last step, there are two options: we can
  list the files directly in the root )SM(build)HY(file)YH()ES( or we can create
  a sepa)HY(rate)YH( )SM(build)HY(file)YH()ES( in the subdi)HY(rec)HY(tory)YH(.)EP(

  )BR(
  )0 P(If symlink)HY(ing)YH( entire subdi)HY(rec)HY(to)HY(ries)YH(, don't forget to also list them in
  )SM(.gitat)HY(tributes)YH()ES( if you want your package to be usable from the
  )SM(git)ES( repos)HY(i)HY(tory)YH( directly on Windows. See )R14 2 A(Symlinks and
  Windows)EA( for details.)EP(
  )BR(

  )0 P(Let's examine each approach using our )SM(libfoo)ES( as an example.
  We will assume that the upstream project contains the )SM(docs/)ES(
  subdi)HY(rec)HY(tory)YH( with addi)HY(tional)YH( )SM(*.md)ES( files that docu)HY(ment)YH( the
  library's API. It would make sense to include them into the
  )SM(build2)ES( package.)EP(

  )0 P(Listing the subdi)HY(rec)HY(tory)YH( files directly in the root
  )SM(build)HY(file)YH()ES( works best for simple cases, where you have a bunch
  of static files that don't require any special provi)HY(sions)YH(, such as
  customiza)HY(tions)YH( to their instal)HY(la)HY(tion)YH( loca)HY(tions)YH(. In this case we can symlink
  the entire )SM(docs/)ES( subdi)HY(rec)HY(tory)YH(:)EP(

  ) 2 42 PR($ cd libfoo/ # Change to the package root.
$ ln -s ../upstream/docs ./)RP(

  )0 P(The adjust)HY(ments)YH( to the root )SM(build)HY(file)YH()ES( are pretty
  straight)HY(for)HY(ward)YH(: we exclude the )SM(docs/)ES( subdi)HY(rec)HY(tory)YH( \201since it
  has no )SM(build)HY(file)YH()ES(\202 and list the )SM(*.md)ES( files as
  prereq)HY(ui)HY(sites)YH( using the )SM(doc{})ES( target type \201which, in
  partic)HY(u)HY(lar)YH(, makes sure they are installed into the appro)HY(pri)HY(ate)YH(
  loca)HY(tion)YH(\202:)EP(

  ) 4 43 PR(./: {*/ -build/ -docs/}                   \200
    doc{README.md PACKAGE-README.md NEWS} \200
    docs/doc{*.md}                        \200
    legal{LICENSE} manifest)RP(

  )0 P(The alter)HY(na)HY(tive)YH( approach \201create a sepa)HY(rate)YH( )SM(build)HY(file)YH()ES(\202 is a
  good choice if things are more compli)HY(cated)YH( than that. Let's say we need to
  adjust the instal)HY(la)HY(tion)YH( loca)HY(tion)YH( of the files in )SM(docs/)ES( because
  there is another )SM(README.md)ES( inside and that would conflict with
  the root one when installed into the same loca)HY(tion)YH(. This time we cannot
  symlink the top-level )SM(docs/)ES( subdi)HY(rec)HY(tory)YH( \201because we need to
  place a )SM(build)HY(file)YH()ES( there\202. The two options here are to either
  symlink the indi)HY(vid)HY(ual)YH( files or intro)HY(duce)YH( another subdi)HY(rec)HY(tory)YH( level inside
  )SM(docs/)ES( \201which is the same approach as discussed in )0 90 1 A(Don't build your main targets in the
  root )SM(build)HY(file)YH()ES()90 0 TN TL()Ec /AF f D(\202. Let's illus)HY(trate)YH( both sub-cases.)EP(

  )0 P(Symlink)HY(ing)YH( indi)HY(vid)HY(ual)YH( files works best when you don't expect the set of
  files to change often. For example, if )SM(docs/)ES( contains a man
  page and its HTML render)HY(ing)YH(, then it's unlikely this set will change. On the
  other hand, if )SM(docs/)ES( contains a manual split into an
  )SM(.md)ES( file per chapter, then there is a good chance this set of
  files will fluc)HY(tu)HY(ate)YH( between releases.)EP(

  )0 P(Contin)HY(u)HY(ing)YH( with our )SM(libfoo)ES( example, this is how we symlink
  the indi)HY(vid)HY(ual)YH( )SM(*.md)ES( files in )SM(docs/)ES(:)EP(

  ) 4 42 PR($ cd libfoo/ # Change to the package root.
$ mkdir docs
$ cd docs/
$ ln -s ../../upstream/docs/*.md ./)RP(

  )0 P(Then write a new )SM(build)HY(file)YH()ES( in )SM(docs/)ES(:)EP(

  ) 7 71 PR(./: doc{*.md}

# Install the documentation in docs/ into the manual/ subdirectory of,
# say, /usr/share/doc/libfoo/ since we cannot install both its and root
# README.md into the same location.
#
doc{*.md}: install = doc/manual/)RP(

  )0 P(Note that we don't need to make any changes to the root
  )SM(build)HY(file)YH()ES( since this subdi)HY(rec)HY(tory)YH( will auto)HY(mat)HY(i)HY(cally)YH( get picked
  up by the )SM({*/\240-build/})ES( name pattern that we have
  there.)EP(

  )0 P(Let's now look at the alter)HY(na)HY(tive)YH( arrange)HY(ment)YH( with another subdi)HY(rec)HY(tory)YH(
  level inside )SM(docs/)ES(. Here we achieve the same result but in a
  slightly differ)HY(ent)YH( way. Specif)HY(i)HY(cally)YH(, we call the subdi)HY(rec)HY(tory)YH(
  )SM(manual/)ES( and install recre)HY(at)HY(ing)YH( subdi)HY(rec)HY(to)HY(ries)YH( \201see )0 2 A(Installing)EA(
  for back)HY(ground)YH(\202:)EP(

  ) 4 42 PR($ cd libfoo/ # Change to the package root.
$ mkdir -p docs/manual
$ cd docs/manual/
$ ln -s ../../../upstream/docs/*.md ./)RP(

  )0 P(And the corre)HY(spond)HY(ing)YH( )SM(build)HY(file)YH()ES( in )SM(docs/)ES(:)EP(

  ) 10 70 PR(./: doc{**.md}

# Install the documentation in docs/ into, say, /usr/share/doc/libfoo/
# recreating subdirectories.
#
doc{*}:
{
  install = doc/
  install.subdirs = true
})RP(

  )BR(
  )0 P(Yet another option would be to open a scope for the )SM(docs/)ES(
  subdi)HY(rec)HY(tory)YH( directly in the root )SM(build)HY(file)YH()ES( \201see )0 2 A(Output
  Direc)HY(to)HY(ries)YH( and Scopes)EA( for back)HY(ground)YH(\202. For example:)EP(

  ) 2 42 PR($ cd libfoo/ # Change to the package root.
$ ln -s ../upstream/docs ./)RP(

  )0 P(And then add the follow)HY(ing)YH( to the root )SM(build)HY(file)YH()ES(:)EP(

  ) 10 68 PR(docs/
{
  ./: doc{*.md}

  # Install the documentation in docs/ into the manual/ subdirectory
  # of, say, /usr/share/doc/libfoo/ since we cannot install both its
  # and root README.md into the same location.
  #
  doc{*.md}: install = doc/manual/
})RP(

  )0 P(However, this approach should be used spar)HY(ingly)YH( since it can quickly make
  the root )SM(build)HY(file)YH()ES( hard to compre)HY(hend)YH(. Note also that it cannot
  be used for main targets since an export stub requires a
  )SM(build)HY(file)YH()ES( to load \201see )0 90 1 A(Don't build your main targets in the
  root )SM(build)HY(file)YH()ES()90 0 TN TL()Ec /AF f D( for details\202.)EP(
  )BR(

  )0 3 53 H(2.8.3)WB 159 Sn()WB 55 Sn( Adjust root
  )SM(build)HY(file)YH()ES(: commit and test)EH(

  )0 P(Once all the adjust)HY(ments)YH( to the root )SM(build)HY(file)YH()ES( are made, it
  makes sense to test it locally \201this time from the root of the package\202,
  commit our changes, and test with CI:)EP(

  ) 3 42 PR($ cd libfoo/ # Change to the package root.
$ b test
$ bdep test -a)RP(

  )0 P(If you had to add any extra files to the root )SM(build)HY(file)YH()ES( \201or
  add )SM(build)HY(files)YH()ES( in extra subdi)HY(rec)HY(to)HY(ries)YH(\202, then it also makes
  sense to test the instal)HY(la)HY(tion)YH( \201)0 43 1 A(Test locally: instal)HY(la)HY(tion)YH()43 0 TN TL()Ec /AF f D(\202 and
  the prepa)HY(ra)HY(tion)YH( of the source distri)HY(bu)HY(tion)YH( \201)0 44 1 A(Test locally: distri)HY(bu)HY(tion)YH()44 0 TN TL()Ec /AF f D(\202 to make
  sure the extra files end up in the right places.)EP(

  )0 P(Then commit our changes and CI:)EP(

  ) 7 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Adjust root buildfile"
$ git push

$ bdep ci)RP(

  )0 3 54 H(2.8.4)WB 160 Sn()WB 56 Sn( Adjust )SM(mani)HY(fest)YH()ES()EH(

  )0 P(The next file we need to look over is the package's
  )SM(mani)HY(fest)YH()ES(. Here is what it will look like, using our
  )SM(libfoo)ES( as an example:)EP(

  ) 16 53 PR(: 1
name: libfoo
version: 2.1.0-a.0.z
language: c++
project: foo
summary: C++ library implementing secure Foo protocol
license: MIT ; MIT License.
description-file: README.md
package-description-file: PACKAGE-README.md
changes-file: NEWS
url: https://example.org/upstream
email: upstream@example.org
package-url: https://github.com/build2-packaging/foo
package-email: packaging@build2.org ; Mailing list.
depends: * build2 >= 0.16.0
depends: * bpkg >= 0.16.0)RP(

  )0 P(You can find the descrip)HY(tion)YH( of these and other package
  )SM(mani)HY(fest)YH()ES( values in )0 2 A(Package
  Mani)HY(fest)YH()EA( \201the mani)HY(fest)YH( format is described in )0 2 A(Mani)HY(fest)YH(
  Format)EA(\202.)EP(

  )0 P(In the above listing the values that we likely need to adjust are
  )SM(summary)ES( and )SM(license)ES(, unless correctly
  auto-detected by )SM(bdep-new)ES( in the )0 17 1 A(Create final package)17 0 TN TL()Ec /AF f D( step. See )0 57 1 A(Adjust )SM(mani)HY(fest)YH()ES(:
  )SM(summary)ES()57 0 TN TL()Ec /AF f D( and )0 58 1 A(Adjust
  )SM(mani)HY(fest)YH()ES(: )SM(license)ES()58 0 TN TL()Ec /AF f D( below for guide)HY(lines)YH( on
  chang)HY(ing)YH( these values.)EP(

  )BR(
  )0 P(It is not uncom)HY(mon)YH( for projects to be licensed under multi)HY(ple)YH( licenses.
  Note, however, that )SM(bdep-new)ES( will only detect one license and
  you will need to specify any addi)HY(tional)YH( licenses manu)HY(ally)YH(.)EP(
  )BR(

  )0 P(We will also need to change )SM(url)ES( and )SM(email)ES( with
  the upstream project's home)HY(page)YH( URL and e-mail, respec)HY(tively)YH(. If upstream
  doesn't have a dedi)HY(cated)YH( website for the project, then use its repos)HY(i)HY(tory)YH(
  URL on GitHub or equiv)HY(a)HY(lent)YH(. For e-mail you would normally use a mailing
  list address. If upstream doesn't have any e-mail contacts, then you can
  drop this value from the )SM(mani)HY(fest)YH()ES(. The )SM(package-url)ES(
  and )SM(package-email)ES( values normally do not need to be
  changed.)EP(

  )BR(
  )0 P()R38 2 A(pack)HY(ag)HY(ing)YH(@build2.org)EA( is a mailing
  list for discus)HY(sions)YH( related to the pack)HY(ag)HY(ing)YH( efforts of third-party
  projects.)EP(
  )BR(

  )0 P(Note also that while you may be tempted to adjust the
  )SM(version)ES( value, resist this temp)HY(ta)HY(tion)YH( since this will be done
  auto)HY(mat)HY(i)HY(cally)YH( by )0 2 A()SM()BD(bdep-release\2011\202)ES()ES()EA(
  later.)EP(

  )0 P(You may also want to add the follow)HY(ing)YH( values in certain cases:)EP(

  )0 DL(  )0 DT()0 2 A()SM()BD(changes-file)ES()ES()EA(
  )DD(If you have added any extra news of changelog files to the root
  )SM(build)HY(file)YH()ES( \201see )0 53 1 A(Adjust root
  build)HY(file)YH()53 0 TN TL()Ec /AF f D(\202, then it may also make sense to list them in the
  )SM(mani)HY(fest)YH()ES(. For example:

  ) 1 27 PR(changes-file: ChangeLog.txt)RP(

  )0 DT()0 2 A()SM()BD(topics)ES()ES()EA(
  )DD(Package topics. For example:

  ) 1 42 PR(topics: network protocol, network security)RP(

  )BR(
  )0 P(If the upstream project is hosted on GitHub or similar, then you can
  usually copy the topics from the upstream repos)HY(i)HY(tory)YH( descrip)HY(tion)YH(.)EP(
  )BR(

  )0 DT()0 2 A()SM()BD(doc-url)ES()ES()EA(
  )BR(  )0 2 A()SM()BD(src-url)ES()ES()EA(
  )DD(Docu)HY(men)HY(ta)HY(tion)YH( and source code URLs. For example:

  ) 2 37 PR(doc-url: https://example.org/foo/doc/
src-url: https://github.com/.../foo)RP(
  )LD(

  )0 3 55 H(2.8.5)WB 161 Sn()WB 57 Sn( Adjust )SM(mani)HY(fest)YH()ES(:
  )SM(summary)ES()EH(

  )0 P(For )SM(summary)ES( use a brief descrip)HY(tion)YH( of the func)HY(tion)HY(al)HY(ity)YH(
  provided by the library or executable. Less than 70 char)HY(ac)HY(ters)YH( is a good
  target to aim for. Don't capi)HY(tal)HY(ize)YH( subse)HY(quent)YH( words unless proper nouns and
  omit the trail)HY(ing)YH( dot. For example:)EP(

  ) 1 32 PR(summary: Vim xxd hexdump utility)RP(

  )0 P(Omit weasel words such as "modern", "simple", "fast", "small", etc.,
  since they don't convey anything specific. Omit "header-only" or
  "single-header" for C/C++ libraries since, at least in the context of
  )SM(build2)ES(, it does not imply any benefit.)EP(

  )0 P(If upstream does not offer a sensi)HY(ble)YH( summary, the follow)HY(ing)YH( template is
  recom)HY(mended)YH( for libraries:)EP(

  ) 2 36 PR(summary: <functionality> C library
summary: <functionality> C++ library)RP(

  )0 P(For example:)EP(

  ) 2 61 PR(summary: Event notification C library
summary: Validating XML parsing and serialization C++ library)RP(

  )0 P(If the project consists of multi)HY(ple)YH( pack)HY(ages)YH(, it may be tempt)HY(ing)YH( to name
  each package in terms of the overall project name, for example:)EP(

  ) 2 27 PR(name: libigl-core
summary: libigl core module)RP(

  )0 P(This doesn't give the user any clue about what func)HY(tion)HY(al)HY(ity)YH( is provided
  unless they find out what )SM(libigl)ES( is about. Better:)EP(

  ) 1 53 PR(summary: Geometry processing C++ library, core module)RP(

  )0 P(If you follow the above pattern, then to produce a summary for exter)HY(nal)YH(
  tests or exam)HY(ples)YH( pack)HY(ages)YH( simply add "tests" or "exam)HY(ples)YH(" at the end, for
  example:)EP(

  ) 2 62 PR(summary: Event notification C library tests
summary: Geometry processing C++ library, core module examples)RP(

  )0 3 56 H(2.8.6)WB 162 Sn()WB 58 Sn( Adjust )SM(mani)HY(fest)YH()ES(:
  )SM(license)ES()EH(

  )0 P(For )SM(license)ES(, use the )R39 2 A(SPDX license ID)EA( if at all possi)HY(ble)YH(. If
  multi)HY(ple)YH( licenses are involved, use the SPDX License expres)HY(sion)YH(. See the )R40 2 A()SM(license)ES(
  mani)HY(fest)YH( value)EA( docu)HY(men)HY(ta)HY(tion)YH( for details, includ)HY(ing)YH( the list of the SPDX
  IDs for the commonly used licenses.)EP(

  )0 3 57 H(2.8.7)WB 163 Sn()WB 59 Sn( Adjust )SM(mani)HY(fest)YH()ES(:
  commit and test)EH(

  )0 P(Once all the adjust)HY(ments)YH( to the )SM(mani)HY(fest)YH()ES( are made, it makes
  sense to test it locally, commit our changes, and test with CI:)EP(

  ) 3 42 PR($ cd libfoo/ # Change to the package root.
$ b test
$ bdep test -a)RP(

  )0 P(Then commit our changes and CI:)EP(

  ) 7 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Adjust manifest"
$ git push

$ bdep ci)RP(

  )0 3 58 H(2.8.8)WB 164 Sn()WB 60 Sn( Adjust
  )SM(PACKAGE-README.md)ES()EH(

  )0 P(The last package file we need to adjust is )SM(PACKAGE-README.md)ES(
  which describes how to use the package from a )SM(build2)ES(-based
  project. The template gener)HY(ated)YH( by )SM(bdep-new)ES( estab)HY(lishes)YH( the
  recom)HY(mended)YH( struc)HY(ture)YH( and includes a number of place)HY(hold)HY(ers)YH( enclosed in
  )SM(<\240>)ES(, such as )SM(<UPSTREAM-NAME>)ES( and
  )SM(<SUMMARY-OF-FUNC)HY(TION)HY(AL)HY(ITY)YH(>)ES(, that need to be replaced with
  the package-specific content. While all the place)HY(hold)HY(ers)YH( should be
  self-explana)HY(tory)YH(, below are a couple of guide)HY(lines)YH(.)EP(

  )0 P(For )SM(<SUMMARY-OF-FUNC)HY(TION)HY(AL)HY(ITY)YH(>)ES( it's best to copy a
  para)HY(graph)YH( or two from the upstream docu)HY(men)HY(ta)HY(tion)YH(, usually from
  )SM(README.md)ES( or the project's web page.)EP(

  )BR(
  )0 P(If the )SM(bdep new)ES( command was able to extract the summary from
  upstream )SM(README)ES(, then the summary in the heading \201first line\202
  will contain that infor)HY(ma)HY(tion)YH(. Other)HY(wise)YH(, you would need to adjust it
  manu)HY(ally)YH(, similar to )SM(mani)HY(fest)YH()ES( above. In this case use the
  )SM(summary)ES( value form the )SM(mani)HY(fest)YH()ES(, perhaps slightly
  short)HY(ened)YH(.)EP(
  )BR(

  )0 P(If the package contains a single importable target, as is typical with
  libraries, then it makes sense to drop the "Importable targets" section
  since it won't add anything that hasn't already been said in the "Usage"
  section.)EP(

  )0 P(Simi)HY(larly)YH(, if the package has no config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH(, then it makes
  sense to drop the "Config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH(" section.)EP(

  )0 P(For inspi)HY(ra)HY(tion)YH(, see)EP(

  )0 P()R41 2 A()SM(PACKAGE-README.md)ES()EA(
  in )R28 2 A()SM(zstd)ES()EA(
  and )R42 2 A()SM(PACKAGE-README.md)ES()EA(
  in )R43 2 A()SM(libevent)ES()EA(
  \201libraries\202 as well as )R44 2 A()SM(PACKAGE-README.md)ES()EA(
  in )R28 2 A()SM(zstd)ES()EA(
  and )R45 2 A()SM(README.md)ES()EA(
  in )R46 2 A()SM(xxd)ES()EA(
  \201executa)HY(bles)YH(\202.)EP(

  )BR(
  )0 P(If upstream does not provide a )SM(README)ES( file, then it makes
  sense to rename )SM(PACKAGE-README.md)ES( to just
  )SM(README.md)ES( in the )SM(build2)ES( package, as was done in
  the )SM(xxd)ES( package mentioned above.)EP(
  )BR(

  )0 P(Once )SM(PACKAGE-README.md)ES( is ready, commit and push the
  changes. You may also want to view the result on GitHub to make sure
  every)HY(thing)YH( is rendered correctly.)EP(

  ) 5 50 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Adjust PACKAGE-README.md"
$ git push)RP(

  )0 2 59 H(2.9)WB 165 Sn()WB 61 Sn( Adjust package repos)HY(i)HY(tory)YH(
  )SM(README.md)ES()EH(

  )0 P(With all the package files taken care of, the last file we need to adjust
  is )SM(README.md)ES( in the root of our package repos)HY(i)HY(tory)YH( \201it was
  created in the )0 10 1 A(Initial)HY(ize)YH( package repos)HY(i)HY(tory)YH( with
  )SM(bdep new)ES()10 0 TN TL()Ec /AF f D( step\202.)EP(

  )BR(
  )0 P(If you need to add addi)HY(tional)YH( pack)HY(ages)YH( and are doing this one package at
  a time \201for example, first library then executable in the "library and
  executable" project\202, then this is the point where you would want to restart
  from )0 12 1 A(Create package and gener)HY(ate)YH(
  )SM(build)HY(file)YH()ES( templates)12 0 TN TL()Ec /AF f D( for another iter)HY(a)HY(tion)YH(. Only once all
  the pack)HY(ages)YH( are added does it make sense to continue with updat)HY(ing)YH( this
  )SM(README.md)ES(.)EP(
  )BR(

  )0 P(The primary purpose of the package repos)HY(i)HY(tory)YH( )SM(README.md)ES( is
  to provide setup instruc)HY(tions)YH( as well as any other rele)HY(vant)YH( infor)HY(ma)HY(tion)YH( for
  the devel)HY(op)HY(ment)YH( of the pack)HY(ages)YH( as opposed to their consump)HY(tion)YH(. However,
  it's also a good idea to give a brief summary of what this repos)HY(i)HY(tory)YH( is
  about and to point users inter)HY(ested)YH( in consump)HY(tion)YH( to the
  )SM(PACKAGE-README.md)ES( files.)EP(

  )0 P(The template gener)HY(ated)YH( by )SM(bdep new)ES( estab)HY(lishes)YH( the
  recom)HY(mended)YH( struc)HY(ture)YH( to achieve these objec)HY(tives)YH(. It includes a number of
  place)HY(hold)HY(ers)YH( enclosed in )SM(<\240>)ES(, such as
  )SM(<UPSTREAM-URL>)ES( and
  )SM(<SUMMARY-OF-FUNC)HY(TION)HY(AL)HY(ITY)YH(>)ES(, that need to be replaced with
  the repos)HY(i)HY(tory)YH(-specific content. While all the place)HY(hold)HY(ers)YH( should be
  self-explana)HY(tory)YH(, below are a couple of guide)HY(lines)YH(.)EP(

  )0 P(If there is a single package, then )SM(<SUMMARY>)ES( in the
  heading can be the same as in )SM(PACKAGE-README.md)ES(. If there are
  multi)HY(ple)YH( pack)HY(ages)YH(, then use an overall summary of the upstream project.)EP(

  )0 P(For )SM(<SUMMARY-OF-FUNC)HY(TION)HY(AL)HY(ITY)YH(>)ES( it's best to copy a
  para)HY(graph)YH( or two from the upstream docu)HY(men)HY(ta)HY(tion)YH(, usually from
  )SM(README.md)ES( or the project's web page. Again, for a single
  package, this can be copied directly from
  )SM(PACKAGE-README.md)ES(.)EP(

  )0 P(If there are multi)HY(ple)YH( pack)HY(ages)YH( in the repos)HY(i)HY(tory)YH(, then it's recom)HY(mended)YH(
  to replace a single link to )SM(PACKAGE-README.md)ES( with a list of
  links \201this also shows the avail)HY(able)YH( pack)HY(ages)YH(\202. For example:)EP(

  ) 5 65 PR(... If you want to use `foo` in your `build2`-based project, then
instead see the accompanying `PACKAGE-README.md` files:

* [`libfoo/PACKAGE-README.md`]\201libfoo/PACKAGE-README.md\202
* [`foo/PACKAGE-README.md`]\201foo/PACKAGE-README.md\202)RP(

  )0 P(The remain)HY(der)YH( of the gener)HY(ated)YH( )SM(README.md)ES( file are the
  stan)HY(dard)YH( )SM(bdep)ES( initial)HY(iza)HY(tion)YH( instruc)HY(tions)YH(. Adjust them if your
  package repos)HY(i)HY(tory)YH( requires anything special \201for example, a host
  config)HY(u)HY(ra)HY(tion)YH(\202. This is also the place to mention anything unusual, such as
  that upstream does not use semver \201and thus only a subset of
  )SM(bdep)ES( func)HY(tion)HY(al)HY(ity)YH( is usable\202.)EP(

  )0 P(For inspi)HY(ra)HY(tion)YH(, see )R47 2 A()SM(README.md)ES()EA(
  in the )R28 2 A()SM(zstd)ES()EA(
  package repos)HY(i)HY(tory)YH(.)EP(

  )0 P(Once the repos)HY(i)HY(tory)YH( )SM(README.md)ES( is ready, commit and push the
  changes. You may also want to view the result on GitHub to make sure
  every)HY(thing)YH( is rendered correctly.)EP(

  ) 5 53 PR($ cd foo/ # Change to the package repository root.
$ git add .
$ git status
$ git commit -m "Adjust package repository README.md"
$ git push)RP(

  )0 2 60 H(2.10)WB 166 Sn()WB 62 Sn( Release and publish)EH(

  )0 P(Once all the adjust)HY(ments)YH( are in and every)HY(thing)YH( is tested, we can release
  the final version of the package and then publish it to )R1 2 A(cppget.org)EA(. Both of these steps are auto)HY(mated)YH(
  with the corre)HY(spond)HY(ing)YH( )SM(bdep)ES( commands. But before perform)HY(ing)YH(
  these steps we need to trans)HY(fer)YH( the package repos)HY(i)HY(tory)YH( to )R5 2 A(github.com/build2-pack)HY(ag)HY(ing)YH()EA(.)EP(

  )0 3 61 H(2.10.1)WB 167 Sn()WB 63 Sn( Trans)HY(fer)YH( package
  repos)HY(i)HY(tory)YH()EH(

  )0 P(If you have been doing your work in a repos)HY(i)HY(tory)YH( in your personal
  workspace, then now is the time to trans)HY(fer)YH( it to the )R5 2 A(github.com/build2-pack)HY(ag)HY(ing)YH()EA(
  orga)HY(ni)HY(za)HY(tion)YH(.)EP(

  )BR(
  )0 P(It is impor)HY(tant)YH( to trans)HY(fer)YH( the repos)HY(i)HY(tory)YH( before publish)HY(ing)YH( the first
  version of the package since the repos)HY(i)HY(tory)YH( is used as a proxy for package
  name owner)HY(ship)YH( \201see )0 2 A()SM()BD(bdep-publish\2011\202)ES()ES()EA(
  for details\202. If you publish the package from your personal workspace and
  then trans)HY(fer)YH( the repos)HY(i)HY(tory)YH(, the owner)HY(ship)YH( infor)HY(ma)HY(tion)YH( will have to be
  adjusted manu)HY(ally)YH(, which we would prefer to avoid.)EP(
  )BR(

  )0 P(The first step is to become a member of this orga)HY(ni)HY(za)HY(tion)YH( \201unless you
  already are\202. This will give you permis)HY(sions)YH( to create new repos)HY(i)HY(to)HY(ries)YH(,
  which is required to perform a trans)HY(fer)YH( \201you will also have full read/write
  access to the repos)HY(i)HY(tory)YH( once trans)HY(ferred)YH(\202. To get an invite, )R10 2 A(get in touch)EA( not
  forget)HY(ting)YH( to mention your GitHub user name.)EP(

  )0 P(If your repos)HY(i)HY(tory)YH( has any prefixes, such as )SM(build2-)ES(, or
  suffixes such as )SM(-package)ES(, then the next step is to rename it
  to follow the )0 8 1 A(Use upstream repos)HY(i)HY(tory)YH( name as
  package repos)HY(i)HY(tory)YH( name)8 0 TN TL()Ec /AF f D( guide)HY(line)YH(. Go to the repos)HY(i)HY(tory)YH('s Settings on
  GitHub where you should see the Rename button.)EP(

  )0 P(Finally, to perform the trans)HY(fer)YH(, go to the repos)HY(i)HY(tory)YH('s Settings, Danger
  Zone section, where you should see the Trans)HY(fer)YH( button. Select
  )SM(build2-pack)HY(ag)HY(ing)YH()ES( as the orga)HY(ni)HY(za)HY(tion)YH( to trans)HY(fer)YH( to, and
  complete the trans)HY(fer)YH(.)EP(

  )0 P(Once trans)HY(ferred)YH(, you will be consid)HY(ered)YH( the main)HY(tainer)YH( of this package
  going forward. If other members of the )SM(build2-pack)HY(ag)HY(ing)YH()ES(
  orga)HY(ni)HY(za)HY(tion)YH( wish to partic)HY(i)HY(pate)YH( in the package main)HY(te)HY(nance)YH(, the correct
  etiquette is to do this via pull requests. However, if you lose inter)HY(est)YH( in
  main)HY(tain)HY(ing)YH( a package or other)HY(wise)YH( become unre)HY(spon)HY(sive)YH(, we may allow a new
  main)HY(tainer)YH( to take over this role.)EP(

  )BR(
  )0 P(In extraor)HY(di)HY(nary)YH( circum)HY(stances)YH( the )SM(build2-pack)HY(ag)HY(ing)YH()ES(
  admin)HY(is)HY(tra)HY(tors)YH( may make direct changes to the package, for example, to
  release a new revi)HY(sion)YH( in order to address a crit)HY(i)HY(cal)YH( issue. They will still
  try to coor)HY(di)HY(nate)YH( the changes with the main)HY(tainer)YH( but may not always be able
  to wait for a response in time-sensi)HY(tive)YH( cases.)EP(
  )BR(

  )0 3 62 H(2.10.2)WB 168 Sn()WB 64 Sn( Release final version)EH(

  )0 P(As you may recall, our package currently has a pre-release snap)HY(shot)YH(
  version of the upstream version \201see )0 18 1 A(Adjust package version)18 0 TN TL()Ec /AF f D(\202. Once all
  the changes are in, we can change to the final upstream version, in a sense
  signal)HY(ing)YH( that this package version is ready.)EP(

  )BR(
  )0 P(If you are working in a branch, then now is also the time to merge it
  into )SM(master)ES( \201or equiv)HY(a)HY(lent)YH(\202.)EP(
  )BR(

  )0 P(The recom)HY(mended)YH( way to do this is with the )0 2 A()SM()BD(bdep-release\2011\202)ES()ES()EA(
  command \201see )0 2 A(Version)HY(ing)YH(
  and Release Manage)HY(ment)YH()EA( for back)HY(ground)YH(\202. Besides replac)HY(ing)YH( the
  )SM(version)ES( value in the package )SM(mani)HY(fest)YH()ES( file, it
  also commits this change, tags it with the
  )SM(v)I(X)ES(.)I(Y)ES(.)I(Z)ES()ES( tag, and can be instructed to push
  the changes \201or show the )SM(git)ES( command to do so\202. This command
  also by default "opens" the next devel)HY(op)HY(ment)YH( version, which is some)HY(thing)YH(
  that we normally want for our own projects but not when we package a
  third-party one \201since we cannot predict which version upstream will release
  next\202. So we disable this func)HY(tion)HY(al)HY(ity)YH(. For example:)EP(

  ) 2 50 PR($ cd foo/ # Change to the package repository root.
$ bdep release --no-open --show-push)RP(

  )0 P(Then review the commit made by )SM(bdep-release)ES( and, if
  every)HY(thing)YH( looks good, push the changes by copying the command that it
  printed:)EP(

  ) 2 17 PR($ git diff HEAD~1
$ git push ...)RP(

  )BR(
  )0 P(If some)HY(thing)YH( is wrong and you need to undo this commit, don't forget to
  also remove the tag. Note also that once you have pushed your changes, you
  cannot undo the commit. Instead, you will need to make a revi)HY(sion)YH(. See )0 66 1 A(Version manage)HY(ment)YH()66 0 TN TL()Ec /AF f D( for back)HY(ground)YH( and
  details.)EP(
  )BR(

  )0 3 63 H(2.10.3)WB 169 Sn()WB 65 Sn( Publish released version)EH(

  )0 P(Once the version is released we can publish the package to )R1 2 A(cppget.org)EA( with the )0 2 A()SM()BD(bdep-publish\2011\202)ES()ES()EA(
  command \201see )0 2 A(Version)HY(ing)YH(
  and Release Manage)HY(ment)YH()EA( for back)HY(ground)YH(\202:)EP(

  ) 2 50 PR($ cd foo/ # Change to the package repository root.
$ bdep publish)RP(

  )0 P(The )SM(bdep-publish)ES( command prepares the source distri)HY(bu)HY(tion)YH( of
  your package, uploads the result)HY(ing)YH( archive to the package repos)HY(i)HY(tory)YH(, and
  prints a link to the package submis)HY(sion)YH( in the queue. Open this link in the
  browser and check that there are no surprises in the build results \201they
  should match the earlier CI results\202 or in the displayed package infor)HY(ma)HY(tion)YH(
  \201)SM(PACKAGE-README.md)ES(, etc\202.)EP(

  )BR(
  )0 P(While there should normally be no discrep)HY(an)HY(cies)YH( in the build results
  compared to our earlier CI submis)HY(sions)YH(, the way the pack)HY(ages)YH( are built on CI
  and in the package repos)HY(i)HY(tory)YH( are not exactly the same. Specif)HY(i)HY(cally)YH(, CI
  builds them from )SM(git)ES( while the package repos)HY(i)HY(tory)YH( \235 from
  the submit)HY(ted)YH( package archives. If there are differ)HY(ences)YH(, it's almost always
  due to issues in the source distri)HY(bu)HY(tion)YH( prepa)HY(ra)HY(tion)YH( \201see )0 44 1 A(Test locally: distri)HY(bu)HY(tion)YH()44 0 TN TL()Ec /AF f D(\202.)EP(
  )BR(

  )0 P(If every)HY(thing)YH( looks good, then you are done: the package submis)HY(sion)YH( will
  be reviewed and, if there are no prob)HY(lems)YH(, moved to )R1 2 A(cppget.org)EA(. If there are prob)HY(lems)YH(, then an
  issue will be created in the package repos)HY(i)HY(tory)YH( with the review feed)HY(back)YH(. In
  this case you will need to )0 67 1 A(release and publish a version
  revi)HY(sion)YH()67 0 TN TL()Ec /AF f D( to address any prob)HY(lems)YH(. However, in both cases, you should
  first read through the follow)HY(ing)YH( )0 66 1 A(Package
  version manage)HY(ment)YH()66 0 TN TL()Ec /AF f D( section to under)HY(stand)YH( the recom)HY(mended)YH( "version
  life)HY(cy)HY(cle)YH(" of a third-party package.)EP(

  )0 P(Also, if there is an issue for this package in )R11 2 A(github.com/build2-pack)HY(ag)HY(ing)YH(/WISH)HY(LIST)YH()EA(,
  then you would want to add a comment and close it once the package has been
  moved to )R1 2 A(cppget.org)EA(.)EP(

  )0 2 64 H(2.11)WB 170 Sn()WB 66 Sn( Package version manage)HY(ment)YH()EH(

  )0 P(Once we have pushed the release commit, in order to preserve contin)HY(u)HY(ous)YH(
  version)HY(ing)YH( \201see )0 18 1 A(Adjust package
  version)18 0 TN TL()Ec /AF f D( for back)HY(ground)YH(\202, no further changes should be made to the
  package without also chang)HY(ing)YH( its version.)EP(

  )BR(
  )0 P(More precisely, you can make and commit changes without chang)HY(ing)YH( the
  version provided they don't affect the package. For example, you may keep a
  )SM(TODO)ES( file in the root of your repos)HY(i)HY(tory)YH( which is not part of
  any package. Updat)HY(ing)YH( such a file without chang)HY(ing)YH( the version is ok since
  the package remains unchanged.)EP(
  )BR(

  )0 P(While in our own projects we can change the versions as we see fit, with
  third-party projects the versions are dictated by upstream and as a result
  we are limited to what we can use to fix issues in our pack)HY(ag)HY(ing)YH( work
  itself. It may be tempt)HY(ing)YH( \201and perhaps even concep)HY(tu)HY(ally)YH( correct\202 to
  release a patch version for our own fixes, however, we will be in trouble if
  later upstream releases the same patch version but with a differ)HY(ent)YH( set of
  changes \201plus the users of our package may wonder where did this version
  come from\202. As a result, we should only change the major, minor, or patch
  compo)HY(nents)YH( of the package version in response to the corre)HY(spond)HY(ing)YH( upstream
  releases. For fixes to the pack)HY(ag)HY(ing)YH( work itself we should instead use
  version revi)HY(sions)YH(.)EP(

  )BR(
  )0 P(Because a revi)HY(sion)YH( replaces the exist)HY(ing)YH( version, we should try to limit
  revi)HY(sion)YH( changes to bug fixes and prefer)HY(ably)YH( only in the package
  "infras)HY(truc)HY(ture)YH(" \201)SM(build)HY(files)YH()ES(, )SM(mani)HY(fest)YH()ES(, etc\202.
  Fixes to upstream source code should be limited to crit)HY(i)HY(cal)YH( bugs and be
  prefer)HY(ably)YH( back)HY(ported)YH( from upstream. To put it another way, changes in a
  revi)HY(sion)YH( should have an even more limited scope than a patch release.)EP(
  )BR(

  )0 P(Based on this, the recom)HY(mended)YH( "version life)HY(cy)HY(cle)YH(" for a third-party
  package is as follows:)EP(

  )4 OL(  )-1 LI(After a release \201the )0 64 1 A(Release
  final version)64 0 TN TL()Ec /AF f D( step above\202, for example, version )SM(2.1.0)ES(, the
  package enters a "revi)HY(sion)YH( phase" where we can release revi)HY(sions)YH(
  \201)SM(2.1.0+1)ES(, )SM(2.1.0+2)ES(, etc\202 to address any issues in
  the pack)HY(ag)HY(ing)YH( work. See )0 67 1 A(New
  revi)HY(sion)YH()67 0 TN TL()Ec /AF f D( for the detailed proce)HY(dure)YH(.

  )-1 LI(When a new upstream version is released, for example version
  )SM(2.2.0)ES(, and we wish to upgrade our package to this version, we
  switch to its pre-release snap)HY(shot)YH( version \201)SM(2.2.0-a.0.z)ES(\202 the
  same way as we did in the )0 18 1 A(Adjust
  package version)18 0 TN TL()Ec /AF f D( step initially. See )0 68 1 A(New version)68 0 TN TL()Ec /AF f D( for the detailed
  proce)HY(dure)YH(.

  )-1 LI(Once we are done upgrad)HY(ing)YH( to the new upstream version, we release the
  final version just like in the )0 64 1 A(Release final version)64 0 TN TL()Ec /AF f D( step
  initially. At this point the package enters another revi)HY(sion)YH( phase.
  )LO(

  )0 P(Note also that in the above example, once we have switched to
  )SM(2.2.0-a.0.z)ES(, we cannot go back and release another revi)HY(sion)YH( or
  patch version for )SM(2.1.0)ES( on the current branch. Instead, we will
  need to create a sepa)HY(rate)YH( branch for the )SM(2.1.Z)ES( release series
  and make a revi)HY(sion)YH( or patch version there. See )0 83 1 A(New version/revi)HY(sion)YH( in old
  release series)83 0 TN TL()Ec /AF f D( for the detailed proce)HY(dure)YH(.)EP(

  )0 3 65 H(2.11.1)WB 171 Sn()WB 67 Sn( New revi)HY(sion)YH()EH(

  )0 P(As discussed in )0 66 1 A(Package version
  manage)HY(ment)YH()66 0 TN TL()Ec /AF f D(, we release revi)HY(sions)YH( to fix issues in the package
  "infras)HY(truc)HY(ture)YH(" \201)SM(build)HY(files)YH()ES(, )SM(mani)HY(fest)YH()ES(, etc\202 as
  well as crit)HY(i)HY(cal)YH( bugs in upstream source code.)EP(

  )BR(
  )0 P(Releas)HY(ing)YH( a new revi)HY(sion)YH( is also a good oppor)HY(tu)HY(nity)YH( to review and fix any
  accu)HY(mu)HY(lated)YH( issues that didn't warrant a revi)HY(sion)YH( on their own. See )0 80 1 A(New version: review/fix
  accu)HY(mu)HY(lated)YH( issues)80 0 TN TL()Ec /AF f D( for back)HY(ground)YH(.)EP(
  )BR(

  )0 P(In the revi)HY(sion)YH( phase of the package version life)HY(cy)HY(cle)YH( \201i.e., when the
  version does not end with )SM(-a.0.z)ES(\202, every commit must be
  accom)HY(pa)HY(nied)YH( by the revi)HY(sion)YH( incre)HY(ment)YH( to main)HY(tain)YH( contin)HY(u)HY(ous)YH( version)HY(ing)YH(. As
  a result, each revi)HY(sion)YH( release commit neces)HY(sar)HY(ily)YH( also contains the changes
  in this revi)HY(sion)YH(. Below is a typical work)HY(flow)YH( for releas)HY(ing)YH( and publish)HY(ing)YH(
  the revi)HY(sion)YH(:)EP(

  ) 8 37 PR($ # make changes
$ # test locally
$ git add .
$ bdep release --revision --show-push
$ # review commit
$ git push ...
$ # test with CI
$ bdep publish)RP(

  )0 P(Custom)HY(ar)HY(ily)YH(, the revi)HY(sion)YH( commit message has the )SM("Release version
  X.Y.Z+R")ES( summary as gener)HY(ated)YH( by )SM(bdep-release)ES( followed
  by the descrip)HY(tion)YH( of changes, orga)HY(nized)YH( in a list if there are several. For
  example:)EP(

  ) 6 68 PR(Release version 2.1.0+1

- Don't compile port/strlcpy.c on Linux if GNU libc is 2.38 or newer
  since it now provides the strl*\201\202 functions.

- Switch to using -pthread instead of -D_REENTRANT/-lpthread.)RP(

  )BR(
  )0 P(The fact that all the changes must be in a single commit is another
  reason to avoid substan)HY(tial)YH( changes in revi)HY(sions)YH(.)EP(
  )BR(

  )0 P(Note also that you can make multi)HY(ple)YH( commits while devel)HY(op)HY(ing)YH( and testing
  the changes for a revi)HY(sion)YH( in a sepa)HY(rate)YH( branch. However, once they are
  ready for a release, they need to be squashed into a single commit. The )0 2 A()SM()BD(bdep-release\2011\202)ES()ES()EA(
  command provides the )SM(--amend)ES( and )SM(--squash)ES( options
  to auto)HY(mate)YH( this. For example, here is what a work)HY(flow)YH( with a sepa)HY(rate)YH(
  branch might look like:)EP(

  ) 22 63 PR($ git checkout -b wip-2.1.0+1

$ # make strl*\201\202 changes
$ # test locally
$ git commit -a -m "Omit port/strlcpy.c if glibc 2.38 or newer"
$ git push -u
$ # test with CI

$ # make pthread changes
$ # test locally
$ git commit -a -m "Switch to using -pthread"
$ git push
$ # test with CI

$ git checkout master
$ git merge --ff-only wip-2.1.0+1
$ bdep release --revision --show-push --amend --squash 2
$ # review commit
$ # test locally
$ git push ...
$ # test with CI
$ bdep publish)RP(

  )0 3 66 H(2.11.2)WB 172 Sn()WB 68 Sn( New version)EH(

  )0 P(As discussed in )0 66 1 A(Package version
  manage)HY(ment)YH()66 0 TN TL()Ec /AF f D(, we release new versions strictly in response to the
  corre)HY(spond)HY(ing)YH( upstream releases.)EP(

  )0 P(The amount or work required to upgrade a package to a new upstream
  version depends on the extend of changes in the new version.)EP(

  )0 P(On one extreme you may have a patch release which fixes a couple of bugs
  in the upstream source code without any changes to the set of source files,
  upstream build system, etc. In such cases, upgrad)HY(ing)YH( a package is a simple
  matter of creat)HY(ing)YH( a new work branch, point)HY(ing)YH( the )SM(upstream)ES(
  )SM(git)ES( submod)HY(ule)YH( to the new release, running tests, and then
  merging, releas)HY(ing)YH(, and publish)HY(ing)YH( a new package version.)EP(

  )0 P(On the other extreme you may have a new major upstream release which is
  essen)HY(tially)YH( a from-scratch rewrite with new source code layout, differ)HY(ent)YH(
  upstream build system, etc. In such cases it may be easier to like)HY(wise)YH( start
  from scratch. Specif)HY(i)HY(cally)YH(, create a new work branch, point the
  )SM(upstream)ES( )SM(git)ES( submod)HY(ule)YH( to the new release, delete
  the exist)HY(ing)YH( package, and continue from )0 12 1 A(Create
  package and gener)HY(ate)YH( )SM(build)HY(file)YH()ES( templates)12 0 TN TL()Ec /AF f D(.)EP(

  )0 P(Most of the time, however, it will be some)HY(thing)YH( in between where you may
  need to tweak a few things here and there, such as adding symlinks to new
  source files \201or remov)HY(ing)YH( old ones\202, tweak)HY(ing)YH( the )SM(build)HY(files)YH()ES( to
  reflect changes in the upstream build system, etc.)EP(

  )0 P(The follow)HY(ing)YH( sections provide a check)HY(list)YH(-like sequence of steps that
  can be used to review upstream changes with links to the rele)HY(vant)YH( earlier
  sections in case adjust)HY(ments)YH( are required.)EP(

  )0 3 67 H(2.11.3)WB 173 Sn()WB 69 Sn( New version:
  create new work branch)EH(

  )0 P(When upgrad)HY(ing)YH( a package to a new upstream version it's recom)HY(mended)YH( to do
  this in a new work branch which, upon comple)HY(tion)YH(, is merged into
  )SM(master)ES( \201or equiv)HY(a)HY(lent)YH(\202. For example, if the new upstream
  version is )SM(2.2.0)ES(:)EP(

  ) 1 27 PR($ git checkout -b wip-2.2.0)RP(

  )BR(
  )0 P(If you are not the main)HY(tainer)YH( of the package and would like to help with
  prepar)HY(ing)YH( the new version, then, when every)HY(thing)YH( is ready, use this branch
  to create a pull request instead of merging it directly.)EP(
  )BR(

  )0 3 68 H(2.11.4)WB 174 Sn()WB 70 Sn( New version: open
  new version)EH(

  )0 P(This step corre)HY(sponds)YH( to )0 18 1 A(Adjust
  package version)18 0 TN TL()Ec /AF f D( during the initial pack)HY(ag)HY(ing)YH(. Here we can make use of
  the )SM(bdep-release)ES( command to auto)HY(mat)HY(i)HY(cally)YH( open the new version
  and make the corre)HY(spond)HY(ing)YH( commit. For example, if the new upstream version
  is )SM(2.2.0)ES(:)EP(

  ) 1 49 PR($ bdep release --open --no-push --open-base 2.2.0)RP(

  )0 3 69 H(2.11.5)WB 175 Sn()WB 71 Sn( New version:
  update )SM(upstream)ES( submod)HY(ule)YH()EH(

  )0 P(This step corre)HY(sponds)YH( to )0 11 1 A(Add upstream
  repos)HY(i)HY(tory)YH( as )SM(git)ES( submod)HY(ule)YH()11 0 TN TL()Ec /AF f D( during the initial pack)HY(ag)HY(ing)YH(.
  Here we need to update the submod)HY(ule)YH( to point to the upstream commit that
  corre)HY(sponds)YH( to the new version.)EP(

  )0 P(For example, if the upstream release tag we are inter)HY(ested)YH( in is called
  )SM(v2.2.0)ES(, to update the )SM(upstream)ES( submod)HY(ule)YH( to point
  to this release commit, run the follow)HY(ing)YH( commands:)EP(

  ) 8 52 PR($ cd upstream/
$ git fetch
$ git checkout v2.2.0
$ cd ../

$ git add .
$ git status
$ git commit -m "Update upstream submodule to 2.2.0")RP(

  )0 3 70 H(2.11.6)WB 176 Sn()WB 72 Sn( New version:
  review upstream changes)EH(

  )0 P(At this point it's a good idea to get an overview of the upstream changes
  between the two releases in order to deter)HY(mine)YH( which adjust)HY(ments)YH( are likely
  to be required in the )SM(build2)ES( package. We can use the
  )SM(upstream)ES( submod)HY(ule)YH( for that, which contains the change history
  we need.)EP(

  )0 P(One way to get an overview of changes between the releases is to use a
  graph)HY(i)HY(cal)YH( repos)HY(i)HY(tory)YH( browser such as )SM(gitk)ES( and view a cumu)HY(la)HY(tive)YH(
  )SM(diff)ES( of changes between the two versions. For example, assum)HY(ing)YH(
  the latest pack)HY(aged)YH( version is tagged )SM(v2.1.0)ES( and the new
  version is tagged )SM(v2.2.0)ES(:)EP(

  ) 2 23 PR($ cd upstream/
$ gitk v2.1.0..v2.2.0 &)RP(

  )0 P(Then click on the commit tagged )SM(v2.2.0)ES(, scroll down and
  right-click on the commit tagged )SM(v2.1.0)ES(, and select the "Diff
  this -> selected" menu item. This will display the cumu)HY(la)HY(tive)YH( set of changes
  between these two upstream versions. Review them looking for the follow)HY(ing)YH(
  types of changes in partic)HY(u)HY(lar)YH( \201discussed in the follow)HY(ing)YH( sections\202:)EP(

  )UL(  )-1 LI(Changes to the source code layout.

  )-1 LI(New depen)HY(den)HY(cies)YH( being added or old removed.

  )-1 LI(New source files being added or old removed \201includ)HY(ing)YH( in tests,
  etc\202.

  )-1 LI(Changes to the upstream build system.

  )-1 LI(Other new files/subdi)HY(rec)HY(to)HY(ries)YH( being added or old removed.
  )LU(

  )0 3 71 H(2.11.7)WB 177 Sn()WB 73 Sn( New version:
  layout changes)EH(

  )0 P(As mentioned earlier, for drastic layout changes it may make sense to
  start from scratch and re-gener)HY(ate)YH( the package with the
  )SM(bdep-new)ES( command \201use )0 14 1 A(Decide on
  the package source code layout)14 0 TN TL()Ec /AF f D( as a start)HY(ing)YH( point\202. On the other hand,
  if the changes are minor, then you can try to adjust things manu)HY(ally)YH(. An
  in-between strat)HY(egy)YH( is to gener)HY(ate)YH( the new layout using
  )SM(bdep-new)ES( on the side and then retrofit the rele)HY(vant)YH( changes in
  )SM(build)HY(files)YH()ES( to the exist)HY(ing)YH( package. In a sense, this approach
  uses )SM(bdep-new)ES( as a guide to figure out how to imple)HY(ment)YH( the new
  layout.)EP(

  )0 3 72 H(2.11.8)WB 178 Sn()WB 74 Sn( New
  version: new/old depen)HY(den)HY(cies)YH()EH(

  )0 P(If upstream added new or removed old depen)HY(den)HY(cies)YH(, then you will need to
  repli)HY(cate)YH( these changes in your package as in the )0 21 1 A(Add depen)HY(den)HY(cies)YH()21 0 TN TL()Ec /AF f D( and )0 29 1 A(Adjust source
  )SM(build)HY(file)YH()ES(: depen)HY(den)HY(cies)YH()29 0 TN TL()Ec /AF f D( initial pack)HY(ag)HY(ing)YH( steps.)EP(

  )0 3 73 H(2.11.9)WB 179 Sn()WB 75 Sn( New version:
  new/old source files)EH(

  )0 P(If upstream added new or removed old source files, then you will need to
  repli)HY(cate)YH( these changes in your package as in the )0 22 1 A(Fill with upstream source code)22 0 TN TL()Ec /AF f D( and possi)HY(bly)YH( )0 26 1 A(Adjust header
  )SM(build)HY(file)YH()ES()26 0 TN TL()Ec /AF f D( and )0 31 1 A(Adjust source
  )SM(build)HY(file)YH()ES(: sources, private headers)31 0 TN TL()Ec /AF f D( initial pack)HY(ag)HY(ing)YH(
  steps.)EP(

  )0 P(Also don't forget about tests, exam)HY(ples)YH(, etc., which may also add new or
  remove old source files \201typi)HY(cally)YH( new tests\202. See )0 48 1 A(Convert smoke test to upstream
  tests)48 0 TN TL()Ec /AF f D(.)EP(

  )0 P(If there are any manual modi)HY(fi)HY(ca)HY(tions)YH( to the upstream source code, then
  you will also need to re-apply them to the new version as discussed in )0 94 1 A(Modi)HY(fy)HY(ing)YH( upstream source code
  manu)HY(ally)YH()94 0 TN TL()Ec /AF f D(.)EP(

  )0 3 74 H(2.11.10)WB 180 Sn()WB 76 Sn( New version:
  changes to build system)EH(

  )0 P(If upstream changed anything in the build system, then you may need to
  repli)HY(cate)YH( these changes in your package's )SM(build)HY(files)YH()ES(. The
  rele)HY(vant)YH( initial pack)HY(ag)HY(ing)YH( steps are: )0 24 1 A(Adjust project-wide build system files in
  )SM(build/)ES()24 0 TN TL()Ec /AF f D( and )0 32 1 A(Adjust source
  )SM(build)HY(file)YH()ES(: build and export options)32 0 TN TL()Ec /AF f D(.)EP(

  )0 P(The corre)HY(spond)HY(ing)YH( steps for tests are: )0 39 1 A(Adjust project-wide build system files in
  )SM(tests/build/)ES()39 0 TN TL()Ec /AF f D( and )0 48 1 A(Convert smoke test to upstream
  tests)48 0 TN TL()Ec /AF f D(.)EP(

  )0 3 75 H(2.11.11)WB 181 Sn()WB 77 Sn( New version:
  other new/old files/subdi)HY(rec)HY(to)HY(ries)YH()EH(

  )0 P(If upstream added or removed any other files or subdi)HY(rec)HY(to)HY(ries)YH( that are
  rele)HY(vant)YH( to our package \201such as docu)HY(men)HY(ta)HY(tion)YH(\202, then adjust the package
  similar to the )0 53 1 A(Adjust root
  )SM(build)HY(file)YH()ES()53 0 TN TL()Ec /AF f D( and )0 54 1 A(Adjust
  root )SM(build)HY(file)YH()ES(: other subdi)HY(rec)HY(to)HY(ries)YH()54 0 TN TL()Ec /AF f D( initial pack)HY(ag)HY(ing)YH(
  steps.)EP(

  )0 3 76 H(2.11.12)WB 182 Sn()WB 78 Sn( New version:
  review )SM(mani)HY(fest)YH()ES( and )SM(PACKAGE-README.md)ES()EH(

  )0 P(It makes sense to review the package )SM(mani)HY(fest)YH()ES( \201)0 56 1 A(Adjust )SM(mani)HY(fest)YH()ES()56 0 TN TL()Ec /AF f D(\202 and
  )SM(PACKAGE-README.md)ES( \201)0 60 1 A(Adjust
  )SM(PACKAGE-README.md)ES()60 0 TN TL()Ec /AF f D(\202 for any updates.)EP(

  )0 3 77 H(2.11.13)WB 183 Sn()WB 79 Sn( New version:
  review repos)HY(i)HY(tory)YH( )SM(README.md)ES()EH(

  )0 P(If any new pack)HY(ages)YH( were added in this version or if there are any
  changes to the devel)HY(op)HY(ment)YH( work)HY(flow)YH(, then it makes sense to review and if
  neces)HY(sary)YH( update package repos)HY(i)HY(tory)YH( )SM(README.md)ES( \201)0 61 1 A(Adjust package repos)HY(i)HY(tory)YH(
  )SM(README.md)ES()61 0 TN TL()Ec /AF f D(\202.)EP(

  )0 3 78 H(2.11.14)WB 184 Sn()WB 80 Sn( New version:
  review/fix accu)HY(mu)HY(lated)YH( issues)EH(

  )0 P(When a bug is iden)HY(ti)HY(fied)YH( in an already released package version, we may
  not always be able to fix it imme)HY(di)HY(ately)YH( \201for example, by )0 67 1 A(releas)HY(ing)YH( a revi)HY(sion)YH()67 0 TN TL()Ec /AF f D(\202. This
  could be because the change is too exten)HY(sive)YH(/risky for a revi)HY(sion)YH( or simply
  not crit)HY(i)HY(cal)YH( enough to warrant a release. In such cases it's recom)HY(mended)YH( to
  file an issue in the package repos)HY(i)HY(tory)YH( with the view to fix it when the
  next oppor)HY(tu)HY(nity)YH( arises. Releas)HY(ing)YH( a new upstream version is one such
  oppor)HY(tu)HY(nity)YH( and it makes sense to review any accu)HY(mu)HY(lated)YH( package issues and
  see if any of them could be addressed.)EP(

  )0 3 79 H(2.11.15)WB 185 Sn()WB 81 Sn( New version: test
  locally and with CI)EH(

  )0 P(Once all the adjust)HY(ments)YH( are in, test the package both locally and with
  CI similar to how we did it during the initial pack)HY(ag)HY(ing)YH( after complet)HY(ing)YH(
  the smoke test:)EP(

  )0 P()0 42 1 A(Test locally)42 0 TN TL()Ec /AF f D(
  )BR(  )0 43 1 A(Test locally: instal)HY(la)HY(tion)YH()43 0 TN TL()Ec /AF f D(
  )BR(  )0 44 1 A(Test locally: distri)HY(bu)HY(tion)YH()44 0 TN TL()Ec /AF f D(
  )BR(  )0 45 1 A(Commit and test with CI)45 0 TN TL()Ec /AF f D()EP(

  )0 3 80 H(2.11.16)WB 186 Sn()WB 82 Sn( New version:
  merge, release, and publish)EH(

  )0 P(When the new version of the package is ready to be released, merge the
  work branch to )SM(master)ES( \201or equiv)HY(a)HY(lent)YH(\202:)EP(

  ) 2 31 PR($ git checkout master
$ git merge --ff-only wip-2.2.0)RP(

  )0 P(Then release and publish using the same steps as after the initial
  pack)HY(ag)HY(ing)YH(: )0 62 1 A(Release and publish)62 0 TN TL()Ec /AF f D(.)EP(

  )0 3 81 H(2.11.17)WB 187 Sn()WB 83 Sn( New version/revi)HY(sion)YH( in
  old release series)EH(

  )0 P(As discussed in )0 66 1 A(Package version
  manage)HY(ment)YH()66 0 TN TL()Ec /AF f D(, if we have already switched to the next upstream version in
  the )SM(master)ES( \201or equiv)HY(a)HY(lent)YH(\202 branch, we cannot go back and
  release a new version or revi)HY(sion)YH( for an older release series on the same
  branch. Instead, we need to create a sepa)HY(rate)YH(, long-lived branch for this
  work.)EP(

  )0 P(As an example, let's say we need to release another revi)HY(sion)YH( or a patch
  version for an already released )SM(2.1.0)ES( while our
  )SM(master)ES( branch has already moved on to )SM(2.2.0)ES(. In
  this case we create a new branch, called )SM(2.1)ES(, to continue with
  the )SM(2.1.Z)ES( release series. The start)HY(ing)YH( point of this branch
  should be the latest released version/revi)HY(sion)YH( in the )SM(2.1)ES(
  series. Let's say in our case it is )SM(2.1.0+2)ES(, meaning we have
  released two revi)HY(sions)YH( for )SM(2.1.0)ES( on the )SM(master)ES(
  branch before upgrad)HY(ing)YH( to )SM(2.2.0)ES(. There)HY(fore)YH( we use the
  )SM(v2.1.0+2)ES( release tag to start the )SM(2.1)ES( branch:)EP(

  ) 1 30 PR($ git checkout -b 2.1 v2.1.0+2)RP(

  )0 P(Once this is done, we continue with the same steps as in )0 67 1 A(New revi)HY(sion)YH()67 0 TN TL()Ec /AF f D( or )0 68 1 A(New version)68 0 TN TL()Ec /AF f D( except that we
  never merge this branch to )SM(master)ES(. If we ever need to release
  another revi)HY(sion)YH( or version in this release series, then we continue using
  this branch. In a sense, this branch becomes the equiv)HY(a)HY(lent)YH( of the
  )SM(master)ES( branch for this release series and you should treat it
  as such \201once published, never delete, rewrite its history, etc\202.)EP(

  )BR(
  )0 P(It is less likely but possi)HY(ble)YH( that you may need to release a new minor
  version in an old release series. For example, the master branch may have
  moved on to )SM(3.0.0)ES( and you want to release )SM(2.2.0)ES(
  after the already released )SM(2.1.0)ES(. In this case it makes sense
  to call the branch )SM(2)ES( since it corre)HY(sponds)YH( to the
  )SM(2.Y.Z)ES( release series. If you already have the )SM(2.1)ES(
  branch, then it makes sense to rename it to )SM(2)ES(.)EP(
  )BR(

  )0 1 82 H(3)WB 188 Sn()WB 84 Sn( What Not to Do)EH(

  )0 P(This chapter describes the common anti-patterns along with the
  recom)HY(mended)YH( alter)HY(na)HY(tive)YH( approaches.)EP(

  )0 2 83 H(3.1)WB 189 Sn()WB 85 Sn( Don't write )SM(build)HY(files)YH()ES( from
  scratch, use )SM(bdep-new)ES()EH(

  )0 P(Unless you have good reasons not to, create the initial project layout
  auto)HY(mat)HY(i)HY(cally)YH( using )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(,
  then tweak it if neces)HY(sary)YH( and fill with upstream source code.)EP(

  )0 P(The main ratio)HY(nale)YH( here is that there are many nuances in getting the
  build right and auto-gener)HY(ated)YH( )SM(build)HY(files)YH()ES( had years of
  refine)HY(ment)YH( and fine-tuning. The famil)HY(iar)YH( struc)HY(ture)YH( also makes it easier for
  others to under)HY(stand)YH( your build, for example while review)HY(ing)YH( your package
  submis)HY(sion)YH( or helping out with the package main)HY(te)HY(nance)YH(.)EP(

  )0 P(The )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA(
  command supports a wide variety of )0 2 A(source layouts)EA(. While it
  may take a bit of time to under)HY(stand)YH( the customiza)HY(tion)YH( points neces)HY(sary)YH( to
  achieve the desired layout for your first package, this will pay off in
  spades when you work on convert)HY(ing)YH( subse)HY(quent)YH( pack)HY(ages)YH(.)EP(

  )0 P(See )0 15 1 A(Craft )SM(bdep\240new)ES(
  command line to create package)15 0 TN TL()Ec /AF f D( for details.)EP(

  )0 2 84 H(3.2)WB 190 Sn()WB 86 Sn( Avoid fixing upstream issues in the
  )SM(build2)ES( package)EH(

  )0 P(Any devi)HY(a)HY(tions)YH( from upstream makes the )SM(build2)ES( package more
  diffi)HY(cult)YH( to main)HY(tain)YH(. In partic)HY(u)HY(lar)YH(, if you make a large number of changes
  to the upstream source code, releas)HY(ing)YH( a new version will require a lot of
  work. As a result, it is recom)HY(mended)YH( to avoid fixing upstream issues in the
  )SM(build2)ES( package. Instead, try to have the issues fixed upstream
  and wait for them to be released as a new version.)EP(

  )0 P(Some)HY(times)YH(, however, you may have no choice. For example, upstream is
  inac)HY(tive)YH( or has no plans to release a new version with your fixes any time
  soon. Or you may want to add support for a plat)HY(form)YH(/compiler that upstream
  is not willing or capable of support)HY(ing)YH(.)EP(

  )0 P(Note that even if you do fix some issues in the )SM(build2)ES(
  package directly, try hard to also incor)HY(po)HY(rate)YH( them upstream so that you
  don't need to main)HY(tain)YH( the patches forever.)EP(

  )0 P(See also )0 87 1 A(Avoid chang)HY(ing)YH( upstream source
  code layout)87 0 TN TL()Ec /AF f D( and )0 93 1 A(How do I patch
  upstream source code?)93 0 TN TL()Ec /AF f D()EP(

  )0 2 85 H(3.3)WB 191 Sn()WB 87 Sn( Avoid chang)HY(ing)YH( upstream source code
  layout)EH(

  )0 P(It's a good idea to stay as close to the upstream's source code layout as
  possi)HY(ble)YH(. For back)HY(ground)YH( and ratio)HY(nale)YH(, see )0 14 1 A(Decide on the package source code
  layout)14 0 TN TL()Ec /AF f D(.)EP(

  )0 2 86 H(3.4)WB 192 Sn()WB 88 Sn( Don't make library header-only if it can be
  compiled)EH(

  )0 P(Some libraries offer two alter)HY(na)HY(tive)YH( modes: header-only and compiled.
  Unless there are good reasons not to, a )SM(build2)ES( build of such a
  library should use the compiled mode.)EP(

  )BR(
  )0 P(Some libraries use the )I(precom)HY(piled)YH()ES( term to describe the
  non-header-only mode. We don't recom)HY(mend)YH( using this term in the
  )SM(build2)ES( package since it has a strong asso)HY(ci)HY(a)HY(tion)YH( with
  precom)HY(piled)YH( headers and can there)HY(fore)YH( be confus)HY(ing)YH(. Instead, use the
  )I(compiled)ES( term.)EP(
  )BR(

  )0 P(The main ratio)HY(nale)YH( here is that a library would not be offer)HY(ing)YH( a
  compiled mode if there were no bene)HY(fits)YH( \201usually faster compile times of
  library consumers\202 and there is no reason not to take advan)HY(tage)YH( of it in the
  )SM(build2)ES( package.)EP(

  )0 P(There are, however, valid reasons why a compiled mode cannot be used, the
  most common of which are:)EP(

  )UL(  )-1 LI(The compiled mode is not well main)HY(tained)YH(/tested by upstream and
  there)HY(fore)YH( offers infe)HY(rior)YH( user expe)HY(ri)HY(ence)YH(.

  )-1 LI(The compiled mode does not work on some plat)HY(forms)YH(, usually Windows due
  to the lack of symbol export support \201but see )0 2 A(Auto)HY(matic)YH(
  DLL Symbol Export)HY(ing)YH()EA(\202.

  )-1 LI(Uses of the compiled version of the library requires changes to the
  library consumers, for example, inclu)HY(sion)YH( of differ)HY(ent)YH( headers.
  )LU(

  )0 P(If a compiled mode cannot always be used, then it may be tempt)HY(ing)YH( to
  support both modes by making the mode user-config)HY(urable)YH(. Unless there are
  strong reasons to, you should resist this temp)HY(ta)HY(tion)YH( and, if the compiled
  mode is not univer)HY(sally)YH( usable, then use the header-only mode
  every)HY(where)YH(.)EP(

  )0 P(The main ratio)HY(nale)YH( here is that vari)HY(abil)HY(ity)YH( adds complex)HY(ity)YH( which makes
  the result more prone to bugs, more diffi)HY(cult)YH( to use, and harder to review
  and main)HY(tain)YH(. If you really want to have the compiled mode, then the right
  way to achieve it is to work with upstream to fix any issues that prevent
  its use in )SM(build2)ES(.)EP(

  )0 P(There are, however, valid reasons why support)HY(ing)YH( both modes may be
  needed, the most common of which are:)EP(

  )UL(  )-1 LI(The library is widely used in both modes but switch)HY(ing)YH( from one mode to
  the other requires changes to the library consumers \201for example, inclu)HY(sion)YH(
  of differ)HY(ent)YH( headers\202. In this case only support)HY(ing)YH( one mode would mean not
  support)HY(ing)YH( a large number of library consumers.

  )-1 LI(The library consists of a large number of inde)HY(pen)HY(dent)YH( compo)HY(nents)YH( while
  its common for appli)HY(ca)HY(tions)YH( to only use a small subset of them. And
  compil)HY(ing)YH( all of them in the compiled mode takes a substan)HY(tial)YH( amount of
  time.  Note that this can alter)HY(na)HY(tively)YH( be addressed by making the pres)HY(ence)YH(
  of optional compo)HY(nents)YH( user-config)HY(urable)YH(.
  )LU(

  )0 2 87 H(3.5)WB 193 Sn()WB 89 Sn( Don't bundle depen)HY(den)HY(cies)YH()EH(

  )0 P(Some)HY(times)YH( third-party projects bundle their depen)HY(den)HY(cies)YH( with their
  source code \201also called vendor)HY(ing)YH(\202. For example, a C++ library may bundle a
  testing frame)HY(work)YH(. This is espe)HY(cially)YH( common with )R20 2 A()SM(catch2)ES()EA( where one often
  encoun)HY(ters)YH( a comical situ)HY(a)HY(tion)YH( with only a few kilo)HY(bytes)YH( of library source
  code and over 600KB of )SM(catch2.hpp)ES(.)EP(

  )0 P(The extra size, while waste)HY(ful)YH(, is not the main issue, however. The
  bigger problem is that if a bug is fixed in the bundled depen)HY(dency)YH(, then to
  prop)HY(a)HY(gate)YH( the fix we will need to release a new version \201or revi)HY(sion)YH(\202 of
  each package that bundles it. Need)HY(less)YH( to say this is not scal)HY(able)YH(.)EP(

  )0 P(While this doesn't apply to testing frame)HY(works)YH(, an even bigger issue with
  bundling of depen)HY(den)HY(cies)YH( in general is that two libraries that bundle the
  same depen)HY(dency)YH( \201poten)HY(tially)YH( of differ)HY(ent)YH( versions\202 may not be able to
  coexist in the same build with the symp)HY(toms)YH( ranging from compile errors to
  subtle runtime issues that are hard to diag)HY(nose)YH(.)EP(

  )0 P(As a result, it is strongly recom)HY(mended)YH( that you unbun)HY(dle)YH( any
  depen)HY(den)HY(cies)YH( that upstream may have bundled. In case of testing frame)HY(works)YH(,
  see )R12 2 A(How
  do I handle tests that have extra depen)HY(den)HY(cies)YH(?)EA( for the recom)HY(mended)YH( way
  to deal with such cases.)EP(

  )BR(
  )0 P(One special case where a bundled depen)HY(dency)YH( may be warranted is a small
  utility that is completely inline/private to the imple)HY(men)HY(ta)HY(tion)YH( and where
  making it an exter)HY(nal)YH( depen)HY(dency)YH( may lead to a less perfor)HY(mant)YH( result \201due
  to the inabil)HY(ity)YH( to inline without resort)HY(ing)YH( to LTO\202. The
  )SM(xxhash)ES( imple)HY(men)HY(ta)HY(tion)YH( in )SM(libzstd)ES( is a
  repre)HY(sen)HY(ta)HY(tive)YH( example of this situ)HY(a)HY(tion)YH(.)EP(
  )BR(

  )0 2 88 H(3.6)WB 194 Sn()WB 90 Sn( Don't build your main targets
  in the root )SM(build)HY(file)YH()ES()EH(

  )0 P(It may be tempt)HY(ing)YH( to have your main targets \201libraries, executa)HY(bles)YH(\202 in
  the root )SM(build)HY(file)YH()ES(, espe)HY(cially)YH( if it allows you to symlink
  entire direc)HY(to)HY(ries)YH( from )SM(upstream/)ES( \201which is not possi)HY(ble)YH( if you
  have to have a )SM(build)HY(file)YH()ES( inside\202. However, this is not
  recom)HY(mended)YH( except for the simplest of projects.)EP(

  )0 P(Firstly, this quickly gets messy since you have to combine manag)HY(ing)YH(
  )SM(README)ES(, )SM(LICENSE)ES(, etc., and subdi)HY(rec)HY(to)HY(ries)YH( with
  your main target builds. More impor)HY(tantly)YH(, this also means that when your
  main target is imported \201and thus the )SM(build)HY(file)YH()ES( that defines
  this target must be loaded\202, your entire project will be loaded, includ)HY(ing)YH(
  any )SM(tests/)ES( and )SM(exam)HY(ples)YH(/)ES( subpro)HY(jects)YH(, and that is
  waste)HY(ful)YH(.)EP(

  )0 P(If you want to continue symlink)HY(ing)YH( entire direc)HY(to)HY(ries)YH( from
  )SM(upstream/)ES( but without moving every)HY(thing)YH( to the root
  )SM(build)HY(file)YH()ES(, the recom)HY(mended)YH( approach is to simply add another
  subdi)HY(rec)HY(tory)YH( level. Let's look at a few concrete example to illus)HY(trate)YH( the
  tech)HY(nique)YH( \201see )0 14 1 A(Decide on the package source
  code layout)14 0 TN TL()Ec /AF f D( for back)HY(ground)YH( on the termi)HY(nol)HY(ogy)YH( used\202.)EP(

  )0 P(Here is the direc)HY(tory)YH( struc)HY(ture)YH( of a package which uses a combined layout
  \201no header/source split\202 and where the library target is in the root
  )SM(build)HY(file)YH()ES(:)EP(

  ) 4 61 PR(libigl-core/
|-- igl/ -> ../upstream/igl/
|-- tests/
\267-- buildfile                        # Defines lib{igl-core}.)RP(

  )0 P(And here is the alter)HY(na)HY(tive)YH( struc)HY(ture)YH( where we have added the extra
  )SM(libigl-core)ES( subdi)HY(rec)HY(tory)YH( with its own
  )SM(build)HY(file)YH()ES(:)EP(

  ) 6 63 PR(libigl-core/
|-- libigl-core/
|\302\240\302\240 |-- igl/ -> ../../upstream/igl/
|\302\240\302\240 \267-- buildfile                    # Defines lib{igl-core}.
|-- tests/
\267-- buildfile)RP(

  )0 P(Below is the )SM(bdep-new)ES( invo)HY(ca)HY(tion)YH( that can be used to
  auto)HY(mat)HY(i)HY(cally)YH( create this alter)HY(na)HY(tive)YH( struc)HY(ture)YH( \201see )0 15 1 A(Craft )SM(bdep\240new)ES( command line
  to create package)15 0 TN TL()Ec /AF f D( for back)HY(ground)YH( and )0 2 A()SM()BD(bdep-new\2011\202)ES()ES()EA( for
  details\202:)EP(

  ) 3 63 PR($ bdep new \200
 --type lib,prefix=libigl-core,subdir=igl,buildfile-in-prefix \200
 libigl-core)RP(

  )0 P(Let's also look at an example of the split layout, which may require a
  slightly differ)HY(ent)YH( )SM(bdep-new)ES( sub-options to achieve the same
  result. Here is the layout which matched upstream exactly:)EP(

  ) 10 62 PR($ bdep new --type lib,split,subdir=foo,no-subdir-source libfoo
$ tree libfoo
libfoo/
|-- include/
|\302\240\302\240 \267-- foo/
|\302\240\302\240     |-- buildfile
|\302\240\302\240     \267-- ...
\267-- src/
    |-- buildfile
    \267-- ...)RP(

  )0 P(However, with this layout we will not be able to symlink the entire
  )SM(include/foo/)ES( and )SM(src/)ES( subdi)HY(rec)HY(to)HY(ries)YH( because there
  are )SM(build)HY(files)YH()ES( inside \201and which may tempt you to just move
  every)HY(thing)YH( to the root )SM(build)HY(file)YH()ES(\202. To fix this we can move the
  )SM(build)HY(files)YH()ES( out of source subdi)HY(rec)HY(tory)YH( )SM(foo/)ES( and
  into prefixes \201)SM(include/)ES( and )SM(src/)ES(\202 using the
  )SM(build)HY(file)YH(-in-prefix)ES( sub-option. And since )SM(src/)ES(
  doesn't have a source subdi)HY(rec)HY(tory)YH(, we have to invent one:)EP(

  ) 9 65 PR($ bdep new --type lib,split,subdir=foo,buildfile-in-prefix libfoo
$ tree libfoo
libfoo/
|-- include/
|\302\240\302\240 |-- foo/ -> ../../upstream/include/foo/
|\302\240\302\240 \267-- buildfile
\267-- src/
    |-- foo/ -> ../../upstream/src/
    \267-- buildfile)RP(

  )0 2 89 H(3.7)WB 195 Sn()WB 91 Sn( Don't make exten)HY(sive)YH( changes in a
  revi)HY(sion)YH()EH(

  )0 P(Unlike a new version, a revi)HY(sion)YH( replaces the previ)HY(ous)YH( revi)HY(sion)YH( of the
  same version and as a result must be strictly back)HY(wards)YH(-compat)HY(i)HY(ble)YH( in all
  aspects with what it replaces. If you make exten)HY(sive)YH( changes in a revi)HY(sion)YH(,
  it becomes diffi)HY(cult)YH( to guar)HY(an)HY(tee)YH( that this require)HY(ment)YH( is satis)HY(fied)YH(. As a
  result, you should refrain from making major changes, like substan)HY(tially)YH(
  alter)HY(ing)YH( the build, in a revi)HY(sion)YH(, instead delay)HY(ing)YH( such changes until the
  next version.)EP(

  )0 1 90 H(4)WB 196 Sn()WB 92 Sn( Pack)HY(ag)HY(ing)YH( HOWTO)EH(

  )0 P(This chapter provides advice on how to handle less common pack)HY(ag)HY(ing)YH( tasks
  and require)HY(ments)YH(.)EP(

  )0 2 91 H(4.1)WB 197 Sn()WB 93 Sn( How do I patch upstream source
  code?)EH(

  )0 P(If you need to change some)HY(thing)YH( in the upstream source code, there are
  several options: You can make a copy of the upstream source file and make
  the modi)HY(fi)HY(ca)HY(tions)YH( there. While straight)HY(for)HY(ward)YH(, this approach has one major
  draw)HY(back)YH(: you will have to keep re-apply)HY(ing)YH( the changes for every subse)HY(quent)YH(
  version unless and until upstream incor)HY(po)HY(rates)YH( your changes. The other two
  options try to work around this draw)HY(back)YH(.)EP(

  )0 P(The first alter)HY(na)HY(tive)YH( option is to modify the upstream source code
  auto)HY(mat)HY(i)HY(cally)YH( during the build, typi)HY(cally)YH( using an ad hoc recipe. This
  approach works best when the changes are regular and can be applied
  mechan)HY(i)HY(cally)YH( with some)HY(thing)YH( like the )0 2 A()SM(sed)ES(
  builtin)EA(.)EP(

  )0 P(The second alter)HY(na)HY(tive)YH( option is to use the C/C++ prepro)HY(ces)HY(sor)YH( to make
  the neces)HY(sary)YH( changes to the upstream source code during compi)HY(la)HY(tion)YH(. Unlike
  the first alter)HY(na)HY(tive)YH(, this approach doesn't have a prescribed way to apply
  it in every situ)HY(a)HY(tion)YH( and often requires some imag)HY(i)HY(na)HY(tion)YH(. Note that it also
  has the tendency to quickly get out of hand, at which point it's wise to
  keep it simple and use the first option \201manual modi)HY(fi)HY(ca)HY(tion)YH(\202.)EP(

  )0 P(The follow)HY(ing)YH( sections examine each approach in detail.)EP(

  )0 3 92 H(4.1.1)WB 198 Sn()WB 94 Sn( Modi)HY(fy)HY(ing)YH( upstream source
  code manu)HY(ally)YH()EH(

  )0 P(As an illus)HY(tra)HY(tion)YH( of this approach, let's say we need to patch
  )SM(src/foo.cpp)ES( in our )SM(libfoo)ES( example from the
  previ)HY(ous)YH( sections \201see the )0 22 1 A(Fill with upstream
  source code)22 0 TN TL()Ec /AF f D( step for a refresher\202. The recom)HY(mended)YH( sequence of steps is
  as follows:)EP(

  )4 OL(  )-1 LI(Rename the upstream symlink to )SM(.orig)ES(:

  ) 2 25 PR($ cd libfoo/src/
$ mv foo.cpp foo.cpp.orig)RP(

  )-1 LI(Make a deep copy of )SM(.orig)ES(:

  ) 1 28 PR($ cp -H foo.cpp.orig foo.cpp)RP(

  )-1 LI(Make any neces)HY(sary)YH( modi)HY(fi)HY(ca)HY(tions)YH( in the deep copy:

  ) 1 14 PR($ edit foo.cpp)RP(

  )-1 LI(Create a patch for the modi)HY(fi)HY(ca)HY(tions)YH(:

  ) 1 45 PR($ diff -u foo.cpp.orig foo.cpp >foo.cpp.patch)RP(
  )LO(

  )0 P(The pres)HY(ence)YH( of the )SM(.orig)ES( and )SM(.patch)ES( files
  makes it clear that the upstream code was modi)HY(fied)YH(. They are also useful
  when re-apply)HY(ing)YH( the changes to the new version of the upstream source code.
  The recom)HY(mended)YH( sequence of steps for this task is as follows:)EP(

  )4 OL(  )-1 LI(After the )SM(upstream)ES( submod)HY(ule)YH( update \201see the )0 71 1 A(New version: update
  )SM(upstream)ES( submod)HY(ule)YH()71 0 TN TL()Ec /AF f D( step\202, the )SM(.orig)ES( symlink
  points to the new version of the upstream source file.

  )-1 LI(Over)HY(write)YH( old modi)HY(fied)YH( version with a deep copy of new
  )SM(.orig)ES(:

  ) 1 28 PR($ cp -H foo.cpp.orig foo.cpp)RP(

  )-1 LI(Apply old modi)HY(fi)HY(ca)HY(tions)YH( to the new deep copy:

  ) 1 22 PR($ patch <foo.cpp.patch)RP(

  )0 P(If some hunks of the patch could not be applied, manu)HY(ally)YH( resolve any
  conflicts.)EP(

  )-1 LI(If in the previ)HY(ous)YH( step the patch did not apply cleanly, regen)HY(er)HY(ate)YH( it:

  ) 1 45 PR($ diff -u foo.cpp.orig foo.cpp >foo.cpp.patch)RP(
  )LO(

  )0 3 93 H(4.1.2)WB 199 Sn()WB 95 Sn( Modi)HY(fy)HY(ing)YH( upstream source
  code during build)EH(

  )0 P(As an illus)HY(tra)HY(tion)YH( of this approach, let's say upstream is using the
  )SM(${VAR})ES( style vari)HY(able)YH( substi)HY(tu)HY(tions)YH( in their
  )SM(config.h.cmake)ES( instead of the more tradi)HY(tional)YH(
  )SM(@VAR@)ES( style:)EP(

  ) 3 40 PR(/* config.h.cmake */

#define FOO_VERSION "${PROJECT_VERSION}")RP(

  )0 P(The )SM(${VAR})ES( style is not supported by the )SM(build2)ES(
  )R27 2 A()SM(auto)HY(conf)YH()ES()EA(
  module which means we cannot use the upstream )SM(config.h.cmake)ES( as
  is. While we could patch this file manu)HY(ally)YH( to use )SM(@VAR@)ES(
  instead, this is a pretty mechan)HY(i)HY(cal)YH( change that can be easily made with a
  simple ad hoc recipe during the build, freeing us from manu)HY(ally)YH( apply)HY(ing)YH( the
  same changes in subse)HY(quent)YH( versions. For example:)EP(

  ) 12 51 PR(using autoconf

h{config}: in{config.h.in}
{
  autoconf.flavor = cmake
  PROJECT_VERSION = $version
}

in{config.h.in}: file{config.h.cmake}
{{
  sed -e 's/\200$\200{\201.+\202\200}/@\2001@/g' $path\201$<\202 >$path\201$>\202
}})RP(

  )0 3 94 H(4.1.3)WB 200 Sn()WB 96 Sn( Modi)HY(fy)HY(ing)YH( upstream source
  code with C/C++ prepro)HY(ces)HY(sor)YH()EH(

  )0 P(A good illus)HY(tra)HY(tion)YH( of this approach is adding the )SM(build2)ES(
  meta)HY(data)YH( to an executable \201see )R26 2 A(How
  do I convey addi)HY(tional)YH( infor)HY(ma)HY(tion)YH( \201meta)HY(data)YH(\202 with executa)HY(bles)YH( and C/C++
  libraries?)EA( for back)HY(ground)YH(\202. Let's say we have a symlink to upstream's
  )SM(main.c)ES( that imple)HY(ments)YH( the executable's )SM(main\201\202)ES(
  func)HY(tion)YH( and we need to add a snipped of code at the begin)HY(ning)YH( of this
  func)HY(tion)YH( that handles the )SM(--build2-meta)HY(data)YH()ES( option. While
  manu)HY(ally)YH( modi)HY(fy)HY(ing)YH( )SM(main.c)ES( is not a wrong approach, we can try
  to be clever and do it auto)HY(mat)HY(i)HY(cally)YH( with the prepro)HY(ces)HY(sor)YH(.)EP(

  )0 P(Specif)HY(i)HY(cally)YH(, we can create another file next to the )SM(main.c)ES(
  symlink, calling it, for example, )SM(main-build2.c)ES(, with the
  follow)HY(ing)YH( contents:)EP(

  ) 22 68 PR(/* Handle --build2-metadata in main\201\202 \201see also buildfile\202. */

#define main xmain
#include "main.c"
#undef main

#include <stdio.h>
#include <string.h>

int main \201int argc, const char** argv\202
{
  if \201argc == 2 && strncmp \201argv[1], "--build2-metadata=", 18\202 == 0\202
  {
    printf \201"# build2 buildfile foo\200n"\202;
    printf \201"export.metadata = 1 foo\200n"\202;
    printf \201"foo.name = [string] foo\200n"\202;
    ...
    return 0;
  }

  return xmain \201argc, argv\202;
})RP(

  )0 P(The idea here is to rename the orig)HY(i)HY(nal)YH( )SM(main\201\202)ES( with the help
  of the C prepro)HY(ces)HY(sor)YH( and provide our own )SM(main\201\202)ES( which, after
  handling )SM(--build2-meta)HY(data)YH()ES( calls the orig)HY(i)HY(nal)YH(. One notable
  deal-breaker for this approach would be a C++ imple)HY(men)HY(ta)HY(tion)YH( of
  )SM(main\201\202)ES( that doesn't have the explicit )SM(return)ES(.
  There is also a better chance in C++ for the )SM(main)ES( macro to
  replace some)HY(thing)YH( unin)HY(tended)YH(.)EP(

  )0 P(To complete this we also need to modify our )SM(build)HY(file)YH()ES( to
  exclude )SM(main.c)ES( from compi)HY(la)HY(tion)YH( \201since it is compiled as part
  of )SM(main-build2.c)ES( via the prepro)HY(ces)HY(sor)YH( inclu)HY(sion)YH(\202. For
  example:)EP(

  ) 2 64 PR(exe{foo}: {h c}{** -main}
exe{foo}: c{main}: include = adhoc  # Included in main-build2.c.)RP(

  )0 2 95 H(4.2)WB 201 Sn()WB 97 Sn( How do I deal with bad header
  inclu)HY(sion)YH( prac)HY(tice)YH(?)EH(

  )0 P(This section explains how to deal with libraries that include their
  public, gener)HY(i)HY(cally)YH(-named headers without the library name as a subdi)HY(rec)HY(tory)YH(
  prefix. Such libraries cannot coexist, neither in the same build nor when
  installed.)EP(

  )0 P(Specif)HY(i)HY(cally)YH(, as an illus)HY(tra)HY(tion)YH( of the problem, consider the
  )SM(libfoo)ES( library with a public header named )SM(util.h)ES(
  that is included as )SM(<util.h>)ES( \201instead of, say,
  )SM(<libfoo/util.h>)ES( or )SM(<foo/util.h>)ES(\202. If this
  library's headers are installed directly into, say,
  )SM(/usr/include)ES(, then if two such libraries happened to be
  installed at the same time, then one will over)HY(write)YH( the other's header.
  There are also prob)HY(lems)YH( in the non-installed case: if two such libraries are
  used by the same project, then which )SM(<util.h>)ES( header gets
  included depends on which library's header search path ends up being
  spec)HY(i)HY(fied)YH( first on the command line \201with the )SM(-I)ES( option\202.)EP(

  )0 P(These issues are severe enough that libraries with such inclu)HY(sion)YH( issues
  cannot be published to )R1 2 A(cppget.org)EA( without
  them being addressed in the )SM(build2)ES( package. Thank)HY(fully)YH(, most
  library authors these days use the library name as an inclu)HY(sion)YH( prefix \201or
  some)HY(times)YH( they have headers that are deco)HY(rated)YH( with the library name\202.
  However, libraries that do not follow these guide)HY(lines)YH( do exist and this
  section describes how to change their inclu)HY(sion)YH( scheme if you are attempt)HY(ing)YH(
  to package one of them.)EP(

  )BR(
  )0 P(One notable conse)HY(quence)YH( of chang)HY(ing)YH( the inclu)HY(sion)YH( scheme is that it will
  no longer be possi)HY(ble)YH( to use a system-installed version of the package
  \201because it presum)HY(ably)YH( still uses the unqual)HY(i)HY(fied)YH( inclu)HY(sion)YH( scheme\202. Note,
  however, that distri)HY(bu)HY(tions)YH( like Debian and Fedora have the same
  co-exis)HY(tence)YH( issue as we do and are gener)HY(ally)YH( strict about poten)HY(tial)YH( header
  clashes. In partic)HY(u)HY(lar)YH(, it is not uncom)HY(mon)YH( to find Debian pack)HY(ages)YH(
  installing library headers into subdi)HY(rec)HY(to)HY(ries)YH( of )SM(/usr/include)ES(
  to avoid such clashes. And if you find this to be the case for the library
  you are pack)HY(ag)HY(ing)YH(, then it may make sense to use the same prefix as used by
  the main distri)HY(bu)HY(tions)YH( for compat)HY(i)HY(bil)HY(ity)YH(.)EP(

  )0 P(It is also possi)HY(ble)YH( that distri)HY(bu)HY(tions)YH( disre)HY(gard)YH( these consid)HY(er)HY(a)HY(tions)YH( for
  some libraries. This usually happens for older, well-known libraries that
  happened to be installed this way in the early days and chang)HY(ing)YH( things now
  will be too disrup)HY(tive)YH(. In a sense, it is under)HY(stood)YH( that such libraries
  effec)HY(tively)YH( "own" the unqual)HY(i)HY(fied)YH( header names that they happen to be using.
  If you think you are pack)HY(ag)HY(ing)YH( such a library, )R10 2 A(get in touch)EA( to discuss
  this further since it may make sense to also disre)HY(gard)YH( this rule in )R1 2 A(cppget.org)EA(.)EP(
  )BR(

  )0 P(As a concrete example of the approach, let's continue with
  )SM(libfoo)ES( that has )SM(util.h)ES( and which upstream expects
  the users to include as )SM(<util.h>)ES(. The is what the upstream
  source code layout may look like:)EP(

  ) 5 16 PR(libfoo/
|-- include/
|\302\240\302\240 \267-- util.h
\267-- src/
    \267-- ...)RP(

  )0 P(Our plan is to change the inclu)HY(sion)YH( scheme in the )SM(build2)ES(
  package from )SM(<util.h>)ES( to )SM(<libfoo/util.h>)ES(. To
  this effect, we use a slightly modi)HY(fied)YH( layout for our package \201see )0 15 1 A(Craft )SM(bdep new)ES( command line to
  create package)15 0 TN TL()Ec /AF f D( on how to achieve it\202:)EP(

  ) 6 57 PR(libfoo/
|-- include/
|\302\240\302\240 \267-- libfoo/
|\302\240\302\240     \267-- util.h  -> ../../../upstream/include/util.h
\267-- src/
    \267-- ...          -> ../../upstream/src/...)RP(

  )0 P(The instal)HY(la)HY(tion)YH(-related section in our )0 26 1 A(header )SM(build)HY(file)YH()ES()26 0 TN TL()Ec /AF f D( will
  look like this:)EP(

  ) 8 62 PR(# Install into the libfoo/ subdirectory of, say, /usr/include/
# recreating subdirectories.
#
{hxx ixx txx}{*}:
{
  install         = include/libfoo/
  install.subdirs = true
})RP(

  )0 P(In the )0 27 1 A(source
  )SM(build)HY(file)YH()ES()27 0 TN TL()Ec /AF f D( we will most likely need to add the
  )SM(include/libfoo)ES( header search path since the upstream source
  files continue to include public headers without the library prefix \201there
  should be no harm in that and it's not worth modi)HY(fy)HY(ing)YH( them\202:)EP(

  ) 15 57 PR(# Build options.
#
out_pfx_inc = [dir_path] $out_root/include/
src_pfx_inc = [dir_path] $src_root/include/
out_pfx_src = [dir_path] $out_root/src/
src_pfx_src = [dir_path] $src_root/src/

# Unqualified \201without <libfoo/...>\202 header search paths.
#
out_pfx_inc_unq = [dir_path] $out_root/include/libfoo
src_pfx_inc_unq = [dir_path] $src_root/include/libfoo

cxx.poptions =+ "-I$out_pfx_src" "-I$src_pfx_src" \200
                "-I$out_pfx_inc" "-I$src_pfx_inc" \200
                "-I$out_pfx_inc_unq" "-I$src_pfx_inc_unq")RP(

  )0 P(It is also possi)HY(ble)YH( that public headers include each other as
  )SM(<util.h>)ES( rather than the more common )SM("util.h")ES(.
  If that's the case, then we need to fix that and there are two ways to do
  it. The first approach is to patch the public headers to include each other
  with the library prefix \201that is, )SM(<libfoo/util.h>)ES(, etc\202. See
  )0 93 1 A(How do I patch upstream source
  code?)93 0 TN TL()Ec /AF f D( for details.)EP(

  )0 P(The second approach is to support includ)HY(ing)YH( public headers both ways,
  that is, as )SM(<libfoo/util.h>)ES( and as )SM(<util.h>)ES(.
  This will not only solve the above problem \201public headers includ)HY(ing)YH( each
  other\202, but also support any exist)HY(ing)YH( code that uses this library and most
  likely includes its headers the old way, without the prefix.)EP(

  )0 P(There is, however, a major draw)HY(back)YH( to doing that: while the instal)HY(la)HY(tion)YH(
  of the library can now co-exist with other libraries \201because we install its
  public headers into, say, )SM(/usr/include/libfoo)ES(\202, it may still
  not be usable in combi)HY(na)HY(tion)YH( with other libraries from the same build
  \201because we still add the unqual)HY(i)HY(fied)YH( header search path\202.)EP(

  )0 P(If you still want to provide this dual inclu)HY(sion)YH( support, the way to
  achieve it is by export)HY(ing)YH( the unqual)HY(i)HY(fied)YH( header search path and also
  adding it to the )SM(pkg-config)ES( files \201see )0 98 1 A(How do I handle extra header
  instal)HY(la)HY(tion)YH( subdi)HY(rec)HY(tory)YH(?)98 0 TN TL()Ec /AF f D( for back)HY(ground)YH( on the latter\202. For
  example:)EP(

  ) 14 65 PR(# Export options.
#
lib{foo}:
{
  cxx.export.poptions = "-I$out_pfx_inc" "-I$src_pfx_inc" \200
                        "-I$out_pfx_inc_unq" "-I$src_pfx_inc_unq"
  cxx.export.libs = $intf_libs
}

# Make sure headers installed into, say, /usr/include/libfoo/
# can also be included without the directory prefix for backwards
# compatibility.
#
lib{foo}: cxx.pkgconfig.include = include/ include/libfoo/)RP(

  )0 2 96 H(4.3)WB 202 Sn()WB 98 Sn( How do I handle extra header
  instal)HY(la)HY(tion)YH( subdi)HY(rec)HY(tory)YH(?)EH(

  )0 P(This section explains how to handle an addi)HY(tional)YH( header instal)HY(la)HY(tion)YH(
  subdi)HY(rec)HY(tory)YH(. As an illus)HY(tra)HY(tion)YH( of the problem, consider the
  )SM(libfoo)ES( example from the previ)HY(ous)YH( sections \201see the )0 22 1 A(Fill with upstream source code)22 0 TN TL()Ec /AF f D( step for a
  refresher\202. In that example the library headers are included as
  )SM(<foo/util.hpp>)ES( and installed as, say,
  )SM(/usr/include/foo/util.hpp)ES(. In this scheme the installed header
  inclu)HY(sion)YH( works without requir)HY(ing)YH( any extra steps from our side because the
  compiler searches for header in )SM(/usr/include)ES( by default.)EP(

  )0 P(However, some libraries choose to install their headers into a
  subdi)HY(rec)HY(tory)YH( of, say, )SM(/usr/include)ES( but without having this
  subdi)HY(rec)HY(tory)YH( as part of the inclu)HY(sion)YH( path \201)SM(foo/)ES( in
  )SM(<foo/util.hpp>)ES(\202. The two typical reasons for this are
  support for installing multi)HY(ple)YH( versions of the same library side-by-side
  \201for example, )SM(/usr/include/foo-v1/foo/util.hpp)ES(\202 as well as not
  using the library name as the inclu)HY(sion)YH( subdi)HY(rec)HY(tory)YH( prefix and then having
  to hide the headers in a subdi)HY(rec)HY(tory)YH( due to poten)HY(tial)YH( clashes with other
  headers \201if installed directly into, say, )SM(/usr/include)ES(; see )0 97 1 A(How do I deal with bad header inclu)HY(sion)YH(
  prac)HY(tice)YH(?)97 0 TN TL()Ec /AF f D( for back)HY(ground)YH(\202.)EP(

  )0 P(In such cases the installed header inclu)HY(sion)YH( does not work out of the box
  and we have to arrange for an addi)HY(tional)YH( header search path to be added via
  )SM(pkg-config)ES(. Let's use the versioned library case to illus)HY(trate)YH(
  this tech)HY(nique)YH(. The rele)HY(vant)YH( part from the )0 26 1 A(header )SM(build)HY(file)YH()ES()26 0 TN TL()Ec /AF f D( will
  look like this:)EP(

  ) 8 66 PR(# Install into the foo-vN/foo/ subdirectory of, say, /usr/include/
# recreating subdirectories.
#
{hxx ixx txx}{*}:
{
  install         = include/"foo-v$version.major"/foo/
  install.subdirs = true
})RP(

  )0 P(The part that we need to add, this time to the )0 27 1 A(source )SM(build)HY(file)YH()ES()27 0 TN TL()Ec /AF f D(,
  looks like this:)EP(

  ) 5 65 PR(# Make sure headers installed into, say, /usr/include/foo-vN/foo/
# can be included as <foo/*.hpp> by overriding the header search
# path in the generated pkg-config files.
#
lib{foo}: cxx.pkgconfig.include = include/"foo-v$version.major"/)RP(

  )BR(
  )0 P(The vari)HY(able)YH( will be )SM(c.pkgcon)HY(fig)YH(.include)ES( for a C
  library.)EP(
  )BR(

  )0 2 97 H(4.4)WB 203 Sn()WB 99 Sn( How do I handle headers without an
  exten)HY(sion)YH(?)EH(

  )0 P(If all the headers in a project have no exten)HY(sion)YH(, then you can simply
  specify the empty )SM(exten)HY(sion)YH()ES( value for the )SM(hxx{})ES(
  target type in )SM(build/root.build)ES(:)EP(

  ) 2 23 PR(hxx{*}: extension =
cxx{*}: extension = cpp)RP(

  )0 P(Note, however, that using wild)HY(card)YH( patterns for such headers in your
  )SM(build)HY(file)YH()ES( is a bad idea since such a wild)HY(card)YH( will most likely
  pick up other files that also have no exten)HY(sion)YH( \201such as
  )SM(build)HY(file)YH()ES(, executa)HY(bles)YH( on UNIX-like systems, etc\202. Instead,
  it's best to spell the names of such headers explic)HY(itly)YH(. For example,
  instead of:)EP(

  ) 1 24 PR(lib{hello}: {hxx cxx}{*})RP(

  )0 P(Write:)EP(

  ) 1 29 PR(lib{hello}: cxx{*} hxx{hello})RP(

  )0 P(If only some headers in a project have no exten)HY(sion)YH(, then it's best to
  specify the non-empty exten)HY(sion)YH( for the )SM(exten)HY(sion)YH()ES( vari)HY(able)YH( in
  )SM(build/root.build)ES( \201so that you can still use wild)HY(cards)YH( for
  headers with exten)HY(sions)YH(\202 and spell out the headers with no exten)HY(sion)YH(
  explic)HY(itly)YH(. Contin)HY(u)HY(ing)YH( with the above example, if we have both the
  )SM(hello.hpp)ES( and )SM(hello)ES( headers, then we can handle
  them like this:)EP(

  ) 2 23 PR(hxx{*}: extension = hpp
cxx{*}: extension = cpp)RP(

  ) 1 36 PR(lib{hello}: {hxx cxx}{*} hxx{hello.})RP(

  )0 P(Notice the trail)HY(ing)YH( dot in )SM(hxx{hello.})ES( \235 this is the
  explicit "no exten)HY(sion)YH(" spec)HY(i)HY(fi)HY(ca)HY(tion)YH(. See )0 2 A(Targets and
  Target Types)EA( for details.)EP(

  )0 2 98 H(4.5)WB 204 Sn()WB 100 Sn( How do I expose extra debug macros of a
  library?)EH(

  )0 P(Some)HY(times)YH( libraries provide extra debug)HY(ging)YH( facil)HY(i)HY(ties)YH( that are usually
  enabled or disabled with a macro. For example, )SM(libfoo)ES( may
  provide the )SM(LIBFOO_DEBUG)ES( macro that enables addi)HY(tional)YH( sanity
  checks, tracing, etc. Normally, such facil)HY(i)HY(ties)YH( are disabled by default.)EP(

  )0 P(While it may seem like a good idea to detect a debug build and enable
  this auto)HY(mat)HY(i)HY(cally)YH(, it is not: such facil)HY(i)HY(ties)YH( usually impose substan)HY(tial)YH(
  over)HY(heads)YH( and the pres)HY(ence)YH( of debug infor)HY(ma)HY(tion)YH( does not mean that
  perfor)HY(mance)YH( is not impor)HY(tant)YH( \201people routinely make opti)HY(mized)YH( builds with
  debug infor)HY(ma)HY(tion)YH(\202.)EP(

  )0 P(As a result, the recom)HY(mended)YH( approach is to expose this as a
  config)HY(u)HY(ra)HY(tion)YH( vari)HY(able)YH( that the consumers of the library can use \201see )0 2 A(Project
  Config)HY(u)HY(ra)HY(tion)YH()EA( for back)HY(ground)YH(\202. Continue with the )SM(libfoo)ES(
  example, we can add )SM(config.libfoo.debug)ES( to its
  )SM(build/root.build)ES(:)EP(

  ) 3 42 PR(# build/root.build

config [bool] config.libfoo.debug ?= false)RP(

  )0 P(And then define the )SM(LIBFOO_DEBUG)ES( macro based on that in the
  )SM(build)HY(file)YH()ES(:)EP(

  ) 4 32 PR(# src/buildfile

if $config.libfoo.debug
  cxx.poptions += -DLIBFOO_DEBUG)RP(

  )0 P(If the macro is also used in the library's inter)HY(face)YH( \201for example, in
  inline or template func)HY(tions)YH(\202, then we will also need to export it \201see )0 32 1 A(Adjust source
  )SM(build)HY(file)YH()ES(: build and export options)32 0 TN TL()Ec /AF f D( for details\202:)EP(

  ) 7 49 PR(# src/buildfile

if $config.libfoo.debug
{
  cxx.poptions += -DLIBFOO_DEBUG
  lib{foo}: cxx.export.poptions += -DLIBFOO_DEBUG
})RP(

  )BR(
  )0 P(If the debug facil)HY(ity)YH( in ques)HY(tion)YH( should be enabled by default even in
  the opti)HY(mized)YH( builds \201in which case the macro usually has the
  )SM(NO_DEBUG)ES( seman)HY(tics)YH(\202, the other option is to hook it up to the
  stan)HY(dard)YH( )SM(NDEBUG)ES( macro, for example, in the library's
  config)HY(u)HY(ra)HY(tion)YH( header file.)EP(
  )BR(

  )0 P(Note that such )SM(.debug)ES( config)HY(u)HY(ra)HY(tion)YH( vari)HY(ables)YH( should
  primar)HY(ily)YH( be meant for the user to selec)HY(tively)YH( enable extra debug)HY(ging)YH(
  support in certain libraries of their build. However, if your project
  depends on a number of libraries with such extra debug)HY(ging)YH( support and it
  gener)HY(ally)YH( makes sense to also enable this support in depen)HY(den)HY(cies)YH( if it is
  enabled in your project, then you may want to prop)HY(a)HY(gate)YH( your
  )SM(.debug)ES( config)HY(u)HY(ra)HY(tion)YH( value to the depen)HY(den)HY(cies)YH( \201see the )0 2 A()SM(depends)ES(
  package )SM(mani)HY(fest)YH()ES( value)EA( for details on depen)HY(dency)YH(
  config)HY(u)HY(ra)HY(tion)YH(\202. You, however, should still allow the user to over)HY(ride)YH( this
  deci)HY(sion)YH( on the per-depen)HY(dency)YH( basis.)EP(

  )0 P(Contin)HY(u)HY(ing)YH( with the above example, let's say we have )SM(libbar)ES(
  with )SM(config.libbar.debug)ES( that depends on )SM(libfoo)ES(
  and wishes by default to enable debug)HY(ging)YH( in )SM(libfoo)ES( if it is
  enabled in )SM(libbar)ES(. This is how we can correctly arrange for
  this in )SM(libbar)ES('s )SM(mani)HY(fest)YH()ES(:)EP(

  ) 16 60 PR(depends:
\200
libfoo ^1.2.3
{
  # We prefer to enable debug in libfoo if enabled in libbar
  # but accept if it's disabled \201for example, by the user\202.
  #
  prefer
  {
    if $config.libbar.debug
      config.libfoo.debug = true
  }

  accept \201true\202
}
\200)RP(

  )0 1 99 H(5)WB 205 Sn()WB 101 Sn( Pack)HY(ag)HY(ing)YH( FAQ)EH(

  )0 2 100 H(5.1)WB 206 Sn()WB 102 Sn( Publish)HY(ing)YH( FAQ)EH(

  )0 3 101 H(5.1.1)WB 207 Sn()WB 103 Sn( Why is my package in )SM(alpha)ES(
  rather than )SM(stable)ES(?)EH(

  )0 P(If your package uses a semver version \201or semver-like, that is, has three
  version compo)HY(nents)YH(\202 and the first compo)HY(nent)YH( is zero \201for example,
  )SM(0.1.0)ES(\202, then, accord)HY(ing)YH( to the semver spec)HY(i)HY(fi)HY(ca)HY(tion)YH(, this is an
  alpha version and )0 2 A()SM()BD(bdep-publish\2011\202)ES()ES()EA(
  auto)HY(mat)HY(i)HY(cally)YH( published such a version to the )SM(alpha)ES( section of
  the repos)HY(i)HY(tory)YH(.)EP(

  )0 P(Some)HY(times)YH(, however, in a third-party package, while the version may look
  like semver, upstream may not assign the zero first compo)HY(nent)YH( any special
  meaning. In such cases you can over)HY(ride)YH( the )SM(bdep-publish)ES(
  behav)HY(ior)YH( with the )SM(--section)ES( option, for example:)EP(

  ) 1 31 PR($ bdep publish --section=stable)RP(

  )0 P(Note that you should only do this if you are satis)HY(fied)YH( that by having the
  zero first compo)HY(nent)YH( upstream does not imply alpha quality. Getting an
  explicit state)HY(ment)YH( to this effect from upstream is recom)HY(mended)YH(.)EP(

  )0 3 102 H(5.1.2)WB 208 Sn()WB 104 Sn( Where to publish if package requires staged
  toolchain?)EH(

  )0 P(If your package requires the )R48 2 A(staged toolchain)EA(, for
  example, because it needs a feature or bugfix that is not yet avail)HY(able)YH( in
  the released toolchain, then you won't be able to publish it to
  )SM(cppget.org)ES(. Specif)HY(i)HY(cally)YH(, if your package has the accu)HY(rate)YH(
  )SM(build2)ES( version constraint and you attempt to publish it, you
  will get an error like this:)EP(

  ) 3 72 PR(error: package archive is not valid
  info: unable to satisfy constraint \201build2 >= 0.17.0-\202 for package foo
  info: available build2 version is 0.16.0)RP(

  )0 P(There are three alter)HY(na)HY(tive)YH( ways to proceed in this situ)HY(a)HY(tion)YH(:)EP(

  )4 OL(  )-1 LI(Wait until the next release and then publish the package to
  )SM(cppget.org)ES(.

  )-1 LI(If the require)HY(ment)YH( for the staged toolchain is "minor", that is, it
  doesn't affect the common func)HY(tion)HY(al)HY(ity)YH( of the package or only affects a
  small subset of plat)HY(forms)YH(/compil)HY(ers)YH(, then you can lower the toolchain
  version require)HY(ment)YH( and publish the package to )SM(cppget.org)ES(. For
  example, if you require the staged toolchain because of a bugfix that only
  affects one plat)HY(form)YH(, it doesn't make sense to delay publish)HY(ing)YH( the package
  since it is perfectly usable on all the other plat)HY(forms)YH( in the
  mean)HY(time)YH(.

  )-1 LI(Publish it to )R8 2 A(queue.stage.build2.org)EA(, the
  staging package repos)HY(i)HY(tory)YH(. This repos)HY(i)HY(tory)YH( contain new pack)HY(ages)YH( that
  require the staged toolchain to work and which will be auto)HY(mat)HY(i)HY(cally)YH( moved
  to )SM(cppget.org)ES( once the staged version is released. The other
  advan)HY(tage)YH( of publish)HY(ing)YH( to this repos)HY(i)HY(tory)YH( \201besides not having to remem)HY(ber)YH(
  to manu)HY(ally)YH( publish the package once the staged version is released\202 is that
  your package becomes avail)HY(able)YH( from an archive repos)HY(i)HY(tory)YH(, which is
  substan)HY(tially)YH( faster than a )SM(git)ES( repos)HY(i)HY(tory)YH(.

  )0 P(To publish to this repos)HY(i)HY(tory)YH(, use the follow)HY(ing)YH(
  )SM(bdep-publish)ES( command line:)EP(

  ) 1 56 PR($ bdep publish --repository=https://stage.build2.org ...)RP(
  )LO(

  )0 3 103 H(5.1.3)WB 209 Sn()WB 105 Sn( Why "project owner authen)HY(ti)HY(ca)HY(tion)YH( failed"
  while publish)HY(ing)YH(?)EH(

  )0 P(If you are getting the follow)HY(ing)YH( error while attempt)HY(ing)YH( to publish a new
  version of a package:)EP(

  ) 3 42 PR($ bdep publish
...
error: project owner authentication failed)RP(

  )0 P(Then this means the remote )SM(git)ES( repos)HY(i)HY(tory)YH( you are using does
  not match the one from which you \201or someone else\202 has published the initial
  version of the package.)EP(

  )0 P(In )SM(build2)ES( we use the owner)HY(ship)YH( of the package
  )SM(git)ES( repos)HY(i)HY(tory)YH( as a proxy for the owner)HY(ship)YH( of the package name
  on )R1 2 A(cppget.org)EA(. Specif)HY(i)HY(cally)YH(, when you
  publish the package for the first time, we record the )SM(git)ES( URL
  for its package repos)HY(i)HY(tory)YH(. And any further versions of this package can
  only be submit)HY(ted)YH( by someone who has write access to this repos)HY(i)HY(tory)YH(. See )0 2 A()SM()BD(bdep-publish\2011\202)ES()ES()EA(
  for details.)EP(

  )0 P(Based on this back)HY(ground)YH(, the first step you need to take when getting
  the above owner authen)HY(ti)HY(ca)HY(tion)YH( error is to under)HY(stand)YH( its cause. For that,
  first use the )SM(git-config)ES( command to see the URL you are using
  locally:)EP(

  ) 1 36 PR($ git config --get remote.origin.url)RP(

  )0 P(Then look in the )R49 2 A()SM(git)ES(
  repos)HY(i)HY(to)HY(ries)YH()EA( that back )R1 2 A(cppget.org)EA( and
  )R7 2 A(queue.cppget.org)EA( and find the URL
  that is recorded in the )SM(owners/)ES( subdi)HY(rec)HY(tory)YH( in the
  corre)HY(spond)HY(ing)YH( )SM(package-owner.mani)HY(fest)YH()ES( file.)EP(

  )0 P(Note that your local URL will normally be SSH while the recorded URL will
  always be HTTPS. Provided that the host names match, the part to look in for
  differ)HY(ences)YH( is the path compo)HY(nent)YH(. One common cause of a mismatch is the
  missing )SM(.git)ES( exten)HY(sion)YH(. For example \201local first, recorded
  second\202:)EP(

  ) 2 44 PR(git@github.com:build2-packaging/zstd
https://github.com/build2-packaging/zstd.git)RP(

  )0 P(In this case adding the missing exten)HY(sion)YH( to the local URL should fix the
  error.)EP(

  )0 P(If, however, the discrep)HY(ancy)YH( is expected, for example, because you have
  renamed the package repos)HY(i)HY(tory)YH( or moved it to a new loca)HY(tion)YH(, the owner)HY(ship)YH(
  infor)HY(ma)HY(tion)YH( will need to be updated manu)HY(ally)YH(. In this case feel free to
  submit a pull request with the neces)HY(sary)YH( changes or )R10 2 A(get in touch)EA(.)EP(

)BR(

)WB NL
/TE t D NP /OU t D TU PM 1 eq and{/Pn () D showpage}if end restore
